//
//  NamedModelObject.swift
//  Remote
//
//  Created by Jason Cardwell on 10/18/14.
//  Copyright (c) 2014 Moondeer Studios. All rights reserved.
//

import Foundation
import CoreData
import MoonKit

private var existingNamesByClass: [String:NSMutableSet] = [:]

@objc(NamedModelObject)
class NamedModelObject: ModelObject, Renameable {

  /** save */
  func save() { if let moc = managedObjectContext { DataManager.saveContext(moc, propagate: true) } }

  /** delete */
  func delete() {
    if let moc = self.managedObjectContext {
      moc.performBlockAndWait { moc.processPendingChanges(); moc.deleteObject(self) }
      DataManager.saveContext(moc, propagate: true)
    }
  }

  /** rollback */
  func rollback() { if let moc = self.managedObjectContext { moc.performBlockAndWait { moc.rollback() } } }

  /** willSave */
  override func willSave() { if !deleted { _ = name } }

  var autoGeneratedName: String? {
    get {
      willAccessValueForKey("autoGeneratedName")
      var n = primitiveValueForKey("autoGeneratedName") as? String
      didAccessValueForKey("autoGeneratedName")
      if n == nil || n!.isEmpty {
        let base = autoGenerateName()
        let existingNames = self.dynamicType.existingNames
        var count = existingNames.count
        n = "\(base) \(count)"
        while existingNames.containsObject(n!) { n = "\(base) \(++count)" }
        setPrimitiveValue(n!, forKey: "autoGeneratedName")
        existingNamesByClass[className]?.addObject(n!)
      }
      return n
    }
    set {
      willChangeValueForKey("autoGeneratedName")
      setPrimitiveValue(newValue, forKey: "autoGeneratedName")
      didChangeValueForKey("autoGeneratedName")
    }
  }

  var name: String? {
    get {
      willAccessValueForKey("name")
      var n = primitiveValueForKey("name") as? String
      didAccessValueForKey("name")
      return n ?? autoGeneratedName
    }
    set {
      var shouldSetName = true
      if self.dynamicType.requiresUniqueNaming() && newValue != nil {
        if self.dynamicType.objectExistsWithName(newValue!) { shouldSetName = false }
      }
      if shouldSetName {
        let oldValue = primitiveValueForKey("name") as? String
        willChangeValueForKey("name")
        setPrimitiveValue(newValue, forKey: "name")
        didChangeValueForKey("name")
        if newValue != nil {
          existingNamesByClass[className]?.addObject(newValue!)
        } else if oldValue != nil {
          existingNamesByClass[className]?.removeObject(oldValue!)
        }
      }
    }
  }

  var commentedUUID: String { var uuid = self.uuid; if let n = name { uuid.comment = "// \(n)" }; return uuid }

  /**
  requiresUniqueNaming

  :returns: Bool
  */
  class func requiresUniqueNaming() -> Bool { return false }

  /**
  updateWithData:

  :param: data [NSObject:AnyObject]!
  */
  override func updateWithData(data: [NSObject:AnyObject]!) {
    super.updateWithData(data)
    if let n = data["name"] as? String { name = n }
  }

  /**
  JSONDictionary

  :returns: MSDictionary!
  */
  override func JSONDictionary() -> MSDictionary {
    let dictionary = super.JSONDictionary()
    if !isNameAutoGenerated { dictionary["name"] = name! }
    return dictionary
  }

  /**
  autoGenerateName

  :returns: String
  */
  func autoGenerateName() -> String { return className }

  var isNameAutoGenerated: Bool { return primitiveValueForKey("name") as? String == nil }

  /**
  objectExistsWithName:

  :param: name String

  :returns: Bool
  */
  class func objectExistsWithName(name: String) -> Bool { return existingNames.containsObject(name) }

  class var existingNames: NSSet {
    var names = existingNamesByClass[className()]
    if names == nil { names = NSMutableSet(); existingNamesByClass[className()] = names }

    if names!.count == 0 {
      let fetchRequest = NSFetchRequest(entityName: className())
      fetchRequest.resultType = .DictionaryResultType
      fetchRequest.propertiesToFetch = ["name", "autoGeneratedName"]
      var error: NSError?
      let moc = DataManager.mainContext()
      if let results = moc.executeFetchRequest(fetchRequest, error: &error) as? [[String:String]] {
        let allNames = flattened(results.map{Array($0.values)})
        names!.addObjectsFromArray(allNames)
      }
    }
    return names!
  }

}
