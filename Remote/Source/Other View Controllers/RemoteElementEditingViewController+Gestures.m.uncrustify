//

//  RemoteElementEditingViewController+Gestures.m
//  iPhonto
//
//  Created by Jason Cardwell on 2/15/13.
//  Copyright (c) 2013 Moondeer Studios. All rights reserved.
//

#import "RemoteElementEditingViewController_Private.h"
#import "RemoteElementView_Private.h"
#import "MultiSelectionGestureRecognizer.h"
#import "MSRemoteConstants.h"

#define UNDO_BUTTON_INDEX 2

static const int   ddLogLevel = LOG_LEVEL_DEBUG;

//static const int ddLogLevel = DefaultDDLogLevel
#pragma unused(ddLogLevel)

@implementation RemoteElementEditingViewController (Gestures) - (void)attachGestureRecognizers
{
	// long press to translate selected views
	////////////////////////////////////////////////////////////////////////////////
	self.longPressGesture = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(handleLongPress:)];_longPressGesture.tag      = LongPressGestureIndex;_longPressGesture.delegate = self;[self.view addGestureRecognizer:_longPressGesture];

	// pinch to scale selected views
	////////////////////////////////////////////////////////////////////////////////
	self.pinchGesture = [[UIPinchGestureRecognizer alloc]initWithTarget:self action:@selector(handlePinch:)];_pinchGesture.tag      = PinchGestureIndex;_pinchGesture.delegate = self;[self.view addGestureRecognizer:_pinchGesture];

	// double tap to set a focus view
	////////////////////////////////////////////////////////////////////////////////
	self.oneTouchDoubleTapGesture = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(handleTap:)];_oneTouchDoubleTapGesture.tag                  = OneTouchDoubleTapGestureIndex;_oneTouchDoubleTapGesture.numberOfTapsRequired = 2;_oneTouchDoubleTapGesture.delegate             = self;[self.view addGestureRecognizer:_oneTouchDoubleTapGesture];

	// drag/touch to select views
	////////////////////////////////////////////////////////////////////////////////
	self.multiSelectionGesture = [[MultiSelectionGestureRecognizer alloc]initWithTarget:self action:@selector(handleSelection:)];_multiSelectionGesture.tag      = MultiSelectionGestureIndex;_multiSelectionGesture.delegate = self;[_multiSelectionGesture requireGestureRecognizerToFail:_pinchGesture];[_multiSelectionGesture requireGestureRecognizerToFail:_oneTouchDoubleTapGesture];[self.view addGestureRecognizer:_multiSelectionGesture];

	// two finger pan to scroll if source view extends out of sight
	////////////////////////////////////////////////////////////////////////////////
	self.twoTouchPanGesture = [[UIPanGestureRecognizer alloc]initWithTarget:self action:@selector(handlePan:)];_twoTouchPanGesture.tag                    = TwoTouchPanGestureIndex;_twoTouchPanGesture.minimumNumberOfTouches = 2;_twoTouchPanGesture.maximumNumberOfTouches = 2;_twoTouchPanGesture.delegate               = self;[self.view addGestureRecognizer:_twoTouchPanGesture];[self.multiSelectionGesture requireGestureRecognizerToFail:_twoTouchPanGesture];_twoTouchPanGesture.enabled = NO;

	// long press to translate selected views
	////////////////////////////////////////////////////////////////////////////////
	self.toolbarLongPressGesture = [[UILongPressGestureRecognizer alloc]initWithTarget:self action:@selector(handleLongPress:)];_toolbarLongPressGesture.tag      = ToolbarLongPressGestureIndex;_toolbarLongPressGesture.delegate = self;[_longPressGesture requireGestureRecognizerToFail:_toolbarLongPressGesture];[_undoButton addGestureRecognizer:_toolbarLongPressGesture];
}  /* attachGestureRecognizers */

- (void)updateGesturesEnabled
{
	BOOL   focused = (_focusView ? YES : NO);BOOL   moving    = _flags.movingSelectedViews;BOOL   selection = (self.selectionCount > 0 ? YES : NO);_longPressGesture.enabled         = !focused;_pinchGesture.enabled             = selection;_oneTouchDoubleTapGesture.enabled = !moving;_twoTouchPanGesture.enabled       = _twoTouchPanGesture.enabled;_multiSelectionGesture.enabled    = !moving;
}

- (BOOL)gestureRecognizerShouldBegin:(UIGestureRecognizer *)gestureRecognizer
{
	/*
	 * Returns `NO` for the following conditions:
	 * - long press gesture and a `focusView` has been set.
	 * - pinch gesture and an empty selection.
	 * - double tap or multi-selection gesture and `flags.movingSelectedViews`.
	 * @param gestureRecognizer `UIGestureRecognizer` who's event reception is
	 *in question
	 * @return Whether `gestureRecognizer` should begin receiving events
	 */
	switch (gestureRecognizer.tag)
	{
		case LongPressGestureIndex :

			if (_focusView) return NO;

			break;

		case PinchGestureIndex :

			if (!self.selectionCount) return NO;

			break;

		case MultiSelectionGestureIndex :
		case OneTouchDoubleTapGestureIndex :

			if (_flags.movingSelectedViews) return NO;

			break;
	}  /* switch */

	return YES;
}

- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldReceiveTouch:(UITouch *)touch
{
	/*
	 * Returns `NO` for the following conditions:
	 * - long press gesture and a `focusView` has been set.
	 * - pinch gesture and an empty selection.
	 * - double tap or multi-selection gesture and `flags.movingSelectedViews`.
	 * @param gestureRecognizer `UIGestureRecognizer` who's touch reception is
	 *in question
	 * @param touch The `UITouch` to be received
	 * @return Whether `gestureRecognizer` should receive `touch`
	 */
	if (_flags.popoverActive || (_flags.menuState != REEditingMenuStateDefault)) return NO;

	for (UIToolbar * toolbar in self.toolbars)
		if ([touch.view isDescendantOfView:toolbar]) return (toolbar == _topToolbar && gestureRecognizer == _toolbarLongPressGesture);

	switch (gestureRecognizer.tag)
	{
		case LongPressGestureIndex :

			return (_focusView == nil);

		case ToolbarLongPressGestureIndex :

			return NO;

		case PinchGestureIndex :

			return (self.selectionCount > 0);

		case MultiSelectionGestureIndex :
		case OneTouchDoubleTapGestureIndex :

			return !_flags.movingSelectedViews;
	}

	return YES;
}

- (BOOL) gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
	NSSet * gestures = [NSSet setWithObjects:gestureRecognizer, otherGestureRecognizer, nil];return ([gestures containsObject:_longPressGesture] && [gestures containsObject:_toolbarLongPressGesture]);
}

- (IBAction)handleTap:(UITapGestureRecognizer *)gestureRecognizer
{
		assert(gestureRecognizer == _oneTouchDoubleTapGesture);

	if (( gestureRecognizer.tag == OneTouchDoubleTapGestureIndex) && ( gestureRecognizer.state == UIGestureRecognizerStateRecognized) )
	{
		UIView * view = [self.view hitTest:[gestureRecognizer locationInView:self.view] withEvent:nil];

		if ([view isKindOfClass:_selectableClass])
		{
			if (![_selectedViews containsObject:view]) [self selectView:(RemoteElementView *)view];

			self.focusView = (_focusView == view ? nil : (RemoteElementView *)view);
		}
	}
}

- (IBAction)handleLongPress:(UILongPressGestureRecognizer *)gestureRecognizer
{
	if (gestureRecognizer.tag == LongPressGestureIndex)
	{
		assert(gestureRecognizer == _longPressGesture);

		switch (gestureRecognizer.state)
		{
			case UIGestureRecognizerStateBegan :
			{UIView * view = [self.view hitTest:[gestureRecognizer locationInView:self.view] withEvent:nil];

			 if ([view isKindOfClass:_selectableClass])
			 {
				 if (![_selectedViews containsObject:view]) [self selectView:(RemoteElementView *)view];

				 for (RemoteElementView * view in _selectedViews) view.editingStyle = EditingStyleMoving;

				 _flags.movingSelectedViews = YES;[self updateState];_flags.longPressPreviousLocation = [gestureRecognizer locationInView:nil];[self willMoveSelectedViews];
			 }
			}
			break;

			case UIGestureRecognizerStateChanged :
			{CGPoint   currentLocation = [gestureRecognizer locationInView:nil];CGPoint   translation     = CGPointGetDelta(currentLocation, _flags.longPressPreviousLocation);_flags.longPressPreviousLocation = currentLocation;[self moveSelectedViewsWithTranslation:translation];}
																																																																					  break;

			case UIGestureRecognizerStateCancelled :
			case UIGestureRecognizerStateFailed :
			case UIGestureRecognizerStateEnded :
				[self didMoveSelectedViews];break;

			case UIGestureRecognizerStatePossible :
				break;
		}  /* switch */
	}
	else if (gestureRecognizer.tag == ToolbarLongPressGestureIndex)
	{
		switch (gestureRecognizer.state)
		{
			case UIGestureRecognizerStateBegan :
				[_undoButton.button setTitle:[UIFont fontAwesomeIconForName:@"repeat"] forState:UIControlStateNormal];_undoButton.button.selected = YES;break;

			case UIGestureRecognizerStateChanged :

				if (![_undoButton.buttonpointInside:[gestureRecognizer locationInView:_undoButton.button] withEvent:nil])
				{
					_undoButton.button.selected = NO;gestureRecognizer.enabled   = NO;
				}

				break;

			case UIGestureRecognizerStateRecognized :
				[self redo:nil];

			case UIGestureRecognizerStateCancelled :
			case UIGestureRecognizerStateFailed :
			case UIGestureRecognizerStatePossible :
				gestureRecognizer.enabled = YES;_undoButton.button.selected = NO;[_undoButton.button setTitle:[UIFont fontAwesomeIconForName:@"undo"] forState:UIControlStateNormal];break;
		}
	}
}

- (IBAction)handlePinch:(UIPinchGestureRecognizer *)gestureRecognizer
{
	if (gestureRecognizer.tag == PinchGestureIndex)
	{
		switch (gestureRecognizer.state)
		{
			case UIGestureRecognizerStateBegan :
				[self willScaleSelectedViews];break;

			case UIGestureRecognizerStateChanged :
				[self scaleSelectedViews:gestureRecognizer.scale validation:nil];break;

			case UIGestureRecognizerStateCancelled :
			case UIGestureRecognizerStateFailed :
			case UIGestureRecognizerStateEnded :
				[self didScaleSelectedViews];break;

			case UIGestureRecognizerStatePossible :
				break;
		}  /* switch */
	}
}

- (IBAction)handlePan:(UIPanGestureRecognizer *)gestureRecognizer
{
	static CGFloat   startingOffset = 0.0f;

	if (gestureRecognizer.tag == TwoTouchPanGestureIndex)
	{
		assert( gestureRecognizer.minimumNumberOfTouches == 2 && gestureRecognizer.maximumNumberOfTouches == 2);

		switch (gestureRecognizer.state)
		{
			case UIGestureRecognizerStateBegan :
				startingOffset = self.sourceViewCenterYConstraint.constant;break;

			case UIGestureRecognizerStateChanged :
			{CGPoint   translation = [gestureRecognizer translationInView:self.view];CGFloat   adjustedOffset = startingOffset + translation.y;BOOL      isInBounds     = MSValueInBounds(adjustedOffset, _flags.allowableSourceViewYOffset);CGFloat   newOffset      = (isInBounds ? adjustedOffset : (adjustedOffset < _flags.allowableSourceViewYOffset.lower ? _flags.allowableSourceViewYOffset.lower : _flags.allowableSourceViewYOffset.upper));

			 if (self.sourceViewCenterYConstraint.constant != newOffset)
			 {
				 [UIView animateWithDuration:0.1f delay:0.0f options:UIViewAnimationOptionBeginFromCurrentState animations:^{self.sourceViewCenterYConstraint.constant = newOffset;[self.view layoutIfNeeded];}

																																																																																																																	  completion:nil];
			 }
			}
			break;

			case UIGestureRecognizerStateCancelled :
			case UIGestureRecognizerStateFailed :
			case UIGestureRecognizerStateEnded :
			default :
				break;
		}  /* switch */
	}
}

- (IBAction)toggleSelected:(UIButton *)sender { sender.selected = !sender.selected; }

- (void)displayStackedViewDialogForViews:(NSSet *)stackedViews
{
	MSLogDebug(EDITORFILE_AND_CONSOLE, @"%@ select stacked views to include: (%@)",ClassTagSelectorString,[[[stackedViews allObjects] valueForKey:@"displayName"]componentsJoinedByString:@", "]);_flags.menuState = REEditingMenuStateStackedViews;MenuController.menuItems = [[stackedViews allObjects]arrayByMappingToBlock:^UIMenuItem *(RemoteElementView * obj, NSUInteger idx) {SEL action = NSSelectorFromString($(@"menuAction%@:",obj.identifier));return MenuItem(obj.displayName, action);}

																																																																			   ];[MenuController setTargetRect:[self.view.window convertRect:[UIViewunionFrameForViews:[stackedViews allObjects]] fromView:_sourceView] inView:self.view];MenuController.arrowDirection = UIMenuControllerArrowDefault;[MenuController update];MenuController.menuVisible = YES;
}

- (IBAction)handleSelection:(MultiSelectionGestureRecognizer *)gestureRecognizer
{
	if (gestureRecognizer.state == UIGestureRecognizerStateRecognized)
	{
		NSSet * touchLocations = [gestureRecognizer touchLocationsInView:_sourceView];NSSet        * touchedViews           = [gestureRecognizer touchedSubviewsInView:_sourceView];NSMutableSet * touchedSubelementViews = [[gestureRecognizer touchedSubviewsInView:_sourceView ofKind:_selectableClass] mutableCopy];

		if (touchedSubelementViews.count)
		{
			NSMutableDictionary * viewsPerTouch = [NSMutableDictionary dictionaryWithCapacity:touchLocations.count];[touchLocations enumerateObjectsUsingBlock:^(NSValue * obj, BOOL *stop) {NSArray * viewsForLocation = [_sourceView.subelementViewsfilteredArrayUsingPredicateWithBlock:^BOOL(RemoteElementView * evaluatedObject, NSDictionary *bindings) {return [evaluatedObject pointInside:[evaluatedObject convertPoint:Point(obj) fromView:_sourceView] withEvent:nil];}

																																																						  ];viewsPerTouch[obj] = (viewsForLocation.count ? viewsForLocation : NullObject);}

			];NSSet * stackedLocations = [viewsPerTouch keysOfEntriesPassingTest:^BOOL(id key, NSArray * obj, BOOL *stop) {return (obj.count > 1);}

										 ];

			if (stackedLocations.count)
			{
				NSSet * stackedViews = [NSSet setWithArrays:[viewsPerTouch allValues]];[touchedSubelementViews minusSet:stackedViews];[self selectViews:touchedSubelementViews];[self displayStackedViewDialogForViews:stackedViews];
			}
			else [self selectViews:touchedSubelementViews];}

		else if (_selectedViews.count) [self deselectAll];
	}
}

@end
