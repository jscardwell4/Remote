//
//  RemoteDrawingKit.swift
//  ProjectName
//
//  Created by Moondeer on 12/19/14.
//  Copyright (c) 2014 Moondeer Studios. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//



import UIKit

public class RemoteDrawingKit : NSObject {

    //// Cache

    private struct Cache {
        static var buttonBaseColor: UIColor = UIColor(red: 0.261, green: 0.258, blue: 0.258, alpha: 1.000)
        static var buttonStrokeColor: UIColor = RemoteDrawingKit.buttonBaseColor.colorWithHighlight(0.2)
        static var innerShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 2)
        static var outerShadow: NSShadow = NSShadow(color: UIColor.blackColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 2)
        static var strokeShadow: NSShadow = NSShadow(color: UIColor.lightGrayColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 1)
        static var insettingShadow: NSShadow = NSShadow(color: UIColor.whiteColor().colorWithAlphaComponent(0.5), offset: CGSizeMake(0.1, 0.6), blurRadius: 0)
        static var plasticShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSizeMake(0.1, -0.6), blurRadius: 1)
        static var cutoutShadow: NSShadow = NSShadow(color: UIColor.blackColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 4)
        static var glowingShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 5)
    }

    //// Colors

    public class var buttonBaseColor: UIColor { return Cache.buttonBaseColor }
    public class var buttonStrokeColor: UIColor { return Cache.buttonStrokeColor }

    //// Shadows

    public class var innerShadow: NSShadow { return Cache.innerShadow }
    public class var outerShadow: NSShadow { return Cache.outerShadow }
    public class var strokeShadow: NSShadow { return Cache.strokeShadow }
    public class var insettingShadow: NSShadow { return Cache.insettingShadow }
    public class var plasticShadow: NSShadow { return Cache.plasticShadow }
    public class var cutoutShadow: NSShadow { return Cache.cutoutShadow }
    public class var glowingShadow: NSShadow { return Cache.glowingShadow }

    //// Drawing Methods

    public class func drawRoundishButtonBase(#frame: CGRect, color: UIColor, radius: CGFloat) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.2)
        let gradientColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

        //// Gradient Declarations
        let gradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [gradientColor.CGColor, gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor, UIColor.whiteColor().CGColor], [0, 1, 1])


        //// Subframes
        let group2: CGRect = CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4)


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(roundedRect: CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4), cornerRadius: radius)
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.outerShadow.shadowOffset, RemoteDrawingKit.outerShadow.shadowBlurRadius, (RemoteDrawingKit.outerShadow.shadowColor as UIColor).CGColor)
        color.setFill()
        rectanglePath.fill()

        ////// Rectangle Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, rectanglePath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((RemoteDrawingKit.innerShadow.shadowColor as UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let rectangleOpaqueShadow = (RemoteDrawingKit.innerShadow.shadowColor as UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.innerShadow.shadowOffset, RemoteDrawingKit.innerShadow.shadowBlurRadius, (rectangleOpaqueShadow as UIColor).CGColor)
        CGContextSetBlendMode(context, kCGBlendModeSourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        rectangleOpaqueShadow.setFill()
        rectanglePath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.strokeShadow.shadowOffset, RemoteDrawingKit.strokeShadow.shadowBlurRadius, (RemoteDrawingKit.strokeShadow.shadowColor as UIColor).CGColor)
        strokeColor.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()
        CGContextRestoreGState(context)


        //// Group 2
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, kCGBlendModeSoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip Rectangle 3
        let rectangle3Path = UIBezierPath(roundedRect: CGRectMake(group2.minX + floor(group2.width * 0.00000 + 0.5), group2.minY + floor(group2.height * 0.00000 + 0.5), floor(group2.width * 1.00000 + 0.5) - floor(group2.width * 0.00000 + 0.5), floor(group2.height * 1.00000 + 0.5) - floor(group2.height * 0.00000 + 0.5)), cornerRadius: radius)
        rectangle3Path.addClip()


        //// Rectangle 2 Drawing
        let rectangle2Rect = CGRectMake(group2.minX + floor(group2.width * -0.02083 + 0.5), group2.minY + floor(group2.height * -0.03125 + 0.5), floor(group2.width * 1.02083 + 0.5) - floor(group2.width * -0.02083 + 0.5), floor(group2.height * 1.01042 + 0.5) - floor(group2.height * -0.03125 + 0.5))
        let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
        CGContextSaveGState(context)
        rectangle2Path.addClip()
        CGContextDrawLinearGradient(context, gradient,
            CGPointMake(rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, rectangle2Rect.midY + 50 * rectangle2Rect.height / 100),
            CGPointMake(rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, rectangle2Rect.midY + 0 * rectangle2Rect.height / 100),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawGloss(#frame: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let gradientColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

        //// Gradient Declarations
        let gradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [gradientColor.CGColor, gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor, UIColor.whiteColor().CGColor], [0, 1, 1])


        //// Subframes
        let group: CGRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)


        //// Group
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, kCGBlendModeSoftLight)
        CGContextBeginTransparencyLayer(context, nil)


        //// Rectangle Drawing
        let rectangleRect = CGRectMake(group.minX + floor(group.width * 0.00000 + 0.5), group.minY + floor(group.height * 0.00000 + 0.5), floor(group.width * 1.00000 + 0.5) - floor(group.width * 0.00000 + 0.5), floor(group.height * 1.00000 + 0.5) - floor(group.height * 0.00000 + 0.5))
        let rectanglePath = UIBezierPath(rect: rectangleRect)
        CGContextSaveGState(context)
        rectanglePath.addClip()
        CGContextDrawLinearGradient(context, gradient,
            CGPointMake(rectangleRect.midX + 0 * rectangleRect.width / 100, rectangleRect.midY + 50 * rectangleRect.height / 100),
            CGPointMake(rectangleRect.midX + 0 * rectangleRect.width / 100, rectangleRect.midY + 0 * rectangleRect.height / 100),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawRectangularButtonBase(#frame: CGRect, color: UIColor) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.2)
        let gradientColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

        //// Gradient Declarations
        let gradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [gradientColor.CGColor, gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor, UIColor.whiteColor().CGColor], [0, 1, 1])


        //// Subframes
        let group2: CGRect = CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4)


        //// Rectangle Drawing
        let rectanglePath = UIBezierPath(rect: CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4))
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.outerShadow.shadowOffset, RemoteDrawingKit.outerShadow.shadowBlurRadius, (RemoteDrawingKit.outerShadow.shadowColor as UIColor).CGColor)
        color.setFill()
        rectanglePath.fill()

        ////// Rectangle Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, rectanglePath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((RemoteDrawingKit.innerShadow.shadowColor as UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let rectangleOpaqueShadow = (RemoteDrawingKit.innerShadow.shadowColor as UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.innerShadow.shadowOffset, RemoteDrawingKit.innerShadow.shadowBlurRadius, (rectangleOpaqueShadow as UIColor).CGColor)
        CGContextSetBlendMode(context, kCGBlendModeSourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        rectangleOpaqueShadow.setFill()
        rectanglePath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.strokeShadow.shadowOffset, RemoteDrawingKit.strokeShadow.shadowBlurRadius, (RemoteDrawingKit.strokeShadow.shadowColor as UIColor).CGColor)
        strokeColor.setStroke()
        rectanglePath.lineWidth = 1
        rectanglePath.stroke()
        CGContextRestoreGState(context)


        //// Group 2
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, kCGBlendModeSoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip Rectangle 3
        let rectangle3Path = UIBezierPath(rect: CGRectMake(group2.minX + floor(group2.width * 0.00000 + 0.5), group2.minY + floor(group2.height * 0.00000 + 0.5), floor(group2.width * 1.00000 + 0.5) - floor(group2.width * 0.00000 + 0.5), floor(group2.height * 1.00000 + 0.5) - floor(group2.height * 0.00000 + 0.5)))
        rectangle3Path.addClip()


        //// Rectangle 2 Drawing
        let rectangle2Rect = CGRectMake(group2.minX + floor(group2.width * -0.01042 + 0.5), group2.minY + floor(group2.height * -0.02604) + 0.5, floor(group2.width * 1.03125 + 0.5) - floor(group2.width * -0.01042 + 0.5), floor(group2.height * 1.01562) - floor(group2.height * -0.02604))
        let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
        CGContextSaveGState(context)
        rectangle2Path.addClip()
        CGContextDrawLinearGradient(context, gradient,
            CGPointMake(rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, rectangle2Rect.midY + 50 * rectangle2Rect.height / 100),
            CGPointMake(rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, rectangle2Rect.midY + 0 * rectangle2Rect.height / 100),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawOvalButtonBase(#frame: CGRect, color: UIColor) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.2)
        let gradientColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

        //// Gradient Declarations
        let gradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [gradientColor.CGColor, gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor, UIColor.whiteColor().CGColor], [0, 1, 1])


        //// Subframes
        let group2: CGRect = CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4)


        //// Oval Drawing
        var ovalPath = UIBezierPath(ovalInRect: CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4))
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.outerShadow.shadowOffset, RemoteDrawingKit.outerShadow.shadowBlurRadius, (RemoteDrawingKit.outerShadow.shadowColor as UIColor).CGColor)
        color.setFill()
        ovalPath.fill()

        ////// Oval Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, ovalPath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((RemoteDrawingKit.innerShadow.shadowColor as UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let ovalOpaqueShadow = (RemoteDrawingKit.innerShadow.shadowColor as UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.innerShadow.shadowOffset, RemoteDrawingKit.innerShadow.shadowBlurRadius, (ovalOpaqueShadow as UIColor).CGColor)
        CGContextSetBlendMode(context, kCGBlendModeSourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        ovalOpaqueShadow.setFill()
        ovalPath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.strokeShadow.shadowOffset, RemoteDrawingKit.strokeShadow.shadowBlurRadius, (RemoteDrawingKit.strokeShadow.shadowColor as UIColor).CGColor)
        strokeColor.setStroke()
        ovalPath.lineWidth = 1
        ovalPath.stroke()
        CGContextRestoreGState(context)


        //// Group 2
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, kCGBlendModeSoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip Oval 2
        var oval2Path = UIBezierPath(ovalInRect: CGRectMake(group2.minX + floor(group2.width * 0.00000 + 0.5), group2.minY + floor(group2.height * 0.00000 + 0.5), floor(group2.width * 1.00000 + 0.5) - floor(group2.width * 0.00000 + 0.5), floor(group2.height * 1.00000 + 0.5) - floor(group2.height * 0.00000 + 0.5)))
        oval2Path.addClip()


        //// Rectangle 2 Drawing
        let rectangle2Rect = CGRectMake(group2.minX + floor(group2.width * -0.02083 + 0.5), group2.minY + floor(group2.height * -0.02083 + 0.5), floor(group2.width * 1.02083 + 0.5) - floor(group2.width * -0.02083 + 0.5), floor(group2.height * 1.02083 + 0.5) - floor(group2.height * -0.02083 + 0.5))
        let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
        CGContextSaveGState(context)
        rectangle2Path.addClip()
        CGContextDrawLinearGradient(context, gradient,
            CGPointMake(rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, rectangle2Rect.midY + 50 * rectangle2Rect.height / 100),
            CGPointMake(rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, rectangle2Rect.midY + 0 * rectangle2Rect.height / 100),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawDiamondButtonBase(#frame: CGRect, color: UIColor) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.2)
        let gradientColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

        //// Gradient Declarations
        let gradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [gradientColor.CGColor, gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor, UIColor.whiteColor().CGColor], [0, 1, 1])


        //// Subframes
        let group2: CGRect = CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4)


        //// Bezier Drawing
        var bezierPath = UIBezierPath()
        bezierPath.moveToPoint(CGPointMake(frame.minX + 2, frame.minY + 0.50000 * frame.height))
        bezierPath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 2))
        bezierPath.addLineToPoint(CGPointMake(frame.maxX - 2, frame.minY + 0.50000 * frame.height))
        bezierPath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.maxY - 2))
        bezierPath.addLineToPoint(CGPointMake(frame.minX + 2, frame.minY + 0.50000 * frame.height))
        bezierPath.closePath()
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.outerShadow.shadowOffset, RemoteDrawingKit.outerShadow.shadowBlurRadius, (RemoteDrawingKit.outerShadow.shadowColor as UIColor).CGColor)
        color.setFill()
        bezierPath.fill()

        ////// Bezier Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, bezierPath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((RemoteDrawingKit.innerShadow.shadowColor as UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let bezierOpaqueShadow = (RemoteDrawingKit.innerShadow.shadowColor as UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.innerShadow.shadowOffset, RemoteDrawingKit.innerShadow.shadowBlurRadius, (bezierOpaqueShadow as UIColor).CGColor)
        CGContextSetBlendMode(context, kCGBlendModeSourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        bezierOpaqueShadow.setFill()
        bezierPath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.strokeShadow.shadowOffset, RemoteDrawingKit.strokeShadow.shadowBlurRadius, (RemoteDrawingKit.strokeShadow.shadowColor as UIColor).CGColor)
        strokeColor.setStroke()
        bezierPath.lineWidth = 1
        bezierPath.stroke()
        CGContextRestoreGState(context)


        //// Group 2
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, kCGBlendModeSoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip Bezier 2
        var bezier2Path = UIBezierPath()
        bezier2Path.moveToPoint(CGPointMake(group2.minX + 0.00000 * group2.width, group2.minY + 0.50000 * group2.height))
        bezier2Path.addLineToPoint(CGPointMake(group2.minX + 0.50000 * group2.width, group2.minY + 0.00000 * group2.height))
        bezier2Path.addLineToPoint(CGPointMake(group2.minX + 1.00000 * group2.width, group2.minY + 0.50000 * group2.height))
        bezier2Path.addLineToPoint(CGPointMake(group2.minX + 0.50000 * group2.width, group2.minY + 1.00000 * group2.height))
        bezier2Path.addLineToPoint(CGPointMake(group2.minX + 0.00000 * group2.width, group2.minY + 0.50000 * group2.height))
        bezier2Path.closePath()
        bezier2Path.addClip()


        //// Rectangle 2 Drawing
        let rectangle2Rect = CGRectMake(group2.minX + floor(group2.width * -0.02083 + 0.5), group2.minY + floor(group2.height * -0.02083 + 0.5), floor(group2.width * 1.02083 + 0.5) - floor(group2.width * -0.02083 + 0.5), floor(group2.height * 1.02083 + 0.5) - floor(group2.height * -0.02083 + 0.5))
        let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
        CGContextSaveGState(context)
        rectangle2Path.addClip()
        CGContextDrawLinearGradient(context, gradient,
            CGPointMake(rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, rectangle2Rect.midY + 50 * rectangle2Rect.height / 100),
            CGPointMake(rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, rectangle2Rect.midY + 0 * rectangle2Rect.height / 100),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawTriangleButtonBase(#frame: CGRect, color: UIColor) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.2)
        let gradientColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

        //// Gradient Declarations
        let gradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [gradientColor.CGColor, gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor, UIColor.whiteColor().CGColor], [0, 1, 1])


        //// Subframes
        let group2: CGRect = CGRectMake(frame.minX + 7.2, frame.minY + 9.5, frame.width - 13.4, frame.height - 25)


        //// Star Drawing
        var starPath = UIBezierPath()
        starPath.moveToPoint(CGPointMake(frame.minX + 0.50500 * frame.width, frame.minY + 9.5))
        starPath.addLineToPoint(CGPointMake(frame.minX + 0.72151 * frame.width, frame.minY + 47))
        starPath.addLineToPoint(CGPointMake(frame.minX + 0.93801 * frame.width, frame.minY + 84.5))
        starPath.addLineToPoint(CGPointMake(frame.minX + 0.50500 * frame.width, frame.minY + 84.5))
        starPath.addLineToPoint(CGPointMake(frame.minX + 0.07199 * frame.width, frame.minY + 84.5))
        starPath.addLineToPoint(CGPointMake(frame.minX + 0.28849 * frame.width, frame.minY + 47))
        starPath.addLineToPoint(CGPointMake(frame.minX + 0.50500 * frame.width, frame.minY + 9.5))
        starPath.closePath()
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.outerShadow.shadowOffset, RemoteDrawingKit.outerShadow.shadowBlurRadius, (RemoteDrawingKit.outerShadow.shadowColor as UIColor).CGColor)
        color.setFill()
        starPath.fill()

        ////// Star Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, starPath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((RemoteDrawingKit.innerShadow.shadowColor as UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let starOpaqueShadow = (RemoteDrawingKit.innerShadow.shadowColor as UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.innerShadow.shadowOffset, RemoteDrawingKit.innerShadow.shadowBlurRadius, (starOpaqueShadow as UIColor).CGColor)
        CGContextSetBlendMode(context, kCGBlendModeSourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        starOpaqueShadow.setFill()
        starPath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, RemoteDrawingKit.strokeShadow.shadowOffset, RemoteDrawingKit.strokeShadow.shadowBlurRadius, (RemoteDrawingKit.strokeShadow.shadowColor as UIColor).CGColor)
        strokeColor.setStroke()
        starPath.lineWidth = 1
        starPath.stroke()
        CGContextRestoreGState(context)


        //// Group 2
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, kCGBlendModeSoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip Star 2
        var star2Path = UIBezierPath()
        star2Path.moveToPoint(CGPointMake(group2.minX + 0.50000 * group2.width, group2.minY + 0.00000 * group2.height))
        star2Path.addLineToPoint(CGPointMake(group2.minX + 0.75000 * group2.width, group2.minY + 0.50000 * group2.height))
        star2Path.addLineToPoint(CGPointMake(group2.minX + 1.00000 * group2.width, group2.minY + 1.00000 * group2.height))
        star2Path.addLineToPoint(CGPointMake(group2.minX + 0.50000 * group2.width, group2.minY + 1.00000 * group2.height))
        star2Path.addLineToPoint(CGPointMake(group2.minX + 0.00000 * group2.width, group2.minY + 1.00000 * group2.height))
        star2Path.addLineToPoint(CGPointMake(group2.minX + 0.25000 * group2.width, group2.minY + 0.50000 * group2.height))
        star2Path.addLineToPoint(CGPointMake(group2.minX + 0.50000 * group2.width, group2.minY + 0.00000 * group2.height))
        star2Path.closePath()
        star2Path.addClip()


        //// Rectangle 2 Drawing
        let rectangle2Rect = CGRectMake(group2.minX + floor(group2.width * -0.08312 - 0.3) + 0.8, group2.minY + floor(group2.height * -0.13333 + 0.5), floor(group2.width * 1.07158 - 0.3) - floor(group2.width * -0.08312 - 0.3), floor(group2.height * 1.20000 + 0.5) - floor(group2.height * -0.13333 + 0.5))
        let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
        CGContextSaveGState(context)
        rectangle2Path.addClip()
        CGContextDrawLinearGradient(context, gradient,
            CGPointMake(rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, rectangle2Rect.midY + 50 * rectangle2Rect.height / 100),
            CGPointMake(rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, rectangle2Rect.midY + 0 * rectangle2Rect.height / 100),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawBatteryStatus(#frame: CGRect, color: UIColor, hasPower: Bool, chargeLevel: CGFloat) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.2)

        //// Variable Declarations
        let showPower = hasPower && chargeLevel == 1
        let showCharging = hasPower && chargeLevel < 1

        //// Group
        //// Battery Fill Drawing
        CGContextSaveGState(context)
        CGContextTranslateCTM(context, frame.minX + 0.06250 * frame.width, frame.minY + 0.10938 * frame.height)
        CGContextScaleCTM(context, chargeLevel, 1)

        let batteryFillPath = UIBezierPath(rect: CGRectMake(0, 0, 45, 25))
        color.setFill()
        batteryFillPath.fill()

        CGContextRestoreGState(context)


        //// Battery Frame Drawing
        let batteryFramePath = UIBezierPath(roundedRect: CGRectMake(frame.minX + 2, frame.minY + 2, 48, 28), cornerRadius: 1)
        color.setStroke()
        batteryFramePath.lineWidth = 1
        batteryFramePath.stroke()


        //// Battery Tip Drawing
        var batteryTipPath = UIBezierPath(roundedRect: CGRectMake(frame.minX + 50, frame.minY + 9.5, 4, 13), byRoundingCorners: UIRectCorner.TopRight | UIRectCorner.BottomRight, cornerRadii: CGSizeMake(1, 1))
        batteryTipPath.closePath()
        color.setStroke()
        batteryTipPath.lineWidth = 1
        batteryTipPath.stroke()




        if (showPower) {
            //// Power Drawing
            var powerPath = UIBezierPath()
            powerPath.moveToPoint(CGPointMake(frame.minX + 0.71429 * frame.width, frame.minY + 0.43750 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.71429 * frame.width, frame.minY + 0.37500 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.62500 * frame.width, frame.minY + 0.37500 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.62500 * frame.width, frame.minY + 0.28125 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.47321 * frame.width, frame.minY + 0.28125 * frame.height))
            powerPath.addCurveToPoint(CGPointMake(frame.minX + 0.45893 * frame.width, frame.minY + 0.29375 * frame.height), controlPoint1: CGPointMake(frame.minX + 0.46786 * frame.width, frame.minY + 0.28125 * frame.height), controlPoint2: CGPointMake(frame.minX + 0.46250 * frame.width, frame.minY + 0.28438 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.41071 * frame.width, frame.minY + 0.40625 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.23214 * frame.width, frame.minY + 0.40625 * frame.height))
            powerPath.addCurveToPoint(CGPointMake(frame.minX + 0.21429 * frame.width, frame.minY + 0.43750 * frame.height), controlPoint1: CGPointMake(frame.minX + 0.22143 * frame.width, frame.minY + 0.40625 * frame.height), controlPoint2: CGPointMake(frame.minX + 0.21429 * frame.width, frame.minY + 0.41875 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.21429 * frame.width, frame.minY + 0.56250 * frame.height))
            powerPath.addCurveToPoint(CGPointMake(frame.minX + 0.23214 * frame.width, frame.minY + 0.59375 * frame.height), controlPoint1: CGPointMake(frame.minX + 0.21429 * frame.width, frame.minY + 0.58125 * frame.height), controlPoint2: CGPointMake(frame.minX + 0.22143 * frame.width, frame.minY + 0.59375 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.41071 * frame.width, frame.minY + 0.59375 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.45893 * frame.width, frame.minY + 0.70625 * frame.height))
            powerPath.addCurveToPoint(CGPointMake(frame.minX + 0.47321 * frame.width, frame.minY + 0.71875 * frame.height), controlPoint1: CGPointMake(frame.minX + 0.46250 * frame.width, frame.minY + 0.71562 * frame.height), controlPoint2: CGPointMake(frame.minX + 0.46786 * frame.width, frame.minY + 0.71875 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.62500 * frame.width, frame.minY + 0.71875 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.62500 * frame.width, frame.minY + 0.62500 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.71429 * frame.width, frame.minY + 0.62500 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.71429 * frame.width, frame.minY + 0.56250 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.62500 * frame.width, frame.minY + 0.56250 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.62500 * frame.width, frame.minY + 0.43750 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.71429 * frame.width, frame.minY + 0.43750 * frame.height))
            powerPath.closePath()
            powerPath.miterLimit = 4;

            strokeColor.setFill()
            powerPath.fill()
        }


        if (showCharging) {
            //// Lightning Drawing
            var lightningPath = UIBezierPath()
            lightningPath.moveToPoint(CGPointMake(frame.minX + 0.55153 * frame.width, frame.minY + 0.42366 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.47675 * frame.width, frame.minY + 0.42366 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.51414 * frame.width, frame.minY + 0.19463 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.42689 * frame.width, frame.minY + 0.19463 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.37704 * frame.width, frame.minY + 0.54362 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.46429 * frame.width, frame.minY + 0.54362 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.44559 * frame.width, frame.minY + 0.80537 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.55153 * frame.width, frame.minY + 0.42366 * frame.height))
            lightningPath.closePath()
            lightningPath.miterLimit = 4;

            strokeColor.setFill()
            lightningPath.fill()
        }
    }

}



extension UIColor {
    func colorWithHue(newHue: CGFloat) -> UIColor {
        var saturation: CGFloat = 1.0, brightness: CGFloat = 1.0, alpha: CGFloat = 1.0
        self.getHue(nil, saturation: &saturation, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: newHue, saturation: saturation, brightness: brightness, alpha: alpha)
    }
    func colorWithSaturation(newSaturation: CGFloat) -> UIColor {
        var hue: CGFloat = 1.0, brightness: CGFloat = 1.0, alpha: CGFloat = 1.0
        self.getHue(&hue, saturation: nil, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: hue, saturation: newSaturation, brightness: brightness, alpha: alpha)
    }
    func colorWithBrightness(newBrightness: CGFloat) -> UIColor {
        var hue: CGFloat = 1.0, saturation: CGFloat = 1.0, alpha: CGFloat = 1.0
        self.getHue(&hue, saturation: &saturation, brightness: nil, alpha: &alpha)
        return UIColor(hue: hue, saturation: saturation, brightness: newBrightness, alpha: alpha)
    }
    func colorWithAlpha(newAlpha: CGFloat) -> UIColor {
        var hue: CGFloat = 1.0, saturation: CGFloat = 1.0, brightness: CGFloat = 1.0
        self.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: nil)
        return UIColor(hue: hue, saturation: saturation, brightness: brightness, alpha: newAlpha)
    }
    func colorWithHighlight(highlight: CGFloat) -> UIColor {
        var red: CGFloat = 1.0, green: CGFloat = 1.0, blue: CGFloat = 1.0, alpha: CGFloat = 1.0
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-highlight) + highlight, green: green * (1-highlight) + highlight, blue: blue * (1-highlight) + highlight, alpha: alpha * (1-highlight) + highlight)
    }
    func colorWithShadow(shadow: CGFloat) -> UIColor {
        var red: CGFloat = 1.0, green: CGFloat = 1.0, blue: CGFloat = 1.0, alpha: CGFloat = 1.0
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-shadow), green: green * (1-shadow), blue: blue * (1-shadow), alpha: alpha * (1-shadow) + shadow)
    }
    func blendedColorWithFraction(fraction: CGFloat, ofColor color: UIColor) -> UIColor {
        var r1: CGFloat = 1.0, g1: CGFloat = 1.0, b1: CGFloat = 1.0, a1: CGFloat = 1.0
        var r2: CGFloat = 1.0, g2: CGFloat = 1.0, b2: CGFloat = 1.0, a2: CGFloat = 1.0

        self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
            green: g1 * (1 - fraction) + g2 * fraction,
            blue: b1 * (1 - fraction) + b2 * fraction,
            alpha: a1 * (1 - fraction) + a2 * fraction);
    }
}



extension NSShadow {
    convenience init(color: AnyObject!, offset: CGSize, blurRadius: CGFloat) {
        self.init()
        self.shadowColor = color
        self.shadowOffset = offset
        self.shadowBlurRadius = blurRadius
    }
}

@objc protocol StyleKitSettableImage {
    func setImage(image: UIImage!)
}

@objc protocol StyleKitSettableSelectedImage {
    func setSelectedImage(image: UIImage!)
}
