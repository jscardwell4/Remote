//
//  DrawingKit.swift
//  MoonKit
//
//  Created by Moondeer on 12/18/14.
//  Copyright (c) 2014 Moondeer Studios. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//



import UIKit

public final class DrawingKit {

  // MARK: - Colors
  public static let keyboardColor1 = UIColor(red: 0.529, green: 0.529, blue: 0.529, alpha: 1.000)
  public static let keyboardColor2 = UIColor(red: 0.298, green: 0.298, blue: 0.306, alpha: 1.000)
  public static let prominentColor = UIColor(red: 0.000, green: 0.463, blue: 1.000, alpha: 1.000)
  public static let affirmativeColor = UIColor(red: 0.294, green: 0.847, blue: 0.384, alpha: 1.000)
  public static let defaultBaseColor = UIColor(red: 0.261, green: 0.258, blue: 0.258, alpha: 1.000)
  public static let defaultStrokeColor = DrawingKit.defaultBaseColor.colorWithHighlight(0.2)

  // MARK: - Shadows
  public static let shadow = NSShadow(color: UIColor.blackColor().colorWithAlphaComponent(0.52), offset: CGSize(width: 0.1, height: 1.1), blurRadius: 1)
  public static let semiDarkShadow = NSShadow(color: UIColor.blackColor().colorWithAlphaComponent(0.44), offset: CGSize(width: 0.1, height: 1.1), blurRadius: 1)
  public static let lightShadow = NSShadow(color: UIColor.whiteColor().colorWithAlphaComponent(0.31), offset: CGSize(width: 0.1, height: 2.1), blurRadius: 2)
  public static let thinLightShadow = NSShadow(color: UIColor.whiteColor().colorWithAlphaComponent(0), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 3)
  public static let invisibleShadow = NSShadow(color: UIColor.blackColor().colorWithAlphaComponent(0), offset: CGSize(width: 3.1, height: 3.1), blurRadius: 5)
  public static let insettingShadow = NSShadow(color: UIColor.whiteColor().colorWithAlphaComponent(0.5), offset: CGSize(width: 0.1, height: 0.6), blurRadius: 0)
  public static let plasticShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSize(width: 0.1, height: -0.6), blurRadius: 1)
  public static let cutoutShadow = NSShadow(color: UIColor.blackColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 4)
  public static let glowingShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 5)


  // MARK: - Drawing Methods

  public class func drawNoImage(frame frame: CGRect) {


    // Subframes
    let group: CGRect = CGRect(x: frame.minX + floor(frame.width * 0.00000 + 0.5),
                               y: frame.minY + floor(frame.height * 0.00000 + 0.5),
                               width: floor(frame.width * 1.00000 + 0.5) - floor(frame.width * 0.00000 + 0.5),
                               height: floor(frame.height * 1.00000 + 0.5) - floor(frame.height * 0.00000 + 0.5))


    // Group
    // Photo Drawing
    let photoPath = UIBezierPath()
    photoPath.moveToPoint(CGPoint(x: group.minX + 0.72081 * group.width, y: group.minY + 0.30870 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.67174 * group.width, y: group.minY + 0.35652 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.69371 * group.width, y: group.minY + 0.30870 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.67174 * group.width, y: group.minY + 0.33011 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.72081 * group.width, y: group.minY + 0.40435 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.67174 * group.width, y: group.minY + 0.38293 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.69371 * group.width, y: group.minY + 0.40435 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.76988 * group.width, y: group.minY + 0.35652 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.74791 * group.width, y: group.minY + 0.40435 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.76988 * group.width, y: group.minY + 0.38293 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.72081 * group.width, y: group.minY + 0.30870 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.76988 * group.width, y: group.minY + 0.33011 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.74791 * group.width, y: group.minY + 0.30870 * group.height))
    photoPath.closePath()
    photoPath.moveToPoint(CGPoint(x: group.minX + 0.41213 * group.width, y: group.minY + 0.45234 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.40461 * group.width, y: group.minY + 0.45691 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.40906 * group.width, y: group.minY + 0.45287 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.40646 * group.width, y: group.minY + 0.45459 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.23271 * group.width, y: group.minY + 0.67199 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.40445 * group.width, y: group.minY + 0.45678 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.23271 * group.width, y: group.minY + 0.67199 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.23012 * group.width, y: group.minY + 0.67935 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.23125 * group.width, y: group.minY + 0.67415 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.23012 * group.width, y: group.minY + 0.67659 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.24239 * group.width, y: group.minY + 0.69130 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.23012 * group.width, y: group.minY + 0.68596 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.23561 * group.width, y: group.minY + 0.69130 * group.height))
    photoPath.addLineToPoint(CGPoint(x: group.minX + 0.65548 * group.width, y: group.minY + 0.69130 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.72854 * group.width, y: group.minY + 0.76304 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.68274 * group.width, y: group.minY + 0.71807 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.70753 * group.width, y: group.minY + 0.74241 * group.height))
    photoPath.addLineToPoint(CGPoint(x: group.minX + 0.18106 * group.width, y: group.minY + 0.76304 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.15652 * group.width, y: group.minY + 0.73913 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.16751 * group.width, y: group.minY + 0.76304 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.15652 * group.width, y: group.minY + 0.75233 * group.height))
    photoPath.addLineToPoint(CGPoint(x: group.minX + 0.15652 * group.width, y: group.minY + 0.26087 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.18106 * group.width, y: group.minY + 0.23696 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.15652 * group.width, y: group.minY + 0.24767 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.16751 * group.width, y: group.minY + 0.23696 * group.height))
    photoPath.addLineToPoint(CGPoint(x: group.minX + 0.19279 * group.width, y: group.minY + 0.23696 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.41213 * group.width, y: group.minY + 0.45234 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.23586 * group.width, y: group.minY + 0.27925 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.31996 * group.width, y: group.minY + 0.36183 * group.height))
    photoPath.closePath()
    photoPath.moveToPoint(CGPoint(x: group.minX + 0.84348 * group.width, y: group.minY + 0.26087 * group.height))
    photoPath.addLineToPoint(CGPoint(x: group.minX + 0.84348 * group.width, y: group.minY + 0.73913 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.81894 * group.width, y: group.minY + 0.76304 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.84348 * group.width, y: group.minY + 0.75233 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.83249 * group.width, y: group.minY + 0.76304 * group.height))
    photoPath.addLineToPoint(CGPoint(x: group.minX + 0.80913 * group.width, y: group.minY + 0.76304 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.73584 * group.width, y: group.minY + 0.69130 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.79108 * group.width, y: group.minY + 0.74538 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.76585 * group.width, y: group.minY + 0.72068 * group.height))
    photoPath.addLineToPoint(CGPoint(x: group.minX + 0.75761 * group.width, y: group.minY + 0.69130 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.76988 * group.width, y: group.minY + 0.67935 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.76439 * group.width, y: group.minY + 0.69130 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.76988 * group.width, y: group.minY + 0.68596 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.76681 * group.width, y: group.minY + 0.67166 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.76988 * group.width, y: group.minY + 0.67638 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.76865 * group.width, y: group.minY + 0.67375 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.61973 * group.width, y: group.minY + 0.50417 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.76692 * group.width, y: group.minY + 0.67156 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.61973 * group.width, y: group.minY + 0.50417 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.61040 * group.width, y: group.minY + 0.50000 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.61735 * group.width, y: group.minY + 0.50171 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.61413 * group.width, y: group.minY + 0.50000 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.60173 * group.width, y: group.minY + 0.50350 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.60702 * group.width, y: group.minY + 0.50000 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.60395 * group.width, y: group.minY + 0.50134 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.57280 * group.width, y: group.minY + 0.53170 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.60173 * group.width, y: group.minY + 0.50350 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.58777 * group.width, y: group.minY + 0.51711 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.27169 * group.width, y: group.minY + 0.23696 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.46300 * group.width, y: group.minY + 0.42422 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.34466 * group.width, y: group.minY + 0.30839 * group.height))
    photoPath.addLineToPoint(CGPoint(x: group.minX + 0.81894 * group.width, y: group.minY + 0.23696 * group.height))
    photoPath.addCurveToPoint(CGPoint(x: group.minX + 0.84348 * group.width, y: group.minY + 0.26087 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.83249 * group.width, y: group.minY + 0.23696 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.84348 * group.width, y: group.minY + 0.24767 * group.height))
    photoPath.closePath()
    UIColor.blackColor().setFill()
    photoPath.fill()


    // circle Drawing
    let circlePath = UIBezierPath()
    circlePath.moveToPoint(CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.04348 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.24697 * group.width, y: group.minY + 0.11996 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.40641 * group.width, y: group.minY + 0.04348 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.31939 * group.width, y: group.minY + 0.07164 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.18835 * group.width, y: group.minY + 0.16640 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.22616 * group.width, y: group.minY + 0.13384 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.20656 * group.width, y: group.minY + 0.14938 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.83757 * group.width, y: group.minY + 0.80735 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.28203 * group.width, y: group.minY + 0.25889 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.74345 * group.width, y: group.minY + 0.71443 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.95652 * group.width, y: group.minY + 0.50000 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.91147 * group.width, y: group.minY + 0.72623 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.95652 * group.width, y: group.minY + 0.61838 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.04348 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.95652 * group.width, y: group.minY + 0.24787 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.75213 * group.width, y: group.minY + 0.04348 * group.height))
    circlePath.closePath()
    circlePath.moveToPoint(CGPoint(x: group.minX + 0.16454 * group.width, y: group.minY + 0.19035 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.04348 * group.width, y: group.minY + 0.50000 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.08939 * group.width, y: group.minY + 0.27172 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.04348 * group.width, y: group.minY + 0.38050 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.95652 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.04348 * group.width, y: group.minY + 0.75213 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.24787 * group.width, y: group.minY + 0.95652 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.81606 * group.width, y: group.minY + 0.82942 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.62267 * group.width, y: group.minY + 0.95652 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.73403 * group.width, y: group.minY + 0.90814 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.16454 * group.width, y: group.minY + 0.19035 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.72176 * group.width, y: group.minY + 0.73692 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.25334 * group.width, y: group.minY + 0.27745 * group.height))
    circlePath.closePath()
    circlePath.moveToPoint(CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.50000 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 1.00000 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.77614 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.77614 * group.width, y: group.minY + 1.00000 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.50000 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.22386 * group.width, y: group.minY + 1.00000 * group.height),
                 controlPoint2: CGPoint(x: group.minX + -0.00000 * group.width, y: group.minY + 0.77614 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.20376 * group.width, y: group.minY + 0.09717 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.00000 * group.width, y: group.minY + 0.33474 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.08018 * group.width, y: group.minY + 0.18820 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 0.50000 * group.width, y: group.minY + 0.00000 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.28667 * group.width, y: group.minY + 0.03609 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 0.38912 * group.width, y: group.minY + 0.00000 * group.height))
    circlePath.addCurveToPoint(CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.50000 * group.height),
                 controlPoint1: CGPoint(x: group.minX + 0.77614 * group.width, y: group.minY + 0.00000 * group.height),
                 controlPoint2: CGPoint(x: group.minX + 1.00000 * group.width, y: group.minY + 0.22386 * group.height))
    circlePath.closePath()
    UIColor.blackColor().setFill()
    circlePath.fill()
  }

  public class func drawTwoToneCircle(upperColor upperColor: UIColor, lowerColor: UIColor) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()


    // Shadow Declarations
    let dropShadow = NSShadow(color: UIColor.blackColor().colorWithAlphaComponent(0.15), offset: CGSize(width: 0.1, height: 3.1), blurRadius: 1)

    // halfCircles
    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                dropShadow.shadowOffset,
                                dropShadow.shadowBlurRadius,
                                (dropShadow.shadowColor as! UIColor).CGColor)
    CGContextBeginTransparencyLayer(context, nil)


    // upperHalfCircle Drawing
    let upperHalfCircleRect = CGRect(x: 2, y: 2, width: 27, height: 27)
    let upperHalfCirclePath = UIBezierPath()
    upperHalfCirclePath.addArcWithCenter(CGPoint(x: upperHalfCircleRect.midX, y: upperHalfCircleRect.midY),
                                  radius: upperHalfCircleRect.width / 2,
                              startAngle: -180 * CGFloat(M_PI)/180,
                                endAngle: 0 * CGFloat(M_PI)/180,
                               clockwise: true)
    upperHalfCirclePath.addLineToPoint(CGPoint(x: upperHalfCircleRect.midX, y: upperHalfCircleRect.midY))
    upperHalfCirclePath.closePath()

    upperColor.setFill()
    upperHalfCirclePath.fill()

    // upperHalfCircle Inner Shadow
    CGContextSaveGState(context)
    CGContextClipToRect(context, upperHalfCirclePath.bounds)
    CGContextSetShadow(context, CGSize(width: 0, height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.thinLightShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let upperHalfCircleOpaqueShadow = (DrawingKit.thinLightShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(context,
                                DrawingKit.thinLightShadow.shadowOffset,
                                DrawingKit.thinLightShadow.shadowBlurRadius,
                                (upperHalfCircleOpaqueShadow as UIColor).CGColor)
   CGContextSetBlendMode(context, .SourceOut)
   CGContextBeginTransparencyLayer(context, nil)

    upperHalfCircleOpaqueShadow.setFill()
    upperHalfCirclePath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)



    // lowerHalfCircle Drawing
    let lowerHalfCircleRect = CGRect(x: 2, y: 2, width: 27, height: 27)
    let lowerHalfCirclePath = UIBezierPath()
    lowerHalfCirclePath.addArcWithCenter(CGPoint(x: lowerHalfCircleRect.midX, y: lowerHalfCircleRect.midY),
                                  radius: lowerHalfCircleRect.width / 2,
                              startAngle: 0 * CGFloat(M_PI)/180,
                                endAngle: 180 * CGFloat(M_PI)/180,
                               clockwise: true)
    lowerHalfCirclePath.addLineToPoint(CGPoint(x: lowerHalfCircleRect.midX, y: lowerHalfCircleRect.midY))
    lowerHalfCirclePath.closePath()

    lowerColor.setFill()
    lowerHalfCirclePath.fill()

    // lowerHalfCircle Inner Shadow
    CGContextSaveGState(context)
    CGContextClipToRect(context, lowerHalfCirclePath.bounds)
    CGContextSetShadow(context, CGSize(width: 0, height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.thinLightShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let lowerHalfCircleOpaqueShadow = (DrawingKit.thinLightShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(context,
                                DrawingKit.thinLightShadow.shadowOffset,
                                DrawingKit.thinLightShadow.shadowBlurRadius,
                                (lowerHalfCircleOpaqueShadow as UIColor).CGColor)
   CGContextSetBlendMode(context, .SourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    lowerHalfCircleOpaqueShadow.setFill()
    lowerHalfCirclePath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)



    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)
  }

  public class func drawAlphaValueCircle(value value: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let alpha = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

    // Variable Declarations
    let filteredValue: CGFloat = min(1, max(0, value))
    let representedAlphaColor = UIColor(red: filteredValue, green: filteredValue, blue: filteredValue, alpha: 1)

    // Circle Drawing
    let circleRect = CGRect(x: 0, y: 0, width: 31, height: 34)
    CGContextSaveGState(context)
    UIRectClip(circleRect)
    CGContextTranslateCTM(context, circleRect.origin.x, circleRect.origin.y)

    DrawingKit.drawTwoToneCircle(upperColor: representedAlphaColor, lowerColor: alpha)
    CGContextRestoreGState(context)
  }

  public class func drawRedValueCircle(value value: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let red = UIColor(red: 1.000, green: 0.000, blue: 0.000, alpha: 1.000)

    // Variable Declarations
    let filteredValue: CGFloat = min(1, max(0, value))
    let representedRedColor = UIColor(red: filteredValue, green: 0, blue: 0, alpha: 1)

    // Circle Drawing
    let circleRect = CGRect(x: 0, y: 0, width: 31, height: 34)
    CGContextSaveGState(context)
    UIRectClip(circleRect)
    CGContextTranslateCTM(context, circleRect.origin.x, circleRect.origin.y)

    DrawingKit.drawTwoToneCircle(upperColor: representedRedColor, lowerColor: red)
    CGContextRestoreGState(context)
  }

  public class func drawGreenValueCircle(value value: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let green = UIColor(red: 0.000, green: 1.000, blue: 0.000, alpha: 1.000)

    // Variable Declarations
    let filteredValue: CGFloat = min(1, max(0, value))
    let representedGreenColor = UIColor(red: 0, green: filteredValue, blue: 0, alpha: 1)

    // Circle Drawing
    let circleRect = CGRect(x: 0, y: 0, width: 31, height: 34)
    CGContextSaveGState(context)
    UIRectClip(circleRect)
    CGContextTranslateCTM(context, circleRect.origin.x, circleRect.origin.y)

    DrawingKit.drawTwoToneCircle(upperColor: representedGreenColor, lowerColor: green)
    CGContextRestoreGState(context)
  }

  public class func drawBlueValueCircle(value value: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let blue = UIColor(red: 0.000, green: 0.000, blue: 1.000, alpha: 1.000)

    // Variable Declarations
    let filteredValue: CGFloat = min(1, max(0, value))
    let representedBlueColor = UIColor(red: 0, green: 0, blue: filteredValue, alpha: 1)

    // Circle Drawing
    let circleRect = CGRect(x: 0, y: 0, width: 31, height: 34)
    CGContextSaveGState(context)
    UIRectClip(circleRect)
    CGContextTranslateCTM(context, circleRect.origin.x, circleRect.origin.y)

    DrawingKit.drawTwoToneCircle(upperColor: representedBlueColor, lowerColor: blue)
    CGContextRestoreGState(context)
  }

  public class func drawOneToneCircle(color color: UIColor, opacity: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let halfAlphaColor = color.colorWithAlpha(0.5)
    let circleBaseColor = UIColor(red: 0.000, green: 0.000, blue: 0.000, alpha: 1.000)

    // Shadow Declarations
    let colorShadow = NSShadow(color: color, offset: CGSize(width: 0.1, height: -0.1), blurRadius: 2)
    let thumbShadow = NSShadow(color: UIColor.blackColor().colorWithAlphaComponent(0.15), offset: CGSize(width: 0.1, height: 3.1), blurRadius: 1)
    let colorInnerShadow = NSShadow(color: color, offset: CGSize(width: -18.1, height: -21.1), blurRadius: 0)

    // Variable Declarations
    let fillOpacity: CGFloat = min(1, max(0, opacity)) * 0.95

    // Base Circle Drawing
    let baseCirclePath = UIBezierPath(ovalInRect: CGRect(x: 1, y: 1, width: 29, height: 29))
    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                thumbShadow.shadowOffset,
                                thumbShadow.shadowBlurRadius,
                                (thumbShadow.shadowColor as! UIColor).CGColor)
    UIColor.whiteColor().setFill()
    baseCirclePath.fill()
    CGContextRestoreGState(context)



    // Base Inner Circle Drawing
    let baseInnerCirclePath = UIBezierPath(ovalInRect: CGRect(x: 2, y: 2, width: 27, height: 27))
    circleBaseColor.setFill()
    baseInnerCirclePath.fill()


    // Fill
    CGContextSaveGState(context)
    CGContextSetAlpha(context, fillOpacity)
    CGContextBeginTransparencyLayer(context, nil)


    // Color Filled Circle 2 Drawing
    let colorFilledCircle2Path = UIBezierPath(ovalInRect: CGRect(x: 2, y: 2, width: 27, height: 27))
    UIColor.whiteColor().setFill()
    colorFilledCircle2Path.fill()


    // Color Filled Circle Drawing
    let colorFilledCirclePath = UIBezierPath(ovalInRect: CGRect(x: 2, y: 2, width: 27, height: 27))
    UIColor.whiteColor().setFill()
    colorFilledCirclePath.fill()

    // Color Filled Circle Inner Shadow
    CGContextSaveGState(context)
    CGContextClipToRect(context, colorFilledCirclePath.bounds)
    CGContextSetShadow(context, CGSize(width: 0, height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((colorInnerShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let colorFilledCircleOpaqueShadow = (colorInnerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(context,
                                colorInnerShadow.shadowOffset,
                                colorInnerShadow.shadowBlurRadius,
                                (colorFilledCircleOpaqueShadow as UIColor).CGColor)
    CGContextSetBlendMode(context, .SourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    colorFilledCircleOpaqueShadow.setFill()
    colorFilledCirclePath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)



    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)


    // Color Stroked Circle Drawing
    let colorStrokedCirclePath = UIBezierPath(ovalInRect: CGRect(x: 2, y: 2, width: 27, height: 27))
    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                colorShadow.shadowOffset,
                                colorShadow.shadowBlurRadius,
                                (colorShadow.shadowColor as! UIColor).CGColor)
    halfAlphaColor.setStroke()
    colorStrokedCirclePath.lineWidth = 1
    colorStrokedCirclePath.stroke()
    CGContextRestoreGState(context)
  }

  public class func drawRedCircle(opacity opacity: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let red = UIColor(red: 1.000, green: 0.000, blue: 0.000, alpha: 1.000)

    // Symbol Drawing
    let symbolRect = CGRect(x: 0, y: 0, width: 31, height: 34)
    CGContextSaveGState(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)

    DrawingKit.drawOneToneCircle(color: red, opacity: opacity)
    CGContextRestoreGState(context)
  }

  public class func drawGreenCircle(opacity opacity: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let green = UIColor(red: 0.000, green: 1.000, blue: 0.000, alpha: 1.000)

    // Symbol Drawing
    let symbolRect = CGRect(x: 0, y: 0, width: 31, height: 34)
    CGContextSaveGState(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)

    DrawingKit.drawOneToneCircle(color: green, opacity: opacity)
    CGContextRestoreGState(context)
  }

  public class func drawBlueCircle(opacity opacity: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let blue = UIColor(red: 0.000, green: 0.000, blue: 1.000, alpha: 1.000)

    // Symbol Drawing
    let symbolRect = CGRect(x: 0, y: 0, width: 31, height: 34)
    CGContextSaveGState(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)

    DrawingKit.drawOneToneCircle(color: blue, opacity: opacity)
    CGContextRestoreGState(context)
  }

  public class func drawAlphaCircle(opacity opacity: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let alpha = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

    // Symbol Drawing
    let symbolRect = CGRect(x: 0, y: 0, width: 31, height: 34)
    CGContextSaveGState(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)

    DrawingKit.drawOneToneCircle(color: alpha, opacity: opacity)
    CGContextRestoreGState(context)
  }

  public class func drawGradientCircle(color1 color1: UIColor, color2: UIColor, opacity: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()


    // Gradient Declarations
    let gradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [color1.CGColor, color2.CGColor], [0, 1])

    // Shadow Declarations
    let baseStrokeShadow = NSShadow(color: UIColor.blackColor().colorWithAlphaComponent(0.44), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 3)
    let dropShadow = NSShadow(color: UIColor.blackColor().colorWithAlphaComponent(0.15), offset: CGSize(width: 0.1, height: 3.1), blurRadius: 1)
    let baseInnerShadow = NSShadow(color: UIColor.blackColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 1)

    // Base Circle Drawing
    let baseCirclePath = UIBezierPath(ovalInRect: CGRect(x: 2, y: 2, width: 27, height: 27))
    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                dropShadow.shadowOffset,
                                dropShadow.shadowBlurRadius,
                                (dropShadow.shadowColor as! UIColor).CGColor)
    UIColor.whiteColor().setFill()
    baseCirclePath.fill()

    // Base Circle Inner Shadow
    CGContextSaveGState(context)
    CGContextClipToRect(context, baseCirclePath.bounds)
    CGContextSetShadow(context, CGSize(width: 0, height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((baseInnerShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let baseCircleOpaqueShadow = (baseInnerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(context,
                                baseInnerShadow.shadowOffset,
                                baseInnerShadow.shadowBlurRadius,
                                (baseCircleOpaqueShadow as UIColor).CGColor)
    CGContextSetBlendMode(context, .SourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    baseCircleOpaqueShadow.setFill()
    baseCirclePath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)

    CGContextRestoreGState(context)

    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                baseStrokeShadow.shadowOffset,
                                baseStrokeShadow.shadowBlurRadius,
                                (baseStrokeShadow.shadowColor as! UIColor).CGColor)
    color1.setStroke()
    baseCirclePath.lineWidth = 0.5
    baseCirclePath.stroke()
    CGContextRestoreGState(context)


    // Group
    CGContextSaveGState(context)
    CGContextSetAlpha(context, opacity)
    CGContextBeginTransparencyLayer(context, nil)


    // Gradient Filled Circle Drawing
    let gradientFilledCirclePath = UIBezierPath(ovalInRect: CGRect(x: 2, y: 2, width: 27, height: 27))
    CGContextSaveGState(context)
    gradientFilledCirclePath.addClip()
    CGContextDrawRadialGradient(context, gradient,
      CGPoint(x: 15.5, y: 15.5), 11.91,
      CGPoint(x: 15.5, y: 15.5), 15.94,
      [.DrawsBeforeStartLocation, .DrawsAfterEndLocation])
    CGContextRestoreGState(context)


    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)
  }

  public class func drawRedGradientCircle(opacity opacity: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let alpha = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
    let red = UIColor(red: 1.000, green: 0.000, blue: 0.000, alpha: 1.000)

    // Symbol Drawing
    let symbolRect = CGRect(x: 0, y: 0, width: 31, height: 34)
    CGContextSaveGState(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)

    DrawingKit.drawGradientCircle(color1: red, color2: alpha, opacity: opacity)
    CGContextRestoreGState(context)
  }

  public class func drawGreenGradientCircle(opacity opacity: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let alpha = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

    // Symbol Drawing
    let symbolRect = CGRect(x: 0, y: 0, width: 31, height: 34)
    CGContextSaveGState(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)

    DrawingKit.drawGradientCircle(color1: DrawingKit.affirmativeColor, color2: alpha, opacity: opacity)
    CGContextRestoreGState(context)
  }

  public class func drawBlueGradientCircle(opacity opacity: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let alpha = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)
    let blue = UIColor(red: 0.000, green: 0.000, blue: 1.000, alpha: 1.000)

    // Symbol Drawing
    let symbolRect = CGRect(x: 0, y: 0, width: 31, height: 34)
    CGContextSaveGState(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)

    DrawingKit.drawGradientCircle(color1: blue, color2: alpha, opacity: opacity)
    CGContextRestoreGState(context)
  }

  public class func drawAlphaGradientCircle(opacity opacity: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let alpha = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 1.000)

    // Variable Declarations
    let invertedOpacity: CGFloat = 1 - opacity

    // Symbol Drawing
    let symbolRect = CGRect(x: 0, y: 0, width: 31, height: 34)
    CGContextSaveGState(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)

    DrawingKit.drawGradientCircle(color1: alpha, color2: alpha, opacity: opacity)
    CGContextRestoreGState(context)


    // Group
    CGContextSaveGState(context)
    CGContextSetAlpha(context, invertedOpacity)
    CGContextSetBlendMode(context, .Luminosity)
    CGContextBeginTransparencyLayer(context, nil)


    // Half Circle Drawing
    let halfCircleRect = CGRect(x: 3, y: 3, width: 25, height: 25)
    let halfCirclePath = UIBezierPath()
    halfCirclePath.addArcWithCenter(CGPoint(x: halfCircleRect.midX, y: halfCircleRect.midY),
                             radius: halfCircleRect.width / 2,
                         startAngle: -225 * CGFloat(M_PI)/180,
                           endAngle: -45 * CGFloat(M_PI)/180,
                          clockwise: true)
    halfCirclePath.addLineToPoint(CGPoint(x: halfCircleRect.midX, y: halfCircleRect.midY))
    halfCirclePath.closePath()

    UIColor.blackColor().setFill()
    halfCirclePath.fill()


    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)
  }

  // Generated Images

  public class func imageOfNoImage(frame frame: CGRect) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(frame.size, false, 0)
    DrawingKit.drawNoImage(frame: frame)

    let imageOfNoImage = UIGraphicsGetImageFromCurrentImageContext().imageWithRenderingMode(UIImageRenderingMode.AlwaysTemplate)
    UIGraphicsEndImageContext()

    return imageOfNoImage
  }

  public class func imageOfTwoToneCircle(upperColor upperColor: UIColor, lowerColor: UIColor) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawTwoToneCircle(upperColor: upperColor, lowerColor: lowerColor)

    let imageOfTwoToneCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfTwoToneCircle
  }

  public class func imageOfAlphaValueCircle(value value: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawAlphaValueCircle(value: value)

    let imageOfAlphaValueCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfAlphaValueCircle
  }

  public class func imageOfRedValueCircle(value value: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawRedValueCircle(value: value)

    let imageOfRedValueCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfRedValueCircle
  }

  public class func imageOfGreenValueCircle(value value: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawGreenValueCircle(value: value)

    let imageOfGreenValueCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfGreenValueCircle
  }

  public class func imageOfBlueValueCircle(value value: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawBlueValueCircle(value: value)

    let imageOfBlueValueCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfBlueValueCircle
  }

  public class func imageOfOneToneCircle(color color: UIColor, opacity: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawOneToneCircle(color: color, opacity: opacity)

    let imageOfOneToneCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfOneToneCircle
  }

  public class func imageOfRedCircle(opacity opacity: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawRedCircle(opacity: opacity)

    let imageOfRedCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfRedCircle
  }

  public class func imageOfGreenCircle(opacity opacity: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawGreenCircle(opacity: opacity)

    let imageOfGreenCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfGreenCircle
  }

  public class func imageOfBlueCircle(opacity opacity: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawBlueCircle(opacity: opacity)

    let imageOfBlueCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfBlueCircle
  }

  public class func imageOfAlphaCircle(opacity opacity: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawAlphaCircle(opacity: opacity)

    let imageOfAlphaCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfAlphaCircle
  }

  public class func imageOfGradientCircle(color1 color1: UIColor, color2: UIColor, opacity: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawGradientCircle(color1: color1, color2: color2, opacity: opacity)

    let imageOfGradientCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfGradientCircle
  }

  public class func imageOfRedGradientCircle(opacity opacity: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawRedGradientCircle(opacity: opacity)

    let imageOfRedGradientCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfRedGradientCircle
  }

  public class func imageOfGreenGradientCircle(opacity opacity: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawGreenGradientCircle(opacity: opacity)

    let imageOfGreenGradientCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfGreenGradientCircle
  }

  public class func imageOfBlueGradientCircle(opacity opacity: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawBlueGradientCircle(opacity: opacity)

    let imageOfBlueGradientCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfBlueGradientCircle
  }

  public class func imageOfAlphaGradientCircle(opacity opacity: CGFloat) -> UIImage {
    UIGraphicsBeginImageContextWithOptions(CGSize(width: 31, height: 34), false, 0)
    DrawingKit.drawAlphaGradientCircle(opacity: opacity)

    let imageOfAlphaGradientCircle = UIGraphicsGetImageFromCurrentImageContext()
    UIGraphicsEndImageContext()

    return imageOfAlphaGradientCircle
  }

}
