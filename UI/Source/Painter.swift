//
//  Painter.swift
//  Remote
//
//  Created by Moondeer on 4/28/15.
//  Copyright (c) 2015 Moondeer Studios. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//


import UIKit
import MoonKit
import DataModel

// MARK: - Private globals for convenience

private let white = UIColor.whiteColor()
private let white0_5 = white.colorWithAlphaComponent(0.5)
private let white0_0 = UIColor(red: 1, green: 1, blue: 1, alpha: 0)
private let lightGray = UIColor.lightGrayColor()
private let black = UIColor.blackColor()
private let offset1_neg1 = CGSize(width: 0.1, height: -0.1)
private let offset1_6 = CGSize(width: 0.1, height: 0.6)
private let offset1_neg6 = CGSize(width: 0.1, height: -0.6)

public final class Painter {

  // MARK: - Attributes structure to simplify method parameters

  public struct Attributes: DictionaryLiteralConvertible, CustomStringConvertible {
    public var color: UIColor?
    public var accentColor: UIColor?
    public var foregroundColor: UIColor?
    public var rect: CGRect
    public var lineWidth: CGFloat = 0
    public var corners = Painter.defaultCorners
    public var radii = Painter.defaultRadii
    public var shadow: NSShadow?
    public var accentShadow: NSShadow?
    public var blendMode: CGBlendMode = .Normal
    public var stroke = false
    public var fill = true
    public var alpha: CGFloat = 1.0
    public var image: UIImage?
    public var text: String?
    public var fontAttributes: [String:AnyObject]?
    public var adjustFontSize = false

    public var description: String {
      var result = "Painter.Attributes:\n"
      result += "\tcolor = \(String(color))\n"
      result += "\taccentColor = \(String(accentColor))\n"
      result += "\tforegroundColor = \(String(foregroundColor))\n"
      result += "\trect = \(String(rect))\n"
      result += "\tlineWidth = \(String(lineWidth))\n"
      result += "\tcorners = \(String(corners))\n"
      result += "\tradii = \(String(radii))\n"
      result += "\tshadow = \(String(shadow))\n"
      result += "\taccentShadow = \(String(accentShadow))\n"
      result += "\tblendMode = \(String(blendMode))\n"
      result += "\tstroke = \(String(stroke))\n"
      result += "\tfill = \(String(fill))\n"
      result += "\talpha = \(String(alpha))\n"
      result += "\timage = \(String(image))\n"
      result += "\ttext = \(String(text))\n"
      result += "\tfontAttributes = \(String(fontAttributes))\n"
      result += "\tadjustFontSize = \(String(adjustFontSize))\n"
      return result
    }

    /**
    Initialize with `rect` and any other options desired

    - parameter rect: CGRect
    - parameter color: UIColor? = nil
    - parameter accentColor: UIColor? = nil
    - parameter foregroundColor: UIColor? = nil
    - parameter shadow: NSShadow? = nil
    - parameter accentShadow: NSShadow? = nil
    - parameter lineWidth: CGFloat = 0
    - parameter corners: UIRectCorner = Painter.defaultCorners
    - parameter radii: CGSize = Painter.defaultRadii
    - parameter blendMode: CGBlendMode = kCGBlendModeNormal
    - parameter stroke: Bool = false
    - parameter fill: Bool = true
    - parameter alpha: CGFloat = 1.0
    - parameter image: UIImage? = nil
    - parameter text: String? = nil
    - parameter fontAttributes: [String AnyObject]? = nil
    - parameter adjustFontSize: Bool = false
    */
    public init(
      rect: CGRect,
      color: UIColor? = nil,
      accentColor: UIColor? = nil,
      foregroundColor: UIColor? = nil,
      shadow: NSShadow? = nil,
      accentShadow: NSShadow? = nil,
      lineWidth: CGFloat = 0,
      corners: UIRectCorner = Painter.defaultCorners,
      radii: CGSize = Painter.defaultRadii,
      blendMode: CGBlendMode = .Normal,
      stroke: Bool = false,
      fill: Bool = true,
      alpha: CGFloat = 1.0,
      image: UIImage? = nil,
      text: String? = nil,
      fontAttributes: [String:AnyObject]? = nil,
      adjustFontSize: Bool = false)
    {
      self.rect = rect
      self.color = color
      self.accentColor = accentColor
      self.foregroundColor = foregroundColor
      self.shadow = shadow
      self.accentShadow = accentShadow
      self.lineWidth = lineWidth
      self.corners = corners
      self.radii = radii
      self.blendMode = blendMode
      self.stroke = stroke
      self.fill = fill
      self.alpha = alpha
      self.image = image
      self.text = text
      self.fontAttributes = fontAttributes
      self.adjustFontSize = adjustFontSize
    }

    public enum Parameter: String {
      case Color = "color"
      case AccentColor = "accentColor"
      case ForegroundColor = "foregroundColor"
      case Rect = "rect"
      case LineWidth = "lineWidth"
      case Corners = "corners"
      case Radii = "radii"
      case Shadow = "shadow"
      case AccentShadow = "accentShadow"
      case BlendMode = "blendMode"
      case Stroke = "stroke"
      case Fill = "fill"
      case Alpha = "alpha"
      case Image = "image"
      case Text = "text"
      case FontAttributes = "fontAttributes"
      case AdjustFontSize = "adjustFontSize"

      public func value<T>(attrs: Attributes) -> T? {
        switch self {
          case .Color: return attrs.color as? T
          case .AccentColor: return attrs.accentColor as? T
          case .ForegroundColor: return attrs.foregroundColor as? T
          case .Rect: return attrs.rect as? T
          case .LineWidth: return attrs.lineWidth as? T
          case .Corners: return attrs.corners as? T
          case .Radii: return attrs.radii as? T
          case .Shadow: return attrs.shadow as? T
          case .AccentShadow: return attrs.accentShadow as? T
          case .BlendMode: return attrs.blendMode as? T
          case .Stroke: return attrs.stroke as? T
          case .Fill: return attrs.fill as? T
          case .Alpha: return attrs.alpha as? T
          case .Image: return attrs.image as? T
          case .Text: return attrs.text as? T
          case .FontAttributes: return attrs.fontAttributes as? T
          case .AdjustFontSize: return attrs.adjustFontSize as? T
        }
      }

      public func setValue<T>(value: T?, inout forAttributes attrs: Attributes) {
        switch self {
          case .Color: attrs.color = value as? UIColor
          case .AccentColor: attrs.accentColor = value as? UIColor
          case .ForegroundColor: attrs.foregroundColor = value as? UIColor
          case .Rect: if let r = value as? CGRect { attrs.rect = r }
          case .LineWidth: if let f = value as? CGFloat { attrs.lineWidth = f }
          case .Alpha: if let f = value as? CGFloat { attrs.alpha = f }
          case .Corners: if let c = value as? UIRectCorner { attrs.corners = c }
          case .Radii: if let s = value as? CGSize { attrs.radii = s }
          case .Shadow: attrs.shadow = value as? NSShadow
          case .AccentShadow: attrs.accentShadow = value as? NSShadow
          case .BlendMode:  if let b = value as? CGBlendMode { attrs.blendMode = b }
          case .Stroke:  if let b = value as? Bool { attrs.stroke = b }
          case .Fill:  if let b = value as? Bool { attrs.fill = b }
          case .AdjustFontSize: if let b = value as? Bool { attrs.adjustFontSize = b }
          case .Image: attrs.image = value as? UIImage
          case .Text: attrs.text = value as? String
          case .FontAttributes: attrs.fontAttributes = value as? [String:AnyObject]
        }
      }
    }

    // ???: Getting different results when using this initializer
    public init(dictionaryLiteral elements: (Parameter, Any)...) {
      rect = CGRect.zeroRect
      apply(elements){$0.setValue($1, forAttributes: &self)}
    }
  }

  public typealias Shape = RemoteElement.Shape

  // MARK: - Static properties

  public static let defaultBackgroundColor = UIColor(r: 41, g: 40, b: 39, a: 255)!
  public static let defaultForegroundColor = white
  public static let blueAccentColor = UIColor(r: 50, g: 143, b: 239, a: 255)!
  public static let defaultRadii = CGSize(width: 10, height: 20)
  public static let defaultCorners: UIRectCorner = .AllCorners
  public static let defaultFont = UIFont.systemFontOfSize(24.0)

  public static let verticalGloss: CGGradient = CGGradientCreateWithColors(
    CGColorSpaceCreateDeviceRGB(),
    [white0_0.CGColor, white0_0.blendedColorWithFraction(0.5, ofColor: white).CGColor, white.CGColor],
    [0, 0.4, 1]
  )!

  public static let innerShadow:     NSShadow = NSShadow(color: white,     offset: offset1_neg1, blurRadius: 2)
  public static let outerShadow:     NSShadow = NSShadow(color: black,     offset: offset1_neg1, blurRadius: 2)
  public static let strokeShadow:    NSShadow = NSShadow(color: lightGray, offset: offset1_neg1, blurRadius: 1)
  public static let insettingShadow: NSShadow = NSShadow(color: white0_5,  offset: offset1_6,    blurRadius: 0)
  public static let plasticShadow:   NSShadow = NSShadow(color: white,     offset: offset1_neg6, blurRadius: 1)
  public static let cutoutShadow:    NSShadow = NSShadow(color: black,     offset: offset1_neg1, blurRadius: 1)
  public static let glowingShadow:   NSShadow = NSShadow(color: white,     offset: offset1_neg1, blurRadius: 5)


  // MARK: - Gettings paths for a shape

  /**
  pathForShape:withAttributes:

  - parameter shape: Shape
  - parameter attrs: Attributes

  - returns: UIBezierPath
  */
  public class func pathForShape(shape: Shape, withAttributes attrs: Attributes) -> UIBezierPath {
    let path: UIBezierPath
    switch shape {
      case .Diamond:
        path = UIBezierPath(diamondInRect: attrs.rect)
      case .Oval:
        path = UIBezierPath(ovalInRect: attrs.rect)
      case .Triangle:
        path = UIBezierPath(triangleInRect: attrs.rect)
      case .Rectangle:
        path = UIBezierPath(rect: attrs.rect)
      case .RoundedRectangle:
        path = UIBezierPath(roundedRect: attrs.rect, byRoundingCorners: attrs.corners, cornerRadii: attrs.radii)
      case .Undefined:
        path = UIBezierPath()
    }
    path.lineWidth = attrs.lineWidth
    return path
  }

  /**
  inscribedRectangleForShape:withAttributes:

  - parameter shape: Shape
  - parameter attrs: Attributes

  - returns: UIBezierPath
  */
  public class func inscribedRectangleForShape(shape: Shape, withAttributes attrs: Attributes) -> UIBezierPath {
    switch shape {
      case .RoundedRectangle:
        let halfRadii = attrs.radii * 0.5
        return UIBezierPath(rect: attrs.rect.rectByInsetting(dx: halfRadii.width, dy: halfRadii.height))
      case .Oval:
        let (w, h) = attrs.rect.size.unpack
        return UIBezierPath(rect: attrs.rect.rectByInsetting(dx: sqrt(w * 2.0) * 0.5, dy: sqrt(h * 2.0) * 0.5))
      case .Triangle:
        let size = attrs.rect.size * 0.5
        let origin = CGPoint(x: 0.5 * size.width, y: size.height)
        return UIBezierPath(rect: CGRect(origin: origin, size: size))
      case .Diamond:
        let (dx, dy) = (attrs.rect.size * 0.25).unpack
        return UIBezierPath(rect: attrs.rect.rectByInsetting(dx: dx, dy: dy))
      default:
        return UIBezierPath(rect: attrs.rect)
    }
  }

  // MARK: - Single element drawing routines

  /**
  drawText:withAttributes:boundByShape:

  - parameter text: String
  - parameter attrs: Attributes
  - parameter shape: Shape = .Rectangle
  */
  public class func drawText(text: String, withAttributes attrs: Attributes, boundByShape shape: Shape = .Rectangle) {

    let path = inscribedRectangleForShape(shape, withAttributes: attrs)
    let bounds = path.bounds
    if bounds.isEmpty { return }

    let appliedFontSize: CGFloat = min(bounds.width / CGFloat(text.utf16.count), bounds.height)

    let context = UIGraphicsGetCurrentContext()

    CGContextSaveGState(context)                                                          // context: •
    attrs.shadow?.setShadow()

    CGContextSetAlpha(context, attrs.alpha)
    CGContextSetBlendMode(context, attrs.blendMode)
    CGContextBeginTransparencyLayer(context, nil)                                         // transparency: •

    CGContextSaveGState(context)                                                          // context: ••
    attrs.accentShadow?.setShadow()
    CGContextBeginTransparencyLayer(context, nil)                                         // transparency: ••

    var textAttributes: [String:AnyObject] = attrs.fontAttributes ?? [:]
    if let font = textAttributes[NSFontAttributeName] as? UIFont where attrs.adjustFontSize {
      textAttributes[NSFontAttributeName] = font.fontWithSize(appliedFontSize)
    } else if textAttributes[NSFontAttributeName] == nil {
      textAttributes[NSFontAttributeName] = defaultFont.fontWithSize(appliedFontSize)
    }
    if textAttributes[NSParagraphStyleAttributeName] == nil {
      textAttributes[NSParagraphStyleAttributeName] = NSParagraphStyle.paragraphStyleWithAttributes(alignment: .Center)
    }
    if let textColor = attrs.foregroundColor ?? attrs.color {
      textAttributes[NSForegroundColorAttributeName] = textColor
    }

    let textHeight: CGFloat = (text as NSString).boundingRectWithSize(CGSize(width: bounds.width, height: CGFloat.infinity),
                                                              options: NSStringDrawingOptions.UsesLineFragmentOrigin,
                                                           attributes: textAttributes,
                                                              context: nil).size.height
    CGContextSaveGState(context)                                                          // context: •••
    path.addClip()

    let textRect = CGRect(x: bounds.minX,
                          y: bounds.minY + (bounds.height - textHeight) * 0.5,
                          width: bounds.width,
                          height: textHeight)
    (text as NSString).drawInRect(textRect, withAttributes: textAttributes)

    CGContextRestoreGState(context)                                                       // context: ••
    CGContextEndTransparencyLayer(context)                                                // transparency: •
    CGContextRestoreGState(context)                                                       // context: •
    CGContextEndTransparencyLayer(context)                                                // transparency:
    CGContextRestoreGState(context)                                                       // context:

  }

  /**
  drawImage:withAttributes:boundByShape:

  - parameter image: UIImage
  - parameter withAttributes: Attributes
  - parameter shape: Shape = .Rectangle
  */
  public class func drawImage(image: UIImage, withAttributes attrs: Attributes, boundByShape shape: Shape = .Rectangle) {
    let path = inscribedRectangleForShape(shape, withAttributes: attrs)
    let bounds = path.bounds
    if bounds.isEmpty { return }
    let imageSize = bounds.size.contains(image.size)
                      ? image.size
                      : image.size.aspectMappedToSize(bounds.size, binding: true)

    let imageRect = CGRect(origin: bounds.center - (imageSize * 0.5), size: imageSize)
    let context = UIGraphicsGetCurrentContext()

    CGContextSaveGState(context)                                                          // context: •

    attrs.shadow?.setShadow()
    CGContextSetAlpha(context, attrs.alpha)
    CGContextSetBlendMode(context, attrs.blendMode)
    CGContextBeginTransparencyLayer(context, nil)                                         // transparency: •

    CGContextSaveGState(context)                                                          // context: ••
    attrs.accentShadow?.setShadow()
    CGContextBeginTransparencyLayer(context, nil)                                         // transparency: ••

    CGContextSaveGState(context)                                                          // context: •••

    path.addClip()
    image.drawInRect(imageRect)

    CGContextRestoreGState(context)                                                       // context: ••
    CGContextEndTransparencyLayer(context)                                                // transparency: •
    CGContextRestoreGState(context)                                                       // context: •
    CGContextEndTransparencyLayer(context)                                                // transparency:
    CGContextRestoreGState(context)                                                       // context:
  }

  /**
  drawShape:withAttributes:

  - parameter shape: Shape
  - parameter attributes: Attributes
  */
  public class func drawShape(shape: Shape, var withAttributes attributes: Attributes) {

    let context = UIGraphicsGetCurrentContext()

    CGContextSaveGState(context)
    CGContextSetBlendMode(context, attributes.blendMode)
    CGContextSetAlpha(context, attributes.alpha)

    UIRectClip(attributes.rect)
    CGContextTranslateCTM(context, attributes.rect.origin.x, attributes.rect.origin.y)

    attributes.shadow?.setShadow()
    attributes.rect = CGRect(size: attributes.rect.size).rectByInsetting(dx: 1, dy: 1)

    let path = pathForShape(shape, withAttributes: attributes)

    if attributes.fill, let color = attributes.color {
      color.setFill()
      path.fill()
    }

    if attributes.stroke, let color = attributes.accentColor ?? attributes.foregroundColor ?? attributes.color {
      color.setStroke()
      path.stroke()
    }

    CGContextRestoreGState(context)

  }

  // MARK: - Composite drawing routines

  /**
  drawBackgroundWithShape:attributes:

  - parameter shape: Shape
  - parameter attributes: Attributes
  */
  public class func drawBackgroundWithShape(shape: Shape, attributes: Attributes) {
    let context = UIGraphicsGetCurrentContext()

    // Draw the base with an outer shadow
    var attrs = attributes
    attrs.shadow = outerShadow
    drawShape(shape, withAttributes: attrs)

    CGContextBeginTransparencyLayer(context, nil)

    let opaqueInnerShadow = innerShadow.shadowWithAlpha(1.0)
    attrs.shadow = opaqueInnerShadow
    attrs.blendMode = .SourceOut
    attrs.color = opaqueInnerShadow.color

    drawShape(shape, withAttributes: attrs)

    CGContextEndTransparencyLayer(context)
  }

  /**
  strokeShape:withAttributes:

  - parameter shape: Shape
  - parameter attributes: Attributes
  */
  public class func strokeShape(shape: Shape, withAttributes attributes: Attributes) {
    var strokeAttrs = attributes
    strokeAttrs.shadow = strokeShadow
    strokeAttrs.stroke = true
    strokeAttrs.fill = false
    strokeAttrs.lineWidth = max(strokeAttrs.lineWidth, 2)
    drawShape(shape, withAttributes: strokeAttrs)
  }

  /**
  drawGlossWithShape:attributes:

  - parameter shape: Shape
  - parameter attributes: Attributes
  */
  public class func drawGlossWithShape(shape: Shape, attributes: Attributes)
  {

    let context = UIGraphicsGetCurrentContext()

    CGContextSaveGState(context)
    CGContextSetBlendMode(context, attributes.blendMode)
    CGContextSetAlpha(context, attributes.alpha)

    let path = pathForShape(shape, withAttributes: attributes)
    if !path.bounds.isEmpty { path.addClip() }

    let bounds = CGContextGetClipBoundingBox(context)
    let p1 = CGPoint(x: bounds.midX, y: bounds.midY + 0.5 * bounds.height)
    let p2 = CGPoint(x: bounds.midX, y: bounds.midY)
    CGContextDrawLinearGradient(context, verticalGloss, p1, p2, [.DrawsBeforeStartLocation, .DrawsAfterEndLocation])

    CGContextRestoreGState(context)
  }

  /**
  drawBaseWithShape:attributes:

  - parameter shape: Shape
  - parameter attributes: Attributes
  */
  public class func drawBaseWithShape(shape: Shape, attributes: Attributes) {

    // Draw the base with an outer shadow
    drawBackgroundWithShape(shape, attributes: attributes)

    // Stroke shape if attributes have stroke set to true
    if attributes.stroke { strokeShape(shape, withAttributes: attributes) }

    // Draw glossy overlay
    var glossAttrs = attributes
    glossAttrs.rect = attributes.rect.rectByInsetting(dx: 6, dy: 6)
    glossAttrs.alpha = 0.1
    glossAttrs.blendMode = .SoftLight

    drawGlossWithShape(shape, attributes: glossAttrs)
  }

  /**
  drawButtonWithShape:attributes:gloss:highlighted:

  - parameter shape: Shape
  - parameter attributes: Attributes
  - parameter gloss: Bool = true
  - parameter highlighted: Bool = false
  */
  public class func drawButtonWithShape(shape: Shape, attributes: Attributes, gloss: Bool = true, highlighted: Bool = false) {
    let context = UIGraphicsGetCurrentContext()

    let baseRect = attributes.rect.rectByInsetting(dx: 4, dy: 4).integerRect

    let bleedRect = baseRect.rectByInsetting(dx: 4, dy: 4)

    let accentColor = attributes.accentColor ?? defaultForegroundColor
    let accentShadow: NSShadow? = highlighted ? NSShadow(color: accentColor, offset: CGSize.zeroSize, blurRadius: 5) : nil

    // Draw shape filled with accent color
    var attrs = Attributes(rect: bleedRect)
    attrs.color = accentColor
    attrs.corners = attributes.corners
    attrs.radii = attributes.radii
    drawShape(shape, withAttributes: attrs)

    CGContextSaveGState(context)                                                            // context: •
    accentShadow?.setShadow()
    CGContextBeginTransparencyLayer(context, nil)                                           // transparency: •

    // Draw background
    attrs.color = attributes.color ?? defaultBackgroundColor
    attrs.accentColor = accentColor
    attrs.rect = baseRect
    attrs.stroke = attributes.stroke
    drawBaseWithShape(shape, attributes: attrs)

    CGContextSaveGState(context)                                                            // context: ••
    CGContextSetBlendMode(context, .DestinationOut)
    CGContextBeginTransparencyLayer(context, nil)                                           // transparency: ••


    if let image = attributes.image {

      var imageAttrs = attributes
      imageAttrs.rect = baseRect
      imageAttrs.alpha = 0.9
      imageAttrs.shadow = innerShadow
      imageAttrs.accentShadow = accentShadow

      drawImage(image, withAttributes: imageAttrs, boundByShape: shape)
    }

    if let text = attributes.text {

      var txtAttrs = attributes
      txtAttrs.rect = baseRect
      txtAttrs.shadow = accentShadow

      drawText(text, withAttributes: txtAttrs, boundByShape: shape)
    }


    CGContextEndTransparencyLayer(context)                                                  // transparency: •
    CGContextRestoreGState(context)                                                         // context: •


    CGContextEndTransparencyLayer(context)                                                  // transparency:
    CGContextRestoreGState(context)                                                         // context:


    if gloss {

      var glossAttrs = Attributes(rect: baseRect)
      glossAttrs.corners = attributes.corners
      glossAttrs.alpha = 0.1
      glossAttrs.radii = attributes.radii
      glossAttrs.blendMode = .SoftLight

      drawGlossWithShape(shape, attributes: glossAttrs)
    }

  }

  // MARK: - Specialized drawing routines

  /**
  drawBatteryStatus:hasPower:chargeLevel:frame:

  - parameter #color: UIColor
  - parameter hasPower: Bool
  - parameter chargeLevel: CGFloat
  - parameter frame: CGRect
  */
  public class func drawBatteryStatus(color color: UIColor, hasPower: Bool, chargeLevel: CGFloat, frame: CGRect) {
    let context = UIGraphicsGetCurrentContext()
    let squaredSize = CGSize(width: min(frame.width, frame.height),
                                            height: min(frame.width, frame.height))
    let squaredFrame = CGRect(x: frame.origin.x + (frame.width - squaredSize.width) / 2.0,
                                        y: frame.origin.y + (frame.size.height - squaredSize.height) / 2.0,
                                        width: squaredSize.width,
                                        height: squaredSize.height)
    let batteryFrame = CGRect(x: squaredFrame.origin.x,
                              y: squaredFrame.origin.y + (squaredFrame.height - squaredFrame.width * 4 / 7.0) / 2.0,
                              width: squaredFrame.width,
                              height: squaredFrame.width * 4 / 7.0)
    let symbolRect = CGRect(x: batteryFrame.minX,
                            y:  batteryFrame.minY,
                            width:  floor(batteryFrame.width + 0.5),
                            height: floor(batteryFrame.height + 0.21) + 0.29)
    CGContextSaveGState(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)
    CGContextScaleCTM(context, symbolRect.size.width / 224, symbolRect.size.height / 128)

    Painter.drawBatteryIcon(color: color, hasPower: hasPower, chargeLevel: chargeLevel)
    CGContextRestoreGState(context)
  }

  /**
  drawBatteryIcon:hasPower:chargeLevel:

  - parameter #color: UIColor
  - parameter hasPower: Bool
  - parameter chargeLevel: CGFloat
  */
  public class func drawBatteryIcon(color color: UIColor, hasPower: Bool, chargeLevel: CGFloat) {

    // Draw battery outline
    let outlinePath = UIBezierPath()
    outlinePath.moveToPoint(CGPoint(x: 208, y: 44))
    outlinePath.addLineToPoint(CGPoint(x: 208, y: 84))
    outlinePath.addCurveToPoint(CGPoint(x: 216, y: 76),

                       controlPoint1: CGPoint(x: 212.42, y: 84),

                 controlPoint2: CGPoint(x: 216, y: 80.42))
    outlinePath.addLineToPoint(CGPoint(x: 216, y: 52))
    outlinePath.addCurveToPoint(CGPoint(x: 208, y: 44),

                       controlPoint1: CGPoint(x: 216, y: 47.58),

                 controlPoint2: CGPoint(x: 212.42, y: 44))
    outlinePath.closePath()
    outlinePath.moveToPoint(CGPoint(x: 144, y: 16))
    outlinePath.addLineToPoint(CGPoint(x: 16.03, y: 16))
    outlinePath.addLineToPoint(CGPoint(x: 16.03, y: 112))
    outlinePath.addCurveToPoint(CGPoint(x: 16, y: 16),

                       controlPoint1: CGPoint(x: 16, y: 112),

                 controlPoint2: CGPoint(x: 16, y: 16))
    outlinePath.addLineToPoint(CGPoint(x: 144, y: 16))
    outlinePath.closePath()
    outlinePath.moveToPoint(CGPoint(x: 192, y: 8))
    outlinePath.addLineToPoint(CGPoint(x: 16, y: 8))
    outlinePath.addCurveToPoint(CGPoint(x: 8, y: 16),

                       controlPoint1: CGPoint(x: 11.58, y: 8),

                 controlPoint2: CGPoint(x: 8, y: 11.58))
    outlinePath.addLineToPoint(CGPoint(x: 8, y: 112))
    outlinePath.addCurveToPoint(CGPoint(x: 16, y: 120),

                       controlPoint1: CGPoint(x: 8, y: 116.42),

                 controlPoint2: CGPoint(x: 11.58, y: 120))
    outlinePath.addLineToPoint(CGPoint(x: 192, y: 120))
    outlinePath.addCurveToPoint(CGPoint(x: 200, y: 112),

                       controlPoint1: CGPoint(x: 196.42, y: 120),

                 controlPoint2: CGPoint(x: 200, y: 116.42))
    outlinePath.addLineToPoint(CGPoint(x: 200, y: 16))
    outlinePath.addCurveToPoint(CGPoint(x: 192, y: 8),

                       controlPoint1: CGPoint(x: 200, y: 11.58),

                 controlPoint2: CGPoint(x: 196.42, y: 8))
    outlinePath.closePath()
    outlinePath.moveToPoint(CGPoint(x: 208, y: 16))
    outlinePath.addLineToPoint(CGPoint(x: 208, y: 36))
    outlinePath.addLineToPoint(CGPoint(x: 216, y: 36))
    outlinePath.addCurveToPoint(CGPoint(x: 224, y: 44),

                       controlPoint1: CGPoint(x: 220.42, y: 36),

                 controlPoint2: CGPoint(x: 224, y: 39.58))
    outlinePath.addLineToPoint(CGPoint(x: 224, y: 84))
    outlinePath.addCurveToPoint(CGPoint(x: 216, y: 92),

                       controlPoint1: CGPoint(x: 224, y: 88.42),

                 controlPoint2: CGPoint(x: 220.42, y: 92))
    outlinePath.addLineToPoint(CGPoint(x: 208, y: 92))
    outlinePath.addLineToPoint(CGPoint(x: 208, y: 112))
    outlinePath.addCurveToPoint(CGPoint(x: 192, y: 128),

                       controlPoint1: CGPoint(x: 208, y: 120.84),

                 controlPoint2: CGPoint(x: 200.84, y: 128))
    outlinePath.addLineToPoint(CGPoint(x: 16, y: 128))
    outlinePath.addCurveToPoint(CGPoint(x: 0, y: 112),

                       controlPoint1: CGPoint(x: 7.16, y: 128),

                 controlPoint2: CGPoint(x: 0, y: 120.84))
    outlinePath.addLineToPoint(CGPoint(x: 0, y: 16))
    outlinePath.addCurveToPoint(CGPoint(x: 10.1, y: 1.12),

                       controlPoint1: CGPoint(x: 0, y: 9.25),

                 controlPoint2: CGPoint(x: 4.18, y: 3.47))
    outlinePath.addCurveToPoint(CGPoint(x: 16, y: 0),

                       controlPoint1: CGPoint(x: 11.93, y: 0.4),

                 controlPoint2: CGPoint(x: 13.92, y: 0))
    outlinePath.addLineToPoint(CGPoint(x: 192, y: 0))
    outlinePath.addCurveToPoint(CGPoint(x: 208, y: 16),

                       controlPoint1: CGPoint(x: 200.84, y: 0),

                 controlPoint2: CGPoint(x: 208, y: 7.16))
    outlinePath.closePath()
    color.setFill()
    outlinePath.fill()


    // Draw charge fill
    let chargeMaxX: CGFloat = 16 + 175 * chargeLevel
    let chargePath = UIBezierPath()
    chargePath.moveToPoint(CGPoint(x: 16, y: 112))
    chargePath.addLineToPoint(CGPoint(x: chargeMaxX, y: 112))
    chargePath.addLineToPoint(CGPoint(x: chargeMaxX, y: 16))
    chargePath.addLineToPoint(CGPoint(x: 16, y: 16))
    chargePath.addLineToPoint(CGPoint(x: 16, y: 112))
    chargePath.closePath()
    color.setFill()
    chargePath.fill()

    // Draw lightning bolt or plug if appropriate
    let batteryIconColor = color.colorWithHighlight(0.3)

    if hasPower && chargeLevel < 1 {
        let lightningBoltPath = UIBezierPath()
        lightningBoltPath.moveToPoint(CGPoint(x: 130.91, y: 51.57))
        lightningBoltPath.addLineToPoint(CGPoint(x: 109.6, y: 51.57))
        lightningBoltPath.addLineToPoint(CGPoint(x: 120.26, y: 14.27))
        lightningBoltPath.addLineToPoint(CGPoint(x: 95.39, y: 14.27))
        lightningBoltPath.addLineToPoint(CGPoint(x: 81.18, y: 71.1))
        lightningBoltPath.addLineToPoint(CGPoint(x: 106.05, y: 71.1))
        lightningBoltPath.addLineToPoint(CGPoint(x: 100.72, y: 113.73))
        lightningBoltPath.addLineToPoint(CGPoint(x: 130.91, y: 51.57))
        lightningBoltPath.closePath()
        lightningBoltPath.usesEvenOddFillRule = true;

        batteryIconColor.setFill()
        lightningBoltPath.fill()
    }


    else if hasPower && chargeLevel == 1 {
        let plugPath = UIBezierPath()
        plugPath.moveToPoint(CGPoint(x: 161.55, y: 56))
        plugPath.addLineToPoint(CGPoint(x: 161.55, y: 48))
        plugPath.addLineToPoint(CGPoint(x: 141.55, y: 48))
        plugPath.addLineToPoint(CGPoint(x: 141.55, y: 36))
        plugPath.addLineToPoint(CGPoint(x: 107.55, y: 36))
        plugPath.addCurveToPoint(CGPoint(x: 104.35, y: 37.6),

                           controlPoint1: CGPoint(x: 106.29, y: 36),

                     controlPoint2: CGPoint(x: 105.1, y: 36.59))
        plugPath.addLineToPoint(CGPoint(x: 93.55, y: 52))
        plugPath.addLineToPoint(CGPoint(x: 53.55, y: 52))
        plugPath.addCurveToPoint(CGPoint(x: 49.55, y: 56),

                           controlPoint1: CGPoint(x: 51.34, y: 52),

                     controlPoint2: CGPoint(x: 49.55, y: 53.79))
        plugPath.addLineToPoint(CGPoint(x: 49.55, y: 72))
        plugPath.addCurveToPoint(CGPoint(x: 53.55, y: 76),

                           controlPoint1: CGPoint(x: 49.55, y: 74.21),

                     controlPoint2: CGPoint(x: 51.34, y: 76))
        plugPath.addLineToPoint(CGPoint(x: 93.55, y: 76))
        plugPath.addLineToPoint(CGPoint(x: 104.35, y: 90.4))
        plugPath.addCurveToPoint(CGPoint(x: 107.55, y: 92),

                           controlPoint1: CGPoint(x: 105.1, y: 91.41),

                     controlPoint2: CGPoint(x: 106.29, y: 92))
        plugPath.addLineToPoint(CGPoint(x: 141.55, y: 92))
        plugPath.addLineToPoint(CGPoint(x: 141.55, y: 80))
        plugPath.addLineToPoint(CGPoint(x: 161.55, y: 80))
        plugPath.addLineToPoint(CGPoint(x: 161.55, y: 72))
        plugPath.addLineToPoint(CGPoint(x: 141.55, y: 72))
        plugPath.addLineToPoint(CGPoint(x: 141.55, y: 56))
        plugPath.addLineToPoint(CGPoint(x: 161.55, y: 56))
        plugPath.closePath()
        batteryIconColor.setFill()
        plugPath.fill()
    }
  }

  /**
  drawWifiIcon:connected:

  - parameter #color: UIColor
  - parameter connected: Bool
  */
  public class func drawWifiIcon(color color: UIColor, connected: Bool) {

    let path = UIBezierPath()

    if (connected) {
        path.moveToPoint(CGPoint(x: 181.46, y: 43.82))
        path.addLineToPoint(CGPoint(x: 181.52, y: 43.79))
        path.addCurveToPoint(CGPoint(x: 91, y: 0),
               controlPoint1: CGPoint(x: 180.42, y: 42),
               controlPoint2: CGPoint(x: 153.85, y: 0))
        path.addCurveToPoint(CGPoint(x: 0.48, y: 43.79),
               controlPoint1: CGPoint(x: 28.15, y: 0),
               controlPoint2: CGPoint(x: 1.58, y: 42))
        path.addLineToPoint(CGPoint(x: 0.54, y: 43.82))
        path.addCurveToPoint(CGPoint(x: 0, y: 45.52),
               controlPoint1: CGPoint(x: 0.23, y: 44.33),
               controlPoint2: CGPoint(x: 0, y: 44.88))
        path.addCurveToPoint(CGPoint(x: 0.95, y: 47.81),
               controlPoint1: CGPoint(x: 0, y: 46.41),
               controlPoint2: CGPoint(x: 0.36, y: 47.23))
        path.addLineToPoint(CGPoint(x: 10.7, y: 57.56))
        path.addCurveToPoint(CGPoint(x: 13, y: 58.51),
               controlPoint1: CGPoint(x: 11.29, y: 58.15),
               controlPoint2: CGPoint(x: 12.1, y: 58.51))
        path.addCurveToPoint(CGPoint(x: 15.67, y: 57.02),
               controlPoint1: CGPoint(x: 14.14, y: 58.51),
               controlPoint2: CGPoint(x: 15.09, y: 57.9))
        path.addLineToPoint(CGPoint(x: 15.7, y: 57.04))
        path.addCurveToPoint(CGPoint(x: 91, y: 19.5),
               controlPoint1: CGPoint(x: 15.95, y: 56.67),
               controlPoint2: CGPoint(x: 41.31, y: 19.5))
        path.addCurveToPoint(CGPoint(x: 166.3, y: 57.05),
               controlPoint1: CGPoint(x: 140.55, y: 19.5),
               controlPoint2: CGPoint(x: 166.05, y: 56.67))
        path.addLineToPoint(CGPoint(x: 166.34, y: 57.02))
        path.addCurveToPoint(CGPoint(x: 169, y: 58.51),
               controlPoint1: CGPoint(x: 166.92, y: 57.9),
               controlPoint2: CGPoint(x: 167.87, y: 58.51))
        path.addCurveToPoint(CGPoint(x: 171.3, y: 57.56),
               controlPoint1: CGPoint(x: 169.9, y: 58.51),
               controlPoint2: CGPoint(x: 170.71, y: 58.15))
        path.addLineToPoint(CGPoint(x: 181.05, y: 47.81))
        path.addCurveToPoint(CGPoint(x: 182, y: 45.52),
               controlPoint1: CGPoint(x: 181.64, y: 47.23),
               controlPoint2: CGPoint(x: 182, y: 46.41))
        path.addCurveToPoint(CGPoint(x: 181.46, y: 43.82),
               controlPoint1: CGPoint(x: 182, y: 44.88),
               controlPoint2: CGPoint(x: 181.77, y: 44.33))
        path.closePath()
        path.moveToPoint(CGPoint(x: 129.29, y: 95.45))
        path.addCurveToPoint(CGPoint(x: 91, y: 77.99),
               controlPoint1: CGPoint(x: 128.72, y: 94.74),
               controlPoint2: CGPoint(x: 115.04, y: 77.99))
        path.addCurveToPoint(CGPoint(x: 52.71, y: 95.45),
               controlPoint1: CGPoint(x: 66.97, y: 77.99),
               controlPoint2: CGPoint(x: 53.28, y: 94.74))
        path.addLineToPoint(CGPoint(x: 52.76, y: 95.49))
        path.addCurveToPoint(CGPoint(x: 52, y: 97.51),
               controlPoint1: CGPoint(x: 52.31, y: 96.05),
               controlPoint2: CGPoint(x: 52, y: 96.73))
        path.addCurveToPoint(CGPoint(x: 52.95, y: 99.8),
               controlPoint1: CGPoint(x: 52, y: 98.4),
               controlPoint2: CGPoint(x: 52.36, y: 99.22))
        path.addLineToPoint(CGPoint(x: 62.7, y: 109.55))
        path.addCurveToPoint(CGPoint(x: 65, y: 110.5),
               controlPoint1: CGPoint(x: 63.29, y: 110.14),
               controlPoint2: CGPoint(x: 64.1, y: 110.5))
        path.addCurveToPoint(CGPoint(x: 67.56, y: 109.16),
               controlPoint1: CGPoint(x: 66.07, y: 110.5),
               controlPoint2: CGPoint(x: 66.97, y: 109.96))
        path.addLineToPoint(CGPoint(x: 67.6, y: 109.19))
        path.addCurveToPoint(CGPoint(x: 91, y: 97.48),
               controlPoint1: CGPoint(x: 67.68, y: 109.07),
               controlPoint2: CGPoint(x: 76.64, y: 97.48))
        path.addCurveToPoint(CGPoint(x: 114.4, y: 109.18),
               controlPoint1: CGPoint(x: 105.36, y: 97.48),
               controlPoint2: CGPoint(x: 114.32, y: 109.07))
        path.addLineToPoint(CGPoint(x: 114.43, y: 109.16))
        path.addCurveToPoint(CGPoint(x: 117, y: 110.5),
               controlPoint1: CGPoint(x: 115.03, y: 109.95),
               controlPoint2: CGPoint(x: 115.93, y: 110.5))
        path.addCurveToPoint(CGPoint(x: 119.3, y: 109.55),
               controlPoint1: CGPoint(x: 117.9, y: 110.5),
               controlPoint2: CGPoint(x: 118.71, y: 110.14))
        path.addLineToPoint(CGPoint(x: 129.05, y: 99.8))
        path.addCurveToPoint(CGPoint(x: 130, y: 97.51),
               controlPoint1: CGPoint(x: 129.64, y: 99.22),
               controlPoint2: CGPoint(x: 130, y: 98.4))
        path.addCurveToPoint(CGPoint(x: 129.24, y: 95.49),
               controlPoint1: CGPoint(x: 130, y: 96.73),
               controlPoint2: CGPoint(x: 129.69, y: 96.05))
        path.addLineToPoint(CGPoint(x: 129.29, y: 95.45))
        path.closePath()
        path.moveToPoint(CGPoint(x: 103.66, y: 122.02))
        path.addCurveToPoint(CGPoint(x: 91, y: 113.73),
               controlPoint1: CGPoint(x: 103.49, y: 121.69),
               controlPoint2: CGPoint(x: 99.41, y: 113.73))
        path.addCurveToPoint(CGPoint(x: 78.34, y: 122.02),
               controlPoint1: CGPoint(x: 82.59, y: 113.73),
               controlPoint2: CGPoint(x: 78.51, y: 121.69))
        path.addLineToPoint(CGPoint(x: 78.38, y: 122.05))
        path.addCurveToPoint(CGPoint(x: 78, y: 123.5),
               controlPoint1: CGPoint(x: 78.16, y: 122.49),
               controlPoint2: CGPoint(x: 78, y: 122.97))
        path.addCurveToPoint(CGPoint(x: 78.95, y: 125.8),
               controlPoint1: CGPoint(x: 78, y: 124.4),
               controlPoint2: CGPoint(x: 78.36, y: 125.21))
        path.addLineToPoint(CGPoint(x: 88.7, y: 135.55))
        path.addCurveToPoint(CGPoint(x: 91, y: 136.5),
               controlPoint1: CGPoint(x: 89.29, y: 136.14),
               controlPoint2: CGPoint(x: 90.1, y: 136.5))
        path.addCurveToPoint(CGPoint(x: 93.3, y: 135.55),
               controlPoint1: CGPoint(x: 91.9, y: 136.5),
               controlPoint2: CGPoint(x: 92.71, y: 136.14))
        path.addLineToPoint(CGPoint(x: 103.05, y: 125.8))
        path.addCurveToPoint(CGPoint(x: 104, y: 123.5),
               controlPoint1: CGPoint(x: 103.64, y: 125.21),
               controlPoint2: CGPoint(x: 104, y: 124.4))
        path.addCurveToPoint(CGPoint(x: 103.62, y: 122.05),
               controlPoint1: CGPoint(x: 104, y: 122.97),
               controlPoint2: CGPoint(x: 103.84, y: 122.49))
        path.addLineToPoint(CGPoint(x: 103.66, y: 122.02))
        path.closePath()
        path.moveToPoint(CGPoint(x: 155.31, y: 69.49))
        path.addCurveToPoint(CGPoint(x: 91, y: 38.99),
               controlPoint1: CGPoint(x: 154.35, y: 68.25),
               controlPoint2: CGPoint(x: 131.13, y: 38.99))
        path.addCurveToPoint(CGPoint(x: 26.69, y: 69.49),
               controlPoint1: CGPoint(x: 50.87, y: 38.99),
               controlPoint2: CGPoint(x: 27.65, y: 68.25))
        path.addLineToPoint(CGPoint(x: 26.74, y: 69.53))
        path.addCurveToPoint(CGPoint(x: 26, y: 71.51),
               controlPoint1: CGPoint(x: 26.3, y: 70.09),
               controlPoint2: CGPoint(x: 26, y: 70.76))
        path.addCurveToPoint(CGPoint(x: 26.95, y: 73.81),
               controlPoint1: CGPoint(x: 26, y: 72.41),
               controlPoint2: CGPoint(x: 26.36, y: 73.22))
        path.addLineToPoint(CGPoint(x: 36.7, y: 83.56))
        path.addCurveToPoint(CGPoint(x: 39, y: 84.51),
               controlPoint1: CGPoint(x: 37.29, y: 84.15),
               controlPoint2: CGPoint(x: 38.1, y: 84.51))
        path.addCurveToPoint(CGPoint(x: 41.56, y: 83.16),
               controlPoint1: CGPoint(x: 40.07, y: 84.51),
               controlPoint2: CGPoint(x: 40.97, y: 83.96))
        path.addLineToPoint(CGPoint(x: 41.6, y: 83.19))
        path.addCurveToPoint(CGPoint(x: 91, y: 58.49),
               controlPoint1: CGPoint(x: 41.79, y: 82.94),
               controlPoint2: CGPoint(x: 60.58, y: 58.49))
        path.addCurveToPoint(CGPoint(x: 140.4, y: 83.19),
               controlPoint1: CGPoint(x: 121.42, y: 58.49),
               controlPoint2: CGPoint(x: 140.22, y: 82.94))
        path.addLineToPoint(CGPoint(x: 140.44, y: 83.16))
        path.addCurveToPoint(CGPoint(x: 143, y: 84.51),
               controlPoint1: CGPoint(x: 141.03, y: 83.96),
               controlPoint2: CGPoint(x: 141.93, y: 84.51))
        path.addCurveToPoint(CGPoint(x: 145.3, y: 83.56),
               controlPoint1: CGPoint(x: 143.9, y: 84.51),
               controlPoint2: CGPoint(x: 144.71, y: 84.15))
        path.addLineToPoint(CGPoint(x: 155.05, y: 73.81))
        path.addCurveToPoint(CGPoint(x: 156, y: 71.51),
               controlPoint1: CGPoint(x: 155.64, y: 73.22),
               controlPoint2: CGPoint(x: 156, y: 72.41))
        path.addCurveToPoint(CGPoint(x: 155.27, y: 69.53),
               controlPoint1: CGPoint(x: 156, y: 70.76),
               controlPoint2: CGPoint(x: 155.7, y: 70.09))
        path.addLineToPoint(CGPoint(x: 155.31, y: 69.49))
        path.closePath()
    } else {
        path.moveToPoint(CGPoint(x: 103.66, y: 122.02))
        path.addCurveToPoint(CGPoint(x: 91, y: 113.73),
               controlPoint1: CGPoint(x: 103.49, y: 121.69),
               controlPoint2: CGPoint(x: 99.41, y: 113.73))
        path.addCurveToPoint(CGPoint(x: 78.34, y: 122.02),
               controlPoint1: CGPoint(x: 82.59, y: 113.73),
               controlPoint2: CGPoint(x: 78.51, y: 121.69))
        path.addLineToPoint(CGPoint(x: 78.38, y: 122.05))
        path.addCurveToPoint(CGPoint(x: 78, y: 123.5),
               controlPoint1: CGPoint(x: 78.16, y: 122.49),
               controlPoint2: CGPoint(x: 78, y: 122.97))
        path.addCurveToPoint(CGPoint(x: 78.95, y: 125.8),
               controlPoint1: CGPoint(x: 78, y: 124.4),
               controlPoint2: CGPoint(x: 78.36, y: 125.21))
        path.addLineToPoint(CGPoint(x: 88.7, y: 135.55))
        path.addCurveToPoint(CGPoint(x: 91, y: 136.5),
               controlPoint1: CGPoint(x: 89.29, y: 136.14),
               controlPoint2: CGPoint(x: 90.1, y: 136.5))
        path.addCurveToPoint(CGPoint(x: 93.3, y: 135.55),
               controlPoint1: CGPoint(x: 91.9, y: 136.5),
               controlPoint2: CGPoint(x: 92.71, y: 136.14))
        path.addLineToPoint(CGPoint(x: 103.05, y: 125.8))
        path.addCurveToPoint(CGPoint(x: 104, y: 123.5),
               controlPoint1: CGPoint(x: 103.64, y: 125.21),
               controlPoint2: CGPoint(x: 104, y: 124.4))
        path.addCurveToPoint(CGPoint(x: 103.62, y: 122.05),
               controlPoint1: CGPoint(x: 104, y: 122.97),
               controlPoint2: CGPoint(x: 103.84, y: 122.49))
        path.addLineToPoint(CGPoint(x: 103.66, y: 122.02))
        path.closePath()
        path.moveToPoint(CGPoint(x: 91, y: 128.66))
        path.addLineToPoint(CGPoint(x: 85.46, y: 123.12))
        path.addCurveToPoint(CGPoint(x: 91, y: 120.23),
               controlPoint1: CGPoint(x: 86.61, y: 121.79),
               controlPoint2: CGPoint(x: 88.47, y: 120.23))
        path.addCurveToPoint(CGPoint(x: 96.54, y: 123.12),
               controlPoint1: CGPoint(x: 93.53, y: 120.23),
               controlPoint2: CGPoint(x: 95.39, y: 121.79))
        path.addLineToPoint(CGPoint(x: 91, y: 128.66))
        path.closePath()
        path.moveToPoint(CGPoint(x: 129.29, y: 95.45))
        path.addCurveToPoint(CGPoint(x: 91, y: 77.99),
               controlPoint1: CGPoint(x: 128.72, y: 94.74),
               controlPoint2: CGPoint(x: 115.03, y: 77.99))
        path.addCurveToPoint(CGPoint(x: 52.71, y: 95.45),
               controlPoint1: CGPoint(x: 66.96, y: 77.99),
               controlPoint2: CGPoint(x: 53.28, y: 94.74))
        path.addLineToPoint(CGPoint(x: 52.76, y: 95.49))
        path.addCurveToPoint(CGPoint(x: 52, y: 97.51),
               controlPoint1: CGPoint(x: 52.31, y: 96.05),
               controlPoint2: CGPoint(x: 52, y: 96.73))
        path.addCurveToPoint(CGPoint(x: 52.95, y: 99.8),
               controlPoint1: CGPoint(x: 52, y: 98.4),
               controlPoint2: CGPoint(x: 52.36, y: 99.22))
        path.addLineToPoint(CGPoint(x: 62.7, y: 109.55))
        path.addCurveToPoint(CGPoint(x: 65, y: 110.5),
               controlPoint1: CGPoint(x: 63.29, y: 110.14),
               controlPoint2: CGPoint(x: 64.1, y: 110.5))
        path.addCurveToPoint(CGPoint(x: 67.56, y: 109.16),
               controlPoint1: CGPoint(x: 66.07, y: 110.5),
               controlPoint2: CGPoint(x: 66.97, y: 109.96))
        path.addLineToPoint(CGPoint(x: 67.6, y: 109.19))
        path.addCurveToPoint(CGPoint(x: 91, y: 97.48),
               controlPoint1: CGPoint(x: 67.68, y: 109.07),
               controlPoint2: CGPoint(x: 76.64, y: 97.48))
        path.addCurveToPoint(CGPoint(x: 114.4, y: 109.18),
               controlPoint1: CGPoint(x: 105.36, y: 97.48),
               controlPoint2: CGPoint(x: 114.32, y: 109.07))
        path.addLineToPoint(CGPoint(x: 114.43, y: 109.16))
        path.addCurveToPoint(CGPoint(x: 117, y: 110.5),
               controlPoint1: CGPoint(x: 115.03, y: 109.95),
               controlPoint2: CGPoint(x: 115.93, y: 110.5))
        path.addCurveToPoint(CGPoint(x: 119.3, y: 109.55),
               controlPoint1: CGPoint(x: 117.9, y: 110.5),
               controlPoint2: CGPoint(x: 118.71, y: 110.14))
        path.addLineToPoint(CGPoint(x: 129.05, y: 99.8))
        path.addCurveToPoint(CGPoint(x: 130, y: 97.51),
               controlPoint1: CGPoint(x: 129.64, y: 99.22),
               controlPoint2: CGPoint(x: 130, y: 98.4))
        path.addCurveToPoint(CGPoint(x: 129.24, y: 95.49),
               controlPoint1: CGPoint(x: 130, y: 96.73),
               controlPoint2: CGPoint(x: 129.69, y: 96.05))
        path.addLineToPoint(CGPoint(x: 129.29, y: 95.45))
        path.closePath()
        path.moveToPoint(CGPoint(x: 117.15, y: 102.51))
        path.addCurveToPoint(CGPoint(x: 91, y: 90.98),
               controlPoint1: CGPoint(x: 113.04, y: 98.36),
               controlPoint2: CGPoint(x: 103.97, y: 90.98))
        path.addCurveToPoint(CGPoint(x: 64.85, y: 102.51),
               controlPoint1: CGPoint(x: 78.03, y: 90.98),
               controlPoint2: CGPoint(x: 68.96, y: 98.36))
        path.addLineToPoint(CGPoint(x: 59.76, y: 97.42))
        path.addCurveToPoint(CGPoint(x: 91, y: 84.48),
               controlPoint1: CGPoint(x: 63.97, y: 93.3),
               controlPoint2: CGPoint(x: 74.86, y: 84.48))
        path.addCurveToPoint(CGPoint(x: 122.23, y: 97.43),
               controlPoint1: CGPoint(x: 107.05, y: 84.48),
               controlPoint2: CGPoint(x: 118, y: 93.31))
        path.addLineToPoint(CGPoint(x: 117.15, y: 102.51))
        path.closePath()
        path.moveToPoint(CGPoint(x: 155.31, y: 69.49))
        path.addCurveToPoint(CGPoint(x: 91, y: 38.99),
               controlPoint1: CGPoint(x: 154.35, y: 68.25),
               controlPoint2: CGPoint(x: 131.13, y: 38.99))
        path.addCurveToPoint(CGPoint(x: 26.69, y: 69.49),
               controlPoint1: CGPoint(x: 50.87, y: 38.99),
               controlPoint2: CGPoint(x: 27.65, y: 68.25))
        path.addLineToPoint(CGPoint(x: 26.74, y: 69.53))
        path.addCurveToPoint(CGPoint(x: 26, y: 71.51),
               controlPoint1: CGPoint(x: 26.3, y: 70.09),
               controlPoint2: CGPoint(x: 26, y: 70.76))
        path.addCurveToPoint(CGPoint(x: 26.95, y: 73.81),
               controlPoint1: CGPoint(x: 26, y: 72.41),
               controlPoint2: CGPoint(x: 26.36, y: 73.22))
        path.addLineToPoint(CGPoint(x: 36.7, y: 83.56))
        path.addCurveToPoint(CGPoint(x: 39, y: 84.51),
               controlPoint1: CGPoint(x: 37.29, y: 84.15),
               controlPoint2: CGPoint(x: 38.1, y: 84.51))
        path.addCurveToPoint(CGPoint(x: 41.56, y: 83.16),
               controlPoint1: CGPoint(x: 40.07, y: 84.51),
               controlPoint2: CGPoint(x: 40.97, y: 83.96))
        path.addLineToPoint(CGPoint(x: 41.6, y: 83.19))
        path.addCurveToPoint(CGPoint(x: 91, y: 58.49),
               controlPoint1: CGPoint(x: 41.78, y: 82.94),
               controlPoint2: CGPoint(x: 60.58, y: 58.49))
        path.addCurveToPoint(CGPoint(x: 140.4, y: 83.19),
               controlPoint1: CGPoint(x: 121.42, y: 58.49),
               controlPoint2: CGPoint(x: 140.22, y: 82.94))
        path.addLineToPoint(CGPoint(x: 140.44, y: 83.16))
        path.addCurveToPoint(CGPoint(x: 143, y: 84.51),
               controlPoint1: CGPoint(x: 141.03, y: 83.96),
               controlPoint2: CGPoint(x: 141.93, y: 84.51))
        path.addCurveToPoint(CGPoint(x: 145.3, y: 83.56),
               controlPoint1: CGPoint(x: 143.9, y: 84.51),
               controlPoint2: CGPoint(x: 144.71, y: 84.15))
        path.addLineToPoint(CGPoint(x: 155.05, y: 73.81))
        path.addCurveToPoint(CGPoint(x: 156, y: 71.51),
               controlPoint1: CGPoint(x: 155.64, y: 73.22),
               controlPoint2: CGPoint(x: 156, y: 72.41))
        path.addCurveToPoint(CGPoint(x: 155.26, y: 69.53),
               controlPoint1: CGPoint(x: 156, y: 70.76),
               controlPoint2: CGPoint(x: 155.7, y: 70.09))
        path.addLineToPoint(CGPoint(x: 155.31, y: 69.49))
        path.closePath()
        path.moveToPoint(CGPoint(x: 143.22, y: 76.44))
        path.addCurveToPoint(CGPoint(x: 91, y: 51.99),
               controlPoint1: CGPoint(x: 136.94, y: 69.43),
               controlPoint2: CGPoint(x: 118.55, y: 51.99))
        path.addCurveToPoint(CGPoint(x: 38.78, y: 76.44),
               controlPoint1: CGPoint(x: 63.45, y: 51.99),
               controlPoint2: CGPoint(x: 45.06, y: 69.43))
        path.addLineToPoint(CGPoint(x: 33.69, y: 71.35))
        path.addCurveToPoint(CGPoint(x: 91, y: 45.49),
               controlPoint1: CGPoint(x: 39.68, y: 64.86),
               controlPoint2: CGPoint(x: 60.13, y: 45.49))
        path.addCurveToPoint(CGPoint(x: 148.31, y: 71.35),
               controlPoint1: CGPoint(x: 121.87, y: 45.49),
               controlPoint2: CGPoint(x: 142.32, y: 64.86))
        path.addLineToPoint(CGPoint(x: 143.22, y: 76.44))
        path.closePath()
        path.moveToPoint(CGPoint(x: 181.46, y: 43.82))
        path.addLineToPoint(CGPoint(x: 181.52, y: 43.79))
        path.addCurveToPoint(CGPoint(x: 91, y: 0),
               controlPoint1: CGPoint(x: 180.42, y: 42),
               controlPoint2: CGPoint(x: 153.85, y: 0))
        path.addCurveToPoint(CGPoint(x: 0.48, y: 43.79),
               controlPoint1: CGPoint(x: 28.15, y: 0),
               controlPoint2: CGPoint(x: 1.58, y: 42))
        path.addLineToPoint(CGPoint(x: 0.54, y: 43.82))
        path.addCurveToPoint(CGPoint(x: 0, y: 45.52),
               controlPoint1: CGPoint(x: 0.23, y: 44.33),
               controlPoint2: CGPoint(x: 0, y: 44.88))
        path.addCurveToPoint(CGPoint(x: 0.95, y: 47.81),
               controlPoint1: CGPoint(x: 0, y: 46.41),
               controlPoint2: CGPoint(x: 0.36, y: 47.23))
        path.addLineToPoint(CGPoint(x: 10.7, y: 57.56))
        path.addCurveToPoint(CGPoint(x: 13, y: 58.51),
               controlPoint1: CGPoint(x: 11.29, y: 58.15),
               controlPoint2: CGPoint(x: 12.1, y: 58.51))
        path.addCurveToPoint(CGPoint(x: 15.67, y: 57.02),
               controlPoint1: CGPoint(x: 14.14, y: 58.51),
               controlPoint2: CGPoint(x: 15.09, y: 57.9))
        path.addLineToPoint(CGPoint(x: 15.7, y: 57.04))
        path.addCurveToPoint(CGPoint(x: 91, y: 19.5),
               controlPoint1: CGPoint(x: 15.95, y: 56.67),
               controlPoint2: CGPoint(x: 41.31, y: 19.5))
        path.addCurveToPoint(CGPoint(x: 166.3, y: 57.05),
               controlPoint1: CGPoint(x: 140.55, y: 19.5),
               controlPoint2: CGPoint(x: 166.05, y: 56.67))
        path.addLineToPoint(CGPoint(x: 166.34, y: 57.02))
        path.addCurveToPoint(CGPoint(x: 169, y: 58.51),
               controlPoint1: CGPoint(x: 166.92, y: 57.9),
               controlPoint2: CGPoint(x: 167.87, y: 58.51))
        path.addCurveToPoint(CGPoint(x: 171.3, y: 57.56),
               controlPoint1: CGPoint(x: 169.9, y: 58.51),
               controlPoint2: CGPoint(x: 170.71, y: 58.15))
        path.addLineToPoint(CGPoint(x: 181.05, y: 47.81))
        path.addCurveToPoint(CGPoint(x: 182, y: 45.52),
               controlPoint1: CGPoint(x: 181.64, y: 47.23),
               controlPoint2: CGPoint(x: 182, y: 46.41))
        path.addCurveToPoint(CGPoint(x: 181.46, y: 43.82),
               controlPoint1: CGPoint(x: 182, y: 44.88),
               controlPoint2: CGPoint(x: 181.77, y: 44.33))
        path.closePath()
        path.moveToPoint(CGPoint(x: 169.37, y: 50.3))
        path.addCurveToPoint(CGPoint(x: 91, y: 13),
               controlPoint1: CGPoint(x: 161.79, y: 40.74),
               controlPoint2: CGPoint(x: 135.93, y: 13))
        path.addCurveToPoint(CGPoint(x: 12.63, y: 50.3),
               controlPoint1: CGPoint(x: 46.07, y: 13),
               controlPoint2: CGPoint(x: 20.21, y: 40.74))
        path.addLineToPoint(CGPoint(x: 7.46, y: 45.13))
        path.addCurveToPoint(CGPoint(x: 26.15, y: 26.8),
               controlPoint1: CGPoint(x: 10.04, y: 41.63),
               controlPoint2: CGPoint(x: 16.15, y: 34.18))
        path.addCurveToPoint(CGPoint(x: 91, y: 6.5),
               controlPoint1: CGPoint(x: 38.7, y: 17.54),
               controlPoint2: CGPoint(x: 60.13, y: 6.5))
        path.addCurveToPoint(CGPoint(x: 155.85, y: 26.8),
               controlPoint1: CGPoint(x: 121.87, y: 6.5),
               controlPoint2: CGPoint(x: 143.3, y: 17.54))
        path.addCurveToPoint(CGPoint(x: 174.54, y: 45.13),
               controlPoint1: CGPoint(x: 165.85, y: 34.18),
               controlPoint2: CGPoint(x: 171.96, y: 41.63))
        path.addLineToPoint(CGPoint(x: 169.37, y: 50.3))
        path.closePath()
    }

    color.setFill()
    path.fill()

  }

  /**
  drawWifiStatus:connected:frame:

  - parameter #color: UIColor
  - parameter connected: Bool
  - parameter frame: CGRect
  */
  public class func drawWifiStatus(color color: UIColor, connected: Bool, frame: CGRect) {
    let context = UIGraphicsGetCurrentContext()

    let squaredSize = CGSize(width: min(frame.width, frame.height), height:  min(frame.width, frame.height))
    let squaredFrame = CGRect(x: frame.origin.x + (frame.width - squaredSize.width) / 2.0,
                              y: frame.origin.y + (frame.height - squaredSize.height) / 2.0,
                              width: squaredSize.width,
                              height: squaredSize.height)
    let wifiFrame = CGRect(x: squaredFrame.origin.x,
                           y: squaredFrame.origin.y + (squaredFrame.height - squaredFrame.width * 4.25 / 5.69) / 2.0,
                           width: squaredFrame.size.width,
                           height: squaredFrame.size.width * 4.25 / 5.69)

    let symbolRect = CGRect(x: wifiFrame.minX,
                            y: wifiFrame.minY,
                            width: floor(wifiFrame.width + 0.5),
                            height: floor(wifiFrame.height + 0.05) - 1.55)
    CGContextSaveGState(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)
    CGContextScaleCTM(context, symbolRect.size.width / 182, symbolRect.size.height / 136)

    drawWifiIcon(color: color, connected: connected)
    CGContextRestoreGState(context)
  }

}
