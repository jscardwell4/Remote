//
//  DrawingKit.swift
//  Remote
//
//  Created by Moondeer on 4/28/15.
//  Copyright (c) 2015 Moondeer Studios. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//


import UIKit
import MoonKit
import DataModel

private let white = UIColor.whiteColor()
private let white0_5 = white.colorWithAlphaComponent(0.5)
private let white0_0 = UIColor(red: 1, green: 1, blue: 1, alpha: 0)
private let lightGray = UIColor.lightGrayColor()
private let black = UIColor.blackColor()
private let offset1_neg1 = CGSize(width: 0.1, height: -0.1)
private let offset1_6 = CGSize(width: 0.1, height: 0.6)
private let offset1_neg6 = CGSize(width: 0.1, height: -0.6)

public final class DrawingKit {

  public struct Attributes {
    public var color: UIColor?
    public var strokeColor: UIColor?
    public var fillColor: UIColor?
    public var rect: CGRect
    public var lineWidth: CGFloat = 0
    public var corners = DrawingKit.defaultCorners
    public var radii = DrawingKit.defaultRadii
    public var shadow: NSShadow?
    public var blendMode: CGBlendMode = kCGBlendModeNormal
    public var stroke = false
    public var fill = true

    public func attributesWithShadow(shadow: NSShadow?) -> Attributes {
      var attrs = self
      attrs.shadow = shadow
      return attrs
    }

    public init(rect: CGRect) {
      self.rect = rect
    }
  }

  public typealias Shape = RemoteElement.Shape

  public static let defaultButtonColor = UIColor(r: 41, g: 40, b: 39, a: 255)!
  public static let defaultContentColor = UIColor(r: 50, g: 143, b: 239, a: 255)!
  public static let defaultRadii = CGSize(width: 10, height: 20)
  public static let defaultCorners: UIRectCorner = .AllCorners

  public static let verticalGloss: CGGradient = CGGradientCreateWithColors(
    CGColorSpaceCreateDeviceRGB(),
    [white0_0.CGColor, white0_0.blendedColorWithFraction(0.5, ofColor: white).CGColor, white.CGColor],
    [0, 0.4, 1]
  )

  public static let innerShadow:     NSShadow = NSShadow(color: white,     offset: offset1_neg1, blurRadius: 2)
  public static let outerShadow:     NSShadow = NSShadow(color: black,     offset: offset1_neg1, blurRadius: 2)
  public static let strokeShadow:    NSShadow = NSShadow(color: lightGray, offset: offset1_neg1, blurRadius: 1)
  public static let insettingShadow: NSShadow = NSShadow(color: white0_5,  offset: offset1_6,    blurRadius: 0)
  public static let plasticShadow:   NSShadow = NSShadow(color: white,     offset: offset1_neg6, blurRadius: 1)
  public static let cutoutShadow:    NSShadow = NSShadow(color: black,     offset: offset1_neg1, blurRadius: 1)
  public static let glowingShadow:   NSShadow = NSShadow(color: white,     offset: offset1_neg1, blurRadius: 5)

  /**
  roundedRectanglePathInRect:radius:

  :param: rect CGRect
  :param: radius CGFloat

  :returns: UIBezierPath
  */
  public class func roundedRectanglePathInRect(rect: CGRect, radius: CGFloat) -> UIBezierPath {
    return UIBezierPath(roundedRect: rect, cornerRadius: radius)
  }

  /**
  roundedRectanglePathInRect:corners:radii:

  :param: rect CGRect
  :param: radius CGFloat

  :returns: UIBezierPath
  */
  public class func roundedRectanglePathInRect(rect: CGRect,
                             byRoundingCorners corners: UIRectCorner,
                                     withRadii radii: CGSize) -> UIBezierPath
  {
    return UIBezierPath(roundedRect: rect, byRoundingCorners: corners, cornerRadii: radii)
  }

  /**
  rectanglePathInRect:

  :param: rect CGRect

  :returns: UIBezierPath
  */
  public class func rectanglePathInRect(rect: CGRect) -> UIBezierPath { return UIBezierPath(rect: rect) }

  /**
  ovalPathInRect:

  :param: rect CGRect

  :returns: UIBezierPath
  */
  public class func ovalPathInRect(rect: CGRect) -> UIBezierPath { return UIBezierPath(ovalInRect: rect) }

  /**
  diamondBasePathInRect:

  :param: rect CGRect

  :returns: UIBezierPath
  */
  public class func diamondPathInRect(rect: CGRect) -> UIBezierPath {
    var path = UIBezierPath()
    path.moveToPoint(CGPoint(x: rect.minX, y: rect.minY + 0.5 * rect.height))
    path.addLineToPoint(CGPoint(x: rect.minX + 0.5 * rect.width, y: rect.minY))
    path.addLineToPoint(CGPoint(x: rect.minX + rect.width, y: rect.minY + 0.5 * rect.height))
    path.addLineToPoint(CGPoint(x: rect.minX + 0.5 * rect.width, y: rect.minY + rect.height))
    path.addLineToPoint(CGPoint(x: rect.minX, y: rect.minY + 0.5 * rect.height))
    path.closePath()
    return path
  }

  /**
  triangleBasePathInRect:

  :param: rect CGRect

  :returns: UIBezierPath
  */
  public class func trianglePathInRect(rect: CGRect) -> UIBezierPath {
    var path = UIBezierPath()
    path.moveToPoint(CGPoint(x: rect.minX + 0.50 * rect.width, y: rect.minY))
    path.addLineToPoint(CGPoint(x: rect.minX + 0.75 * rect.width, y: rect.minY + 0.5 * rect.height))
    path.addLineToPoint(CGPoint(x: rect.minX + rect.width, y: rect.minY + rect.height))
    path.addLineToPoint(CGPoint(x: rect.minX + 0.50 * rect.width, y: rect.minY + rect.height))
    path.addLineToPoint(CGPoint(x: rect.minX, y: rect.minY + rect.height))
    path.addLineToPoint(CGPoint(x: rect.minX + 0.25 * rect.width, y: rect.minY + 0.5 * rect.height))
    path.addLineToPoint(CGPoint(x: rect.minX + 0.5 * rect.width, y: rect.minY))
    path.closePath()
    return path
  }

  /**
  pathForShape:inRect:byRoundingCorners:withRadii:

  :param: shape Shape
  :param: rect CGRect
  :param: corners UIRectCorner = defaultCorners
  :param: radii CGSize = defaultRadii

  :returns: UIBezierPath
  */
  public class func pathForShape(shape: Shape, withAttributes attrs: Attributes) -> UIBezierPath {
    let path: UIBezierPath
    switch shape {
      case .Diamond:          path = diamondPathInRect(attrs.rect)
      case .Oval:             path = ovalPathInRect(attrs.rect)
      case .Triangle:         path = trianglePathInRect(attrs.rect)
      case .Rectangle:        path = rectanglePathInRect(attrs.rect)
      case .RoundedRectangle: path = roundedRectanglePathInRect(attrs.rect, byRoundingCorners: attrs.corners, withRadii: attrs.radii)
      case .Undefined:        path = UIBezierPath()
    }
    path.lineWidth = attrs.lineWidth
    return path
  }

  /**
  drawShape:var:

  :param: shape Shape
  :param: attributes Attributes
  */
  public class func drawShape(shape: Shape, var withAttributes attributes: Attributes) {

    let context = UIGraphicsGetCurrentContext()

    CGContextSaveGState(context)
    CGContextSetBlendMode(context, attributes.blendMode)

    UIRectClip(attributes.rect)
    CGContextTranslateCTM(context, attributes.rect.origin.x, attributes.rect.origin.y)

    attributes.shadow?.setShadow()
    attributes.rect = CGRect(size: attributes.rect.size).rectByInsetting(dx: 1, dy: 1)

    let path = pathForShape(shape, withAttributes: attributes)

    if attributes.fill, let c = attributes.fillColor ?? attributes.color { c.setFill(); path.fill() }
    if attributes.stroke, let c = attributes.strokeColor ?? attributes.color { c.setStroke(); path.stroke() }

    CGContextRestoreGState(context)

  }


  /**
  drawButtonBaseWithShape:inRect:withColor:byRoundingCorners:withRadii:

  :param: shape Shape
  :param: rect CGRect
  :param: color UIColor = defaultButtonColor
  :param: corners UIRectCorner = defaultCorners
  :param: radii CGSize = defaultRadii
  */
  public class func drawButtonBaseWithShape(shape: Shape, withAttributes attributes: Attributes)
  {

    let context = UIGraphicsGetCurrentContext()

    // Draw the base with an outer shadow
    var attrs = attributes
    attrs.shadow = outerShadow
    drawShape(shape, withAttributes: attrs)

    CGContextBeginTransparencyLayer(context, nil)                                           // transparency: •

    let opaqueInnerShadow = innerShadow.shadowWithAlpha(1.0)
    attrs.shadow = opaqueInnerShadow
    attrs.blendMode = kCGBlendModeSourceOut
    attrs.color = opaqueInnerShadow.color

    drawShape(shape, withAttributes: attrs)

    CGContextEndTransparencyLayer(context)                                                  // transparency:

/**     var strokeAttrs = attributes
    strokeAttrs.shadow = strokeShadow
    strokeAttrs.stroke = true
    strokeAttrs.fill = false
    drawShape(shape, withAttributes: strokeAttrs)
 */
    var overlayAttrs = attributes
    overlayAttrs.rect = attributes.rect.rectByInsetting(dx: 6, dy: 6)
    let overlayPath = pathForShape(shape, withAttributes: overlayAttrs)

    CGContextSaveGState(context)                                                           // context: •
    overlayPath.addClip() // helps to cut down on edge artifacts

    // Draw overlay
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)

    let bounds = overlayPath.bounds
    let p1 = CGPoint(x: bounds.midX, y: bounds.midY + 0.5 * bounds.height)
    let p2 = CGPoint(x: bounds.midX, y: bounds.midY)
    let options = UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation)
    CGContextDrawLinearGradient(context, verticalGloss, p1, p2, options)

    CGContextRestoreGState(context)                                                         // context:

  }

  /**
  drawButton:color:contentColor:image:corners:radii:text:fontAttributes:applyGloss:shape:highlighted:

  :param: #rect CGRect
  :param: color UIColor = defaultButtonColor
  :param: contentColor UIColor = defaultContentColor
  :param: image UIImage? = nil
  :param: corners UIRectCorner = defaultCorners
  :param: radii CGSize = defaultRadii
  :param: text String? = nil
  :param: fontAttributes [String AnyObject]? = nil
  :param: applyGloss Bool = true
  :param: shape Shape
  :param: highlighted Bool = false
  */
  public class func drawButtonWithShape(shape: Shape,
                                 inRect rect: CGRect,
                              withColor color: UIColor = defaultButtonColor,
                       withContentColor ccolor: UIColor = defaultContentColor,
                      byRoundingCorners corners: UIRectCorner = defaultCorners,
                              withRadii radii: CGSize = defaultRadii,
                                  image: UIImage? = nil,
                                   text: String? = nil,
                    usingFontAttributes fontAttributes: [String:AnyObject]? = nil,
                             applyGloss: Bool = true,
                               highlighted: Bool = false)
  {
    let context = UIGraphicsGetCurrentContext()

    // TODO: Check points against path for the sides of min/max font height, i.e. shrink more for diamond/triangle shapes
    let baseRect = rect.rectByInsetting(dx: 4, dy: 4).integerRect
    let bleedRect = baseRect.rectByInsetting(dx: 4, dy: 4)

    let contentOuterShadow: NSShadow? = highlighted ? NSShadow(color: ccolor, offset: CGSize.zeroSize, blurRadius: 5) : nil


    CGContextSaveGState(context)                                                            // context stack: •
    UIRectClip(bleedRect)
    CGContextTranslateCTM(context, bleedRect.origin.x, bleedRect.origin.y)
    var attrs = Attributes(rect: CGRect(size: bleedRect.size))
    attrs.color = ccolor
    attrs.corners = corners
    attrs.radii = radii
    drawShape(shape, withAttributes: attrs)
    CGContextRestoreGState(context)                                                         // context:

    CGContextSaveGState(context)                                                            // context: •
    CGContextBeginTransparencyLayer(context, nil)                                           // transparency: •
    CGContextSaveGState(context)                                                            // context: ••
    contentOuterShadow?.setShadow()
    CGContextBeginTransparencyLayer(context, nil)                                           // transparency: ••

    CGContextSaveGState(context)                                                            // context: •••
    UIRectClip(baseRect)
    CGContextTranslateCTM(context, baseRect.origin.x, baseRect.origin.y)

    attrs.rect = CGRect(size: baseRect.size)
    attrs.color = color
    attrs.strokeColor = ccolor
    attrs.lineWidth = 1.0

    drawButtonBaseWithShape(shape, withAttributes: attrs)
    CGContextRestoreGState(context)                                                         // context: ••


    CGContextEndTransparencyLayer(context)                                                  // transparency: •
    CGContextRestoreGState(context)                                                         // context: •

    CGContextSaveGState(context)                                                            // context: ••
    CGContextSetBlendMode(context, kCGBlendModeDestinationOut)
    CGContextBeginTransparencyLayer(context, nil)                                           // transparency: ••


    if let image = image {

      let actualImageSize = image.size
      let boundingSize = baseRect.size
      let imageSize = boundingSize.contains(actualImageSize)
                        ? actualImageSize
                        : actualImageSize.aspectMappedToSize(boundingSize, binding: true)
      let imageOffset = CGPoint(x: baseRect.midX - imageSize.width * 0.5, y: baseRect.midY - imageSize.height * 0.5)

      //// Icon Group
      CGContextSaveGState(context)                                                          // context: •••
      CGContextTranslateCTM(context, imageOffset.x, imageOffset.y)

      innerShadow.setShadow()
      CGContextSetAlpha(context, 0.9)
      CGContextBeginTransparencyLayer(context, nil)                                         // transparency: •••


      //// Icon Path Drawing
      CGContextSaveGState(context)                                                          // context: ••••
      contentOuterShadow?.setShadow()
      CGContextBeginTransparencyLayer(context, nil)                                         // transparency: ••••
      CGContextSaveGState(context)                                                          // context: •••••
      let imageRect = CGRect(size: imageSize)
      CGContextClipToRect(context, imageRect)
      image.drawInRect(imageRect)
      CGContextRestoreGState(context)                                                       // context: ••••
      CGContextEndTransparencyLayer(context)                                                // transparency: •••
      CGContextRestoreGState(context)                                                       // context: •••



      CGContextEndTransparencyLayer(context)                                                // transparency: ••

      CGContextRestoreGState(context)                                                       // context: ••
    }


    if let text: NSString = text {
      let appliedFontSize: CGFloat = min(baseRect.size.width / CGFloat(text.length), baseRect.size.height)

      CGContextSaveGState(context)                                                          // context: •••
      contentOuterShadow?.setShadow()

      let attributes: [String:AnyObject]

      if fontAttributes != nil {

        var attrs = fontAttributes!
        if let f = attrs[NSFontAttributeName] as? UIFont { attrs[NSFontAttributeName] = f.fontWithSize(appliedFontSize) }
        attributes = attrs

      } else {

        let paragraphStyle = NSParagraphStyle.paragraphStyleWithAttributes(alignment: .Center)
        let font = UIFont(name: "HelveticaNeue-Bold", size: appliedFontSize)!
        let fg = UIColor.blackColor()
        attributes = [ NSFontAttributeName           : font,
                       NSForegroundColorAttributeName: fg,
                       NSParagraphStyleAttributeName : paragraphStyle ]

      }

      let textHeight: CGFloat = text.boundingRectWithSize(CGSize(width: bleedRect.width, height: CGFloat.infinity),
                                                 options: NSStringDrawingOptions.UsesLineFragmentOrigin,
                                              attributes: attributes,
                                                 context: nil).size.height
      CGContextSaveGState(context)                                                          // context: ••••
      CGContextClipToRect(context, bleedRect);
      let textRect = CGRect(x: bleedRect.minX,
                            y: bleedRect.minY + (bleedRect.height - textHeight) * 0.5,
                            width: bleedRect.width,
                            height: textHeight)
      text.drawInRect(textRect, withAttributes: attributes)
      CGContextRestoreGState(context)                                                       // context: •••
      CGContextRestoreGState(context)                                                       // context: ••

    }


    CGContextEndTransparencyLayer(context)                                                  // transparency: •
    CGContextRestoreGState(context)                                                         // context: •


    CGContextEndTransparencyLayer(context)                                                  // transparency:
    CGContextRestoreGState(context)                                                         // context:


    if (applyGloss) {

      CGContextBeginTransparencyLayer(context, nil)                                         // transparency: •

      var glossAttrs = Attributes(rect: baseRect)
      glossAttrs.corners = corners
      glossAttrs.radii = radii
      glossAttrs.blendMode = kCGBlendModeSourceAtop

      drawGlossWithShape(shape, withAttributes: glossAttrs)

      CGContextEndTransparencyLayer(context)                                                // transparency:
    }

  }

  /**
  drawGlossWithShape:inRect:byRoundingCorners:withRadii:

  :param: shape Shape
  :param: rect CGRect
  :param: corners UIRectCorner = defaultCorners
  :param: radii CGSize = defaultRadii
  */
  public class func drawGlossWithShape(shape: Shape, withAttributes attributes: Attributes)
  {

    let context = UIGraphicsGetCurrentContext()


    let path = pathForShape(shape, withAttributes: attributes)

    CGContextSaveGState(context)
    CGContextSetBlendMode(context, attributes.blendMode)
    CGContextSetAlpha(context, 0.1)
    path.addClip()

    let bounds = path.bounds
    let p1 = CGPoint(x: bounds.midX, y: bounds.midY + 0.5 * bounds.height)
    let p2 = CGPoint(x: bounds.midX, y: bounds.midY)
    let options = UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation)
    CGContextDrawLinearGradient(context, verticalGloss, p1, p2, options)

    CGContextRestoreGState(context)
  }

  /**
  drawBatteryStatus:hasPower:chargeLevel:frame:

  :param: #color UIColor
  :param: hasPower Bool
  :param: chargeLevel CGFloat
  :param: frame CGRect
  */
  public class func drawBatteryStatus(#color: UIColor, hasPower: Bool, chargeLevel: CGFloat, frame: CGRect) {
    let context = UIGraphicsGetCurrentContext()
    let squaredSize = CGSize(width: min(frame.width, frame.height),
                                            height: min(frame.width, frame.height))
    let squaredFrame = CGRect(x: frame.origin.x + (frame.width - squaredSize.width) / 2.0,
                                        y: frame.origin.y + (frame.size.height - squaredSize.height) / 2.0,
                                        width: squaredSize.width,
                                        height: squaredSize.height)
    let batteryFrame = CGRect(x: squaredFrame.origin.x,
                              y: squaredFrame.origin.y + (squaredFrame.height - squaredFrame.width * 4 / 7.0) / 2.0,
                              width: squaredFrame.width,
                              height: squaredFrame.width * 4 / 7.0)
    let symbolRect = CGRect(x: batteryFrame.minX,
                            y:  batteryFrame.minY,
                            width:  floor(batteryFrame.width + 0.5),
                            height: floor(batteryFrame.height + 0.21) + 0.29)
    CGContextSaveGState(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)
    CGContextScaleCTM(context, symbolRect.size.width / 224, symbolRect.size.height / 128)

    DrawingKit.drawBatteryIcon(color: color, hasPower: hasPower, chargeLevel: chargeLevel)
    CGContextRestoreGState(context)
  }

  /**
  drawBatteryIcon:hasPower:chargeLevel:

  :param: #color UIColor
  :param: hasPower Bool
  :param: chargeLevel CGFloat
  */
  public class func drawBatteryIcon(#color: UIColor, hasPower: Bool, chargeLevel: CGFloat) {

    // Draw battery outline
    var outlinePath = UIBezierPath()
    outlinePath.moveToPoint(CGPoint(x: 208, y: 44))
    outlinePath.addLineToPoint(CGPoint(x: 208, y: 84))
    outlinePath.addCurveToPoint(CGPoint(x: 216, y: 76),

                       controlPoint1: CGPoint(x: 212.42, y: 84),

                 controlPoint2: CGPoint(x: 216, y: 80.42))
    outlinePath.addLineToPoint(CGPoint(x: 216, y: 52))
    outlinePath.addCurveToPoint(CGPoint(x: 208, y: 44),

                       controlPoint1: CGPoint(x: 216, y: 47.58),

                 controlPoint2: CGPoint(x: 212.42, y: 44))
    outlinePath.closePath()
    outlinePath.moveToPoint(CGPoint(x: 144, y: 16))
    outlinePath.addLineToPoint(CGPoint(x: 16.03, y: 16))
    outlinePath.addLineToPoint(CGPoint(x: 16.03, y: 112))
    outlinePath.addCurveToPoint(CGPoint(x: 16, y: 16),

                       controlPoint1: CGPoint(x: 16, y: 112),

                 controlPoint2: CGPoint(x: 16, y: 16))
    outlinePath.addLineToPoint(CGPoint(x: 144, y: 16))
    outlinePath.closePath()
    outlinePath.moveToPoint(CGPoint(x: 192, y: 8))
    outlinePath.addLineToPoint(CGPoint(x: 16, y: 8))
    outlinePath.addCurveToPoint(CGPoint(x: 8, y: 16),

                       controlPoint1: CGPoint(x: 11.58, y: 8),

                 controlPoint2: CGPoint(x: 8, y: 11.58))
    outlinePath.addLineToPoint(CGPoint(x: 8, y: 112))
    outlinePath.addCurveToPoint(CGPoint(x: 16, y: 120),

                       controlPoint1: CGPoint(x: 8, y: 116.42),

                 controlPoint2: CGPoint(x: 11.58, y: 120))
    outlinePath.addLineToPoint(CGPoint(x: 192, y: 120))
    outlinePath.addCurveToPoint(CGPoint(x: 200, y: 112),

                       controlPoint1: CGPoint(x: 196.42, y: 120),

                 controlPoint2: CGPoint(x: 200, y: 116.42))
    outlinePath.addLineToPoint(CGPoint(x: 200, y: 16))
    outlinePath.addCurveToPoint(CGPoint(x: 192, y: 8),

                       controlPoint1: CGPoint(x: 200, y: 11.58),

                 controlPoint2: CGPoint(x: 196.42, y: 8))
    outlinePath.closePath()
    outlinePath.moveToPoint(CGPoint(x: 208, y: 16))
    outlinePath.addLineToPoint(CGPoint(x: 208, y: 36))
    outlinePath.addLineToPoint(CGPoint(x: 216, y: 36))
    outlinePath.addCurveToPoint(CGPoint(x: 224, y: 44),

                       controlPoint1: CGPoint(x: 220.42, y: 36),

                 controlPoint2: CGPoint(x: 224, y: 39.58))
    outlinePath.addLineToPoint(CGPoint(x: 224, y: 84))
    outlinePath.addCurveToPoint(CGPoint(x: 216, y: 92),

                       controlPoint1: CGPoint(x: 224, y: 88.42),

                 controlPoint2: CGPoint(x: 220.42, y: 92))
    outlinePath.addLineToPoint(CGPoint(x: 208, y: 92))
    outlinePath.addLineToPoint(CGPoint(x: 208, y: 112))
    outlinePath.addCurveToPoint(CGPoint(x: 192, y: 128),

                       controlPoint1: CGPoint(x: 208, y: 120.84),

                 controlPoint2: CGPoint(x: 200.84, y: 128))
    outlinePath.addLineToPoint(CGPoint(x: 16, y: 128))
    outlinePath.addCurveToPoint(CGPoint(x: 0, y: 112),

                       controlPoint1: CGPoint(x: 7.16, y: 128),

                 controlPoint2: CGPoint(x: 0, y: 120.84))
    outlinePath.addLineToPoint(CGPoint(x: 0, y: 16))
    outlinePath.addCurveToPoint(CGPoint(x: 10.1, y: 1.12),

                       controlPoint1: CGPoint(x: 0, y: 9.25),

                 controlPoint2: CGPoint(x: 4.18, y: 3.47))
    outlinePath.addCurveToPoint(CGPoint(x: 16, y: 0),

                       controlPoint1: CGPoint(x: 11.93, y: 0.4),

                 controlPoint2: CGPoint(x: 13.92, y: 0))
    outlinePath.addLineToPoint(CGPoint(x: 192, y: 0))
    outlinePath.addCurveToPoint(CGPoint(x: 208, y: 16),

                       controlPoint1: CGPoint(x: 200.84, y: 0),

                 controlPoint2: CGPoint(x: 208, y: 7.16))
    outlinePath.closePath()
    color.setFill()
    outlinePath.fill()


    // Draw charge fill
    let chargeMaxX: CGFloat = 16 + 175 * chargeLevel
    var chargePath = UIBezierPath()
    chargePath.moveToPoint(CGPoint(x: 16, y: 112))
    chargePath.addLineToPoint(CGPoint(x: chargeMaxX, y: 112))
    chargePath.addLineToPoint(CGPoint(x: chargeMaxX, y: 16))
    chargePath.addLineToPoint(CGPoint(x: 16, y: 16))
    chargePath.addLineToPoint(CGPoint(x: 16, y: 112))
    chargePath.closePath()
    color.setFill()
    chargePath.fill()

    // Draw lightning bolt or plug if appropriate
    let batteryIconColor = color.colorWithHighlight(0.3)

    if hasPower && chargeLevel < 1 {
        var lightningBoltPath = UIBezierPath()
        lightningBoltPath.moveToPoint(CGPoint(x: 130.91, y: 51.57))
        lightningBoltPath.addLineToPoint(CGPoint(x: 109.6, y: 51.57))
        lightningBoltPath.addLineToPoint(CGPoint(x: 120.26, y: 14.27))
        lightningBoltPath.addLineToPoint(CGPoint(x: 95.39, y: 14.27))
        lightningBoltPath.addLineToPoint(CGPoint(x: 81.18, y: 71.1))
        lightningBoltPath.addLineToPoint(CGPoint(x: 106.05, y: 71.1))
        lightningBoltPath.addLineToPoint(CGPoint(x: 100.72, y: 113.73))
        lightningBoltPath.addLineToPoint(CGPoint(x: 130.91, y: 51.57))
        lightningBoltPath.closePath()
        lightningBoltPath.usesEvenOddFillRule = true;

        batteryIconColor.setFill()
        lightningBoltPath.fill()
    }


    else if hasPower && chargeLevel == 1 {
        var plugPath = UIBezierPath()
        plugPath.moveToPoint(CGPoint(x: 161.55, y: 56))
        plugPath.addLineToPoint(CGPoint(x: 161.55, y: 48))
        plugPath.addLineToPoint(CGPoint(x: 141.55, y: 48))
        plugPath.addLineToPoint(CGPoint(x: 141.55, y: 36))
        plugPath.addLineToPoint(CGPoint(x: 107.55, y: 36))
        plugPath.addCurveToPoint(CGPoint(x: 104.35, y: 37.6),

                           controlPoint1: CGPoint(x: 106.29, y: 36),

                     controlPoint2: CGPoint(x: 105.1, y: 36.59))
        plugPath.addLineToPoint(CGPoint(x: 93.55, y: 52))
        plugPath.addLineToPoint(CGPoint(x: 53.55, y: 52))
        plugPath.addCurveToPoint(CGPoint(x: 49.55, y: 56),

                           controlPoint1: CGPoint(x: 51.34, y: 52),

                     controlPoint2: CGPoint(x: 49.55, y: 53.79))
        plugPath.addLineToPoint(CGPoint(x: 49.55, y: 72))
        plugPath.addCurveToPoint(CGPoint(x: 53.55, y: 76),

                           controlPoint1: CGPoint(x: 49.55, y: 74.21),

                     controlPoint2: CGPoint(x: 51.34, y: 76))
        plugPath.addLineToPoint(CGPoint(x: 93.55, y: 76))
        plugPath.addLineToPoint(CGPoint(x: 104.35, y: 90.4))
        plugPath.addCurveToPoint(CGPoint(x: 107.55, y: 92),

                           controlPoint1: CGPoint(x: 105.1, y: 91.41),

                     controlPoint2: CGPoint(x: 106.29, y: 92))
        plugPath.addLineToPoint(CGPoint(x: 141.55, y: 92))
        plugPath.addLineToPoint(CGPoint(x: 141.55, y: 80))
        plugPath.addLineToPoint(CGPoint(x: 161.55, y: 80))
        plugPath.addLineToPoint(CGPoint(x: 161.55, y: 72))
        plugPath.addLineToPoint(CGPoint(x: 141.55, y: 72))
        plugPath.addLineToPoint(CGPoint(x: 141.55, y: 56))
        plugPath.addLineToPoint(CGPoint(x: 161.55, y: 56))
        plugPath.closePath()
        batteryIconColor.setFill()
        plugPath.fill()
    }
  }

  /**
  drawWifiIcon:connected:

  :param: #color UIColor
  :param: connected Bool
  */
  public class func drawWifiIcon(#color: UIColor, connected: Bool) {

    var path = UIBezierPath()

    if (connected) {
        path.moveToPoint(CGPoint(x: 181.46, y: 43.82))
        path.addLineToPoint(CGPoint(x: 181.52, y: 43.79))
        path.addCurveToPoint(CGPoint(x: 91, y: 0),
               controlPoint1: CGPoint(x: 180.42, y: 42),
               controlPoint2: CGPoint(x: 153.85, y: 0))
        path.addCurveToPoint(CGPoint(x: 0.48, y: 43.79),
               controlPoint1: CGPoint(x: 28.15, y: 0),
               controlPoint2: CGPoint(x: 1.58, y: 42))
        path.addLineToPoint(CGPoint(x: 0.54, y: 43.82))
        path.addCurveToPoint(CGPoint(x: 0, y: 45.52),
               controlPoint1: CGPoint(x: 0.23, y: 44.33),
               controlPoint2: CGPoint(x: 0, y: 44.88))
        path.addCurveToPoint(CGPoint(x: 0.95, y: 47.81),
               controlPoint1: CGPoint(x: 0, y: 46.41),
               controlPoint2: CGPoint(x: 0.36, y: 47.23))
        path.addLineToPoint(CGPoint(x: 10.7, y: 57.56))
        path.addCurveToPoint(CGPoint(x: 13, y: 58.51),
               controlPoint1: CGPoint(x: 11.29, y: 58.15),
               controlPoint2: CGPoint(x: 12.1, y: 58.51))
        path.addCurveToPoint(CGPoint(x: 15.67, y: 57.02),
               controlPoint1: CGPoint(x: 14.14, y: 58.51),
               controlPoint2: CGPoint(x: 15.09, y: 57.9))
        path.addLineToPoint(CGPoint(x: 15.7, y: 57.04))
        path.addCurveToPoint(CGPoint(x: 91, y: 19.5),
               controlPoint1: CGPoint(x: 15.95, y: 56.67),
               controlPoint2: CGPoint(x: 41.31, y: 19.5))
        path.addCurveToPoint(CGPoint(x: 166.3, y: 57.05),
               controlPoint1: CGPoint(x: 140.55, y: 19.5),
               controlPoint2: CGPoint(x: 166.05, y: 56.67))
        path.addLineToPoint(CGPoint(x: 166.34, y: 57.02))
        path.addCurveToPoint(CGPoint(x: 169, y: 58.51),
               controlPoint1: CGPoint(x: 166.92, y: 57.9),
               controlPoint2: CGPoint(x: 167.87, y: 58.51))
        path.addCurveToPoint(CGPoint(x: 171.3, y: 57.56),
               controlPoint1: CGPoint(x: 169.9, y: 58.51),
               controlPoint2: CGPoint(x: 170.71, y: 58.15))
        path.addLineToPoint(CGPoint(x: 181.05, y: 47.81))
        path.addCurveToPoint(CGPoint(x: 182, y: 45.52),
               controlPoint1: CGPoint(x: 181.64, y: 47.23),
               controlPoint2: CGPoint(x: 182, y: 46.41))
        path.addCurveToPoint(CGPoint(x: 181.46, y: 43.82),
               controlPoint1: CGPoint(x: 182, y: 44.88),
               controlPoint2: CGPoint(x: 181.77, y: 44.33))
        path.closePath()
        path.moveToPoint(CGPoint(x: 129.29, y: 95.45))
        path.addCurveToPoint(CGPoint(x: 91, y: 77.99),
               controlPoint1: CGPoint(x: 128.72, y: 94.74),
               controlPoint2: CGPoint(x: 115.04, y: 77.99))
        path.addCurveToPoint(CGPoint(x: 52.71, y: 95.45),
               controlPoint1: CGPoint(x: 66.97, y: 77.99),
               controlPoint2: CGPoint(x: 53.28, y: 94.74))
        path.addLineToPoint(CGPoint(x: 52.76, y: 95.49))
        path.addCurveToPoint(CGPoint(x: 52, y: 97.51),
               controlPoint1: CGPoint(x: 52.31, y: 96.05),
               controlPoint2: CGPoint(x: 52, y: 96.73))
        path.addCurveToPoint(CGPoint(x: 52.95, y: 99.8),
               controlPoint1: CGPoint(x: 52, y: 98.4),
               controlPoint2: CGPoint(x: 52.36, y: 99.22))
        path.addLineToPoint(CGPoint(x: 62.7, y: 109.55))
        path.addCurveToPoint(CGPoint(x: 65, y: 110.5),
               controlPoint1: CGPoint(x: 63.29, y: 110.14),
               controlPoint2: CGPoint(x: 64.1, y: 110.5))
        path.addCurveToPoint(CGPoint(x: 67.56, y: 109.16),
               controlPoint1: CGPoint(x: 66.07, y: 110.5),
               controlPoint2: CGPoint(x: 66.97, y: 109.96))
        path.addLineToPoint(CGPoint(x: 67.6, y: 109.19))
        path.addCurveToPoint(CGPoint(x: 91, y: 97.48),
               controlPoint1: CGPoint(x: 67.68, y: 109.07),
               controlPoint2: CGPoint(x: 76.64, y: 97.48))
        path.addCurveToPoint(CGPoint(x: 114.4, y: 109.18),
               controlPoint1: CGPoint(x: 105.36, y: 97.48),
               controlPoint2: CGPoint(x: 114.32, y: 109.07))
        path.addLineToPoint(CGPoint(x: 114.43, y: 109.16))
        path.addCurveToPoint(CGPoint(x: 117, y: 110.5),
               controlPoint1: CGPoint(x: 115.03, y: 109.95),
               controlPoint2: CGPoint(x: 115.93, y: 110.5))
        path.addCurveToPoint(CGPoint(x: 119.3, y: 109.55),
               controlPoint1: CGPoint(x: 117.9, y: 110.5),
               controlPoint2: CGPoint(x: 118.71, y: 110.14))
        path.addLineToPoint(CGPoint(x: 129.05, y: 99.8))
        path.addCurveToPoint(CGPoint(x: 130, y: 97.51),
               controlPoint1: CGPoint(x: 129.64, y: 99.22),
               controlPoint2: CGPoint(x: 130, y: 98.4))
        path.addCurveToPoint(CGPoint(x: 129.24, y: 95.49),
               controlPoint1: CGPoint(x: 130, y: 96.73),
               controlPoint2: CGPoint(x: 129.69, y: 96.05))
        path.addLineToPoint(CGPoint(x: 129.29, y: 95.45))
        path.closePath()
        path.moveToPoint(CGPoint(x: 103.66, y: 122.02))
        path.addCurveToPoint(CGPoint(x: 91, y: 113.73),
               controlPoint1: CGPoint(x: 103.49, y: 121.69),
               controlPoint2: CGPoint(x: 99.41, y: 113.73))
        path.addCurveToPoint(CGPoint(x: 78.34, y: 122.02),
               controlPoint1: CGPoint(x: 82.59, y: 113.73),
               controlPoint2: CGPoint(x: 78.51, y: 121.69))
        path.addLineToPoint(CGPoint(x: 78.38, y: 122.05))
        path.addCurveToPoint(CGPoint(x: 78, y: 123.5),
               controlPoint1: CGPoint(x: 78.16, y: 122.49),
               controlPoint2: CGPoint(x: 78, y: 122.97))
        path.addCurveToPoint(CGPoint(x: 78.95, y: 125.8),
               controlPoint1: CGPoint(x: 78, y: 124.4),
               controlPoint2: CGPoint(x: 78.36, y: 125.21))
        path.addLineToPoint(CGPoint(x: 88.7, y: 135.55))
        path.addCurveToPoint(CGPoint(x: 91, y: 136.5),
               controlPoint1: CGPoint(x: 89.29, y: 136.14),
               controlPoint2: CGPoint(x: 90.1, y: 136.5))
        path.addCurveToPoint(CGPoint(x: 93.3, y: 135.55),
               controlPoint1: CGPoint(x: 91.9, y: 136.5),
               controlPoint2: CGPoint(x: 92.71, y: 136.14))
        path.addLineToPoint(CGPoint(x: 103.05, y: 125.8))
        path.addCurveToPoint(CGPoint(x: 104, y: 123.5),
               controlPoint1: CGPoint(x: 103.64, y: 125.21),
               controlPoint2: CGPoint(x: 104, y: 124.4))
        path.addCurveToPoint(CGPoint(x: 103.62, y: 122.05),
               controlPoint1: CGPoint(x: 104, y: 122.97),
               controlPoint2: CGPoint(x: 103.84, y: 122.49))
        path.addLineToPoint(CGPoint(x: 103.66, y: 122.02))
        path.closePath()
        path.moveToPoint(CGPoint(x: 155.31, y: 69.49))
        path.addCurveToPoint(CGPoint(x: 91, y: 38.99),
               controlPoint1: CGPoint(x: 154.35, y: 68.25),
               controlPoint2: CGPoint(x: 131.13, y: 38.99))
        path.addCurveToPoint(CGPoint(x: 26.69, y: 69.49),
               controlPoint1: CGPoint(x: 50.87, y: 38.99),
               controlPoint2: CGPoint(x: 27.65, y: 68.25))
        path.addLineToPoint(CGPoint(x: 26.74, y: 69.53))
        path.addCurveToPoint(CGPoint(x: 26, y: 71.51),
               controlPoint1: CGPoint(x: 26.3, y: 70.09),
               controlPoint2: CGPoint(x: 26, y: 70.76))
        path.addCurveToPoint(CGPoint(x: 26.95, y: 73.81),
               controlPoint1: CGPoint(x: 26, y: 72.41),
               controlPoint2: CGPoint(x: 26.36, y: 73.22))
        path.addLineToPoint(CGPoint(x: 36.7, y: 83.56))
        path.addCurveToPoint(CGPoint(x: 39, y: 84.51),
               controlPoint1: CGPoint(x: 37.29, y: 84.15),
               controlPoint2: CGPoint(x: 38.1, y: 84.51))
        path.addCurveToPoint(CGPoint(x: 41.56, y: 83.16),
               controlPoint1: CGPoint(x: 40.07, y: 84.51),
               controlPoint2: CGPoint(x: 40.97, y: 83.96))
        path.addLineToPoint(CGPoint(x: 41.6, y: 83.19))
        path.addCurveToPoint(CGPoint(x: 91, y: 58.49),
               controlPoint1: CGPoint(x: 41.79, y: 82.94),
               controlPoint2: CGPoint(x: 60.58, y: 58.49))
        path.addCurveToPoint(CGPoint(x: 140.4, y: 83.19),
               controlPoint1: CGPoint(x: 121.42, y: 58.49),
               controlPoint2: CGPoint(x: 140.22, y: 82.94))
        path.addLineToPoint(CGPoint(x: 140.44, y: 83.16))
        path.addCurveToPoint(CGPoint(x: 143, y: 84.51),
               controlPoint1: CGPoint(x: 141.03, y: 83.96),
               controlPoint2: CGPoint(x: 141.93, y: 84.51))
        path.addCurveToPoint(CGPoint(x: 145.3, y: 83.56),
               controlPoint1: CGPoint(x: 143.9, y: 84.51),
               controlPoint2: CGPoint(x: 144.71, y: 84.15))
        path.addLineToPoint(CGPoint(x: 155.05, y: 73.81))
        path.addCurveToPoint(CGPoint(x: 156, y: 71.51),
               controlPoint1: CGPoint(x: 155.64, y: 73.22),
               controlPoint2: CGPoint(x: 156, y: 72.41))
        path.addCurveToPoint(CGPoint(x: 155.27, y: 69.53),
               controlPoint1: CGPoint(x: 156, y: 70.76),
               controlPoint2: CGPoint(x: 155.7, y: 70.09))
        path.addLineToPoint(CGPoint(x: 155.31, y: 69.49))
        path.closePath()
    } else {
        path.moveToPoint(CGPoint(x: 103.66, y: 122.02))
        path.addCurveToPoint(CGPoint(x: 91, y: 113.73),
               controlPoint1: CGPoint(x: 103.49, y: 121.69),
               controlPoint2: CGPoint(x: 99.41, y: 113.73))
        path.addCurveToPoint(CGPoint(x: 78.34, y: 122.02),
               controlPoint1: CGPoint(x: 82.59, y: 113.73),
               controlPoint2: CGPoint(x: 78.51, y: 121.69))
        path.addLineToPoint(CGPoint(x: 78.38, y: 122.05))
        path.addCurveToPoint(CGPoint(x: 78, y: 123.5),
               controlPoint1: CGPoint(x: 78.16, y: 122.49),
               controlPoint2: CGPoint(x: 78, y: 122.97))
        path.addCurveToPoint(CGPoint(x: 78.95, y: 125.8),
               controlPoint1: CGPoint(x: 78, y: 124.4),
               controlPoint2: CGPoint(x: 78.36, y: 125.21))
        path.addLineToPoint(CGPoint(x: 88.7, y: 135.55))
        path.addCurveToPoint(CGPoint(x: 91, y: 136.5),
               controlPoint1: CGPoint(x: 89.29, y: 136.14),
               controlPoint2: CGPoint(x: 90.1, y: 136.5))
        path.addCurveToPoint(CGPoint(x: 93.3, y: 135.55),
               controlPoint1: CGPoint(x: 91.9, y: 136.5),
               controlPoint2: CGPoint(x: 92.71, y: 136.14))
        path.addLineToPoint(CGPoint(x: 103.05, y: 125.8))
        path.addCurveToPoint(CGPoint(x: 104, y: 123.5),
               controlPoint1: CGPoint(x: 103.64, y: 125.21),
               controlPoint2: CGPoint(x: 104, y: 124.4))
        path.addCurveToPoint(CGPoint(x: 103.62, y: 122.05),
               controlPoint1: CGPoint(x: 104, y: 122.97),
               controlPoint2: CGPoint(x: 103.84, y: 122.49))
        path.addLineToPoint(CGPoint(x: 103.66, y: 122.02))
        path.closePath()
        path.moveToPoint(CGPoint(x: 91, y: 128.66))
        path.addLineToPoint(CGPoint(x: 85.46, y: 123.12))
        path.addCurveToPoint(CGPoint(x: 91, y: 120.23),
               controlPoint1: CGPoint(x: 86.61, y: 121.79),
               controlPoint2: CGPoint(x: 88.47, y: 120.23))
        path.addCurveToPoint(CGPoint(x: 96.54, y: 123.12),
               controlPoint1: CGPoint(x: 93.53, y: 120.23),
               controlPoint2: CGPoint(x: 95.39, y: 121.79))
        path.addLineToPoint(CGPoint(x: 91, y: 128.66))
        path.closePath()
        path.moveToPoint(CGPoint(x: 129.29, y: 95.45))
        path.addCurveToPoint(CGPoint(x: 91, y: 77.99),
               controlPoint1: CGPoint(x: 128.72, y: 94.74),
               controlPoint2: CGPoint(x: 115.03, y: 77.99))
        path.addCurveToPoint(CGPoint(x: 52.71, y: 95.45),
               controlPoint1: CGPoint(x: 66.96, y: 77.99),
               controlPoint2: CGPoint(x: 53.28, y: 94.74))
        path.addLineToPoint(CGPoint(x: 52.76, y: 95.49))
        path.addCurveToPoint(CGPoint(x: 52, y: 97.51),
               controlPoint1: CGPoint(x: 52.31, y: 96.05),
               controlPoint2: CGPoint(x: 52, y: 96.73))
        path.addCurveToPoint(CGPoint(x: 52.95, y: 99.8),
               controlPoint1: CGPoint(x: 52, y: 98.4),
               controlPoint2: CGPoint(x: 52.36, y: 99.22))
        path.addLineToPoint(CGPoint(x: 62.7, y: 109.55))
        path.addCurveToPoint(CGPoint(x: 65, y: 110.5),
               controlPoint1: CGPoint(x: 63.29, y: 110.14),
               controlPoint2: CGPoint(x: 64.1, y: 110.5))
        path.addCurveToPoint(CGPoint(x: 67.56, y: 109.16),
               controlPoint1: CGPoint(x: 66.07, y: 110.5),
               controlPoint2: CGPoint(x: 66.97, y: 109.96))
        path.addLineToPoint(CGPoint(x: 67.6, y: 109.19))
        path.addCurveToPoint(CGPoint(x: 91, y: 97.48),
               controlPoint1: CGPoint(x: 67.68, y: 109.07),
               controlPoint2: CGPoint(x: 76.64, y: 97.48))
        path.addCurveToPoint(CGPoint(x: 114.4, y: 109.18),
               controlPoint1: CGPoint(x: 105.36, y: 97.48),
               controlPoint2: CGPoint(x: 114.32, y: 109.07))
        path.addLineToPoint(CGPoint(x: 114.43, y: 109.16))
        path.addCurveToPoint(CGPoint(x: 117, y: 110.5),
               controlPoint1: CGPoint(x: 115.03, y: 109.95),
               controlPoint2: CGPoint(x: 115.93, y: 110.5))
        path.addCurveToPoint(CGPoint(x: 119.3, y: 109.55),
               controlPoint1: CGPoint(x: 117.9, y: 110.5),
               controlPoint2: CGPoint(x: 118.71, y: 110.14))
        path.addLineToPoint(CGPoint(x: 129.05, y: 99.8))
        path.addCurveToPoint(CGPoint(x: 130, y: 97.51),
               controlPoint1: CGPoint(x: 129.64, y: 99.22),
               controlPoint2: CGPoint(x: 130, y: 98.4))
        path.addCurveToPoint(CGPoint(x: 129.24, y: 95.49),
               controlPoint1: CGPoint(x: 130, y: 96.73),
               controlPoint2: CGPoint(x: 129.69, y: 96.05))
        path.addLineToPoint(CGPoint(x: 129.29, y: 95.45))
        path.closePath()
        path.moveToPoint(CGPoint(x: 117.15, y: 102.51))
        path.addCurveToPoint(CGPoint(x: 91, y: 90.98),
               controlPoint1: CGPoint(x: 113.04, y: 98.36),
               controlPoint2: CGPoint(x: 103.97, y: 90.98))
        path.addCurveToPoint(CGPoint(x: 64.85, y: 102.51),
               controlPoint1: CGPoint(x: 78.03, y: 90.98),
               controlPoint2: CGPoint(x: 68.96, y: 98.36))
        path.addLineToPoint(CGPoint(x: 59.76, y: 97.42))
        path.addCurveToPoint(CGPoint(x: 91, y: 84.48),
               controlPoint1: CGPoint(x: 63.97, y: 93.3),
               controlPoint2: CGPoint(x: 74.86, y: 84.48))
        path.addCurveToPoint(CGPoint(x: 122.23, y: 97.43),
               controlPoint1: CGPoint(x: 107.05, y: 84.48),
               controlPoint2: CGPoint(x: 118, y: 93.31))
        path.addLineToPoint(CGPoint(x: 117.15, y: 102.51))
        path.closePath()
        path.moveToPoint(CGPoint(x: 155.31, y: 69.49))
        path.addCurveToPoint(CGPoint(x: 91, y: 38.99),
               controlPoint1: CGPoint(x: 154.35, y: 68.25),
               controlPoint2: CGPoint(x: 131.13, y: 38.99))
        path.addCurveToPoint(CGPoint(x: 26.69, y: 69.49),
               controlPoint1: CGPoint(x: 50.87, y: 38.99),
               controlPoint2: CGPoint(x: 27.65, y: 68.25))
        path.addLineToPoint(CGPoint(x: 26.74, y: 69.53))
        path.addCurveToPoint(CGPoint(x: 26, y: 71.51),
               controlPoint1: CGPoint(x: 26.3, y: 70.09),
               controlPoint2: CGPoint(x: 26, y: 70.76))
        path.addCurveToPoint(CGPoint(x: 26.95, y: 73.81),
               controlPoint1: CGPoint(x: 26, y: 72.41),
               controlPoint2: CGPoint(x: 26.36, y: 73.22))
        path.addLineToPoint(CGPoint(x: 36.7, y: 83.56))
        path.addCurveToPoint(CGPoint(x: 39, y: 84.51),
               controlPoint1: CGPoint(x: 37.29, y: 84.15),
               controlPoint2: CGPoint(x: 38.1, y: 84.51))
        path.addCurveToPoint(CGPoint(x: 41.56, y: 83.16),
               controlPoint1: CGPoint(x: 40.07, y: 84.51),
               controlPoint2: CGPoint(x: 40.97, y: 83.96))
        path.addLineToPoint(CGPoint(x: 41.6, y: 83.19))
        path.addCurveToPoint(CGPoint(x: 91, y: 58.49),
               controlPoint1: CGPoint(x: 41.78, y: 82.94),
               controlPoint2: CGPoint(x: 60.58, y: 58.49))
        path.addCurveToPoint(CGPoint(x: 140.4, y: 83.19),
               controlPoint1: CGPoint(x: 121.42, y: 58.49),
               controlPoint2: CGPoint(x: 140.22, y: 82.94))
        path.addLineToPoint(CGPoint(x: 140.44, y: 83.16))
        path.addCurveToPoint(CGPoint(x: 143, y: 84.51),
               controlPoint1: CGPoint(x: 141.03, y: 83.96),
               controlPoint2: CGPoint(x: 141.93, y: 84.51))
        path.addCurveToPoint(CGPoint(x: 145.3, y: 83.56),
               controlPoint1: CGPoint(x: 143.9, y: 84.51),
               controlPoint2: CGPoint(x: 144.71, y: 84.15))
        path.addLineToPoint(CGPoint(x: 155.05, y: 73.81))
        path.addCurveToPoint(CGPoint(x: 156, y: 71.51),
               controlPoint1: CGPoint(x: 155.64, y: 73.22),
               controlPoint2: CGPoint(x: 156, y: 72.41))
        path.addCurveToPoint(CGPoint(x: 155.26, y: 69.53),
               controlPoint1: CGPoint(x: 156, y: 70.76),
               controlPoint2: CGPoint(x: 155.7, y: 70.09))
        path.addLineToPoint(CGPoint(x: 155.31, y: 69.49))
        path.closePath()
        path.moveToPoint(CGPoint(x: 143.22, y: 76.44))
        path.addCurveToPoint(CGPoint(x: 91, y: 51.99),
               controlPoint1: CGPoint(x: 136.94, y: 69.43),
               controlPoint2: CGPoint(x: 118.55, y: 51.99))
        path.addCurveToPoint(CGPoint(x: 38.78, y: 76.44),
               controlPoint1: CGPoint(x: 63.45, y: 51.99),
               controlPoint2: CGPoint(x: 45.06, y: 69.43))
        path.addLineToPoint(CGPoint(x: 33.69, y: 71.35))
        path.addCurveToPoint(CGPoint(x: 91, y: 45.49),
               controlPoint1: CGPoint(x: 39.68, y: 64.86),
               controlPoint2: CGPoint(x: 60.13, y: 45.49))
        path.addCurveToPoint(CGPoint(x: 148.31, y: 71.35),
               controlPoint1: CGPoint(x: 121.87, y: 45.49),
               controlPoint2: CGPoint(x: 142.32, y: 64.86))
        path.addLineToPoint(CGPoint(x: 143.22, y: 76.44))
        path.closePath()
        path.moveToPoint(CGPoint(x: 181.46, y: 43.82))
        path.addLineToPoint(CGPoint(x: 181.52, y: 43.79))
        path.addCurveToPoint(CGPoint(x: 91, y: 0),
               controlPoint1: CGPoint(x: 180.42, y: 42),
               controlPoint2: CGPoint(x: 153.85, y: 0))
        path.addCurveToPoint(CGPoint(x: 0.48, y: 43.79),
               controlPoint1: CGPoint(x: 28.15, y: 0),
               controlPoint2: CGPoint(x: 1.58, y: 42))
        path.addLineToPoint(CGPoint(x: 0.54, y: 43.82))
        path.addCurveToPoint(CGPoint(x: 0, y: 45.52),
               controlPoint1: CGPoint(x: 0.23, y: 44.33),
               controlPoint2: CGPoint(x: 0, y: 44.88))
        path.addCurveToPoint(CGPoint(x: 0.95, y: 47.81),
               controlPoint1: CGPoint(x: 0, y: 46.41),
               controlPoint2: CGPoint(x: 0.36, y: 47.23))
        path.addLineToPoint(CGPoint(x: 10.7, y: 57.56))
        path.addCurveToPoint(CGPoint(x: 13, y: 58.51),
               controlPoint1: CGPoint(x: 11.29, y: 58.15),
               controlPoint2: CGPoint(x: 12.1, y: 58.51))
        path.addCurveToPoint(CGPoint(x: 15.67, y: 57.02),
               controlPoint1: CGPoint(x: 14.14, y: 58.51),
               controlPoint2: CGPoint(x: 15.09, y: 57.9))
        path.addLineToPoint(CGPoint(x: 15.7, y: 57.04))
        path.addCurveToPoint(CGPoint(x: 91, y: 19.5),
               controlPoint1: CGPoint(x: 15.95, y: 56.67),
               controlPoint2: CGPoint(x: 41.31, y: 19.5))
        path.addCurveToPoint(CGPoint(x: 166.3, y: 57.05),
               controlPoint1: CGPoint(x: 140.55, y: 19.5),
               controlPoint2: CGPoint(x: 166.05, y: 56.67))
        path.addLineToPoint(CGPoint(x: 166.34, y: 57.02))
        path.addCurveToPoint(CGPoint(x: 169, y: 58.51),
               controlPoint1: CGPoint(x: 166.92, y: 57.9),
               controlPoint2: CGPoint(x: 167.87, y: 58.51))
        path.addCurveToPoint(CGPoint(x: 171.3, y: 57.56),
               controlPoint1: CGPoint(x: 169.9, y: 58.51),
               controlPoint2: CGPoint(x: 170.71, y: 58.15))
        path.addLineToPoint(CGPoint(x: 181.05, y: 47.81))
        path.addCurveToPoint(CGPoint(x: 182, y: 45.52),
               controlPoint1: CGPoint(x: 181.64, y: 47.23),
               controlPoint2: CGPoint(x: 182, y: 46.41))
        path.addCurveToPoint(CGPoint(x: 181.46, y: 43.82),
               controlPoint1: CGPoint(x: 182, y: 44.88),
               controlPoint2: CGPoint(x: 181.77, y: 44.33))
        path.closePath()
        path.moveToPoint(CGPoint(x: 169.37, y: 50.3))
        path.addCurveToPoint(CGPoint(x: 91, y: 13),
               controlPoint1: CGPoint(x: 161.79, y: 40.74),
               controlPoint2: CGPoint(x: 135.93, y: 13))
        path.addCurveToPoint(CGPoint(x: 12.63, y: 50.3),
               controlPoint1: CGPoint(x: 46.07, y: 13),
               controlPoint2: CGPoint(x: 20.21, y: 40.74))
        path.addLineToPoint(CGPoint(x: 7.46, y: 45.13))
        path.addCurveToPoint(CGPoint(x: 26.15, y: 26.8),
               controlPoint1: CGPoint(x: 10.04, y: 41.63),
               controlPoint2: CGPoint(x: 16.15, y: 34.18))
        path.addCurveToPoint(CGPoint(x: 91, y: 6.5),
               controlPoint1: CGPoint(x: 38.7, y: 17.54),
               controlPoint2: CGPoint(x: 60.13, y: 6.5))
        path.addCurveToPoint(CGPoint(x: 155.85, y: 26.8),
               controlPoint1: CGPoint(x: 121.87, y: 6.5),
               controlPoint2: CGPoint(x: 143.3, y: 17.54))
        path.addCurveToPoint(CGPoint(x: 174.54, y: 45.13),
               controlPoint1: CGPoint(x: 165.85, y: 34.18),
               controlPoint2: CGPoint(x: 171.96, y: 41.63))
        path.addLineToPoint(CGPoint(x: 169.37, y: 50.3))
        path.closePath()
    }

    color.setFill()
    path.fill()

  }

  /**
  drawWifiStatus:connected:frame:

  :param: #color UIColor
  :param: connected Bool
  :param: frame CGRect
  */
  public class func drawWifiStatus(#color: UIColor, connected: Bool, frame: CGRect) {
    let context = UIGraphicsGetCurrentContext()

    let squaredSize = CGSize(width: min(frame.width, frame.height), height:  min(frame.width, frame.height))
    let squaredFrame = CGRect(x: frame.origin.x + (frame.width - squaredSize.width) / 2.0,
                              y: frame.origin.y + (frame.height - squaredSize.height) / 2.0,
                              width: squaredSize.width,
                              height: squaredSize.height)
    let wifiFrame = CGRect(x: squaredFrame.origin.x,
                           y: squaredFrame.origin.y + (squaredFrame.height - squaredFrame.width * 4.25 / 5.69) / 2.0,
                           width: squaredFrame.size.width,
                           height: squaredFrame.size.width * 4.25 / 5.69)

    let symbolRect = CGRect(x: wifiFrame.minX,
                            y: wifiFrame.minY,
                            width: floor(wifiFrame.width + 0.5),
                            height: floor(wifiFrame.height + 0.05) - 1.55)
    CGContextSaveGState(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)
    CGContextScaleCTM(context, symbolRect.size.width / 182, symbolRect.size.height / 136)

    drawWifiIcon(color: color, connected: connected)
    CGContextRestoreGState(context)
  }

}
