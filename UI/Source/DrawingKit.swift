//
//  DrawingKit.swift
//  Remote
//
//  Created by Moondeer on 5/2/15.
//  Copyright (c) 2015 Moondeer Studios. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//



import UIKit

public class DrawingKit : NSObject {

    //// Cache

    private struct Cache {
        static var verticalGlossStop: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        static var verticalGloss: CGGradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [DrawingKit.verticalGlossStop.CGColor, DrawingKit.verticalGlossStop.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor, UIColor.whiteColor().CGColor], [0, 0.4, 1])!
        static var innerShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 2)
        static var outerShadow: NSShadow = NSShadow(color: UIColor.blackColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 2)
        static var strokeShadow: NSShadow = NSShadow(color: UIColor.lightGrayColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 1)
        static var insettingShadow: NSShadow = NSShadow(color: UIColor.whiteColor().colorWithAlphaComponent(0.5), offset: CGSizeMake(0.1, 0.6), blurRadius: 0)
        static var plasticShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSizeMake(0.1, -0.6), blurRadius: 1)
        static var cutoutShadow: NSShadow = NSShadow(color: UIColor.blackColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 1)
        static var glowingShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 5)
    }

    //// Colors

    public class var verticalGlossStop: UIColor { return Cache.verticalGlossStop }

    //// Gradients

    public class var verticalGloss: CGGradient { return Cache.verticalGloss }

    //// Shadows

    public class var innerShadow: NSShadow { return Cache.innerShadow }
    public class var outerShadow: NSShadow { return Cache.outerShadow }
    public class var strokeShadow: NSShadow { return Cache.strokeShadow }
    public class var insettingShadow: NSShadow { return Cache.insettingShadow }
    public class var plasticShadow: NSShadow { return Cache.plasticShadow }
    public class var cutoutShadow: NSShadow { return Cache.cutoutShadow }
    public class var glowingShadow: NSShadow { return Cache.glowingShadow }

    //// Drawing Methods

    public class func drawRoundedButtonBase(color color: UIColor, contentColor: UIColor, radius: CGFloat, rect: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()


        //// Variable Declarations
        let contentAndBaseRect = CGRectMake(4, 4, rect.size.width - 8, rect.size.height - 8)

        //// Frames
        let frame = CGRectMake(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)


        //// darkOverlayRectangle Drawing
        let darkOverlayRectanglePath = UIBezierPath(roundedRect: CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4), cornerRadius: radius)
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.outerShadow.shadowOffset, DrawingKit.outerShadow.shadowBlurRadius, (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
        color.setFill()
        darkOverlayRectanglePath.fill()

        ////// darkOverlayRectangle Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, darkOverlayRectanglePath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let darkOverlayRectangleOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, darkOverlayRectangleOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, .SourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        darkOverlayRectangleOpaqueShadow.setFill()
        darkOverlayRectanglePath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.strokeShadow.shadowOffset, DrawingKit.strokeShadow.shadowBlurRadius, (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
        contentColor.setStroke()
        darkOverlayRectanglePath.lineWidth = 1
        darkOverlayRectanglePath.stroke()
        CGContextRestoreGState(context)


        //// lightBase
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, .SoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip lightBaseClip
        let lightBaseClipPath = UIBezierPath(roundedRect: contentAndBaseRect, cornerRadius: radius)
        lightBaseClipPath.addClip()


        //// lightBaseFillRect Drawing
        let lightBaseFillRectPath = UIBezierPath(rect: CGRectMake(0, 0, 200, 200))
        CGContextSaveGState(context)
        lightBaseFillRectPath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
            CGPointMake(100, 200),
            CGPointMake(100, 100),
            [.DrawsBeforeStartLocation, .DrawsAfterEndLocation])
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawRectangularButtonBase(color color: UIColor, contentColor: UIColor, rect: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()


        //// Variable Declarations
        let contentAndBaseRect = CGRectMake(4, 4, rect.size.width - 8, rect.size.height - 8)

        //// Frames
        let frame = CGRectMake(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)


        //// darkOverlayRect Drawing
        let darkOverlayRectPath = UIBezierPath(rect: CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4))
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.outerShadow.shadowOffset, DrawingKit.outerShadow.shadowBlurRadius, (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
        color.setFill()
        darkOverlayRectPath.fill()

        ////// darkOverlayRect Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, darkOverlayRectPath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let darkOverlayRectOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, darkOverlayRectOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, .SourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        darkOverlayRectOpaqueShadow.setFill()
        darkOverlayRectPath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.strokeShadow.shadowOffset, DrawingKit.strokeShadow.shadowBlurRadius, (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
        contentColor.setStroke()
        darkOverlayRectPath.lineWidth = 1
        darkOverlayRectPath.stroke()
        CGContextRestoreGState(context)


        //// lightBase
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, .SoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip lightBaseClipRect
        let lightBaseClipRectPath = UIBezierPath(rect: contentAndBaseRect)
        lightBaseClipRectPath.addClip()


        //// lightBaseFillRect Drawing
        let lightBaseFillRectPath = UIBezierPath(rect: CGRectMake(0, -8, 200, 200))
        CGContextSaveGState(context)
        lightBaseFillRectPath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
            CGPointMake(100, 192),
            CGPointMake(100, 92),
            [.DrawsBeforeStartLocation, .DrawsAfterEndLocation])
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawOvalButtonBase(color color: UIColor, contentColor: UIColor, rect: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()


        //// Variable Declarations
        let contentAndBaseRect = CGRectMake(4, 4, rect.size.width - 8, rect.size.height - 8)

        //// Frames
        let frame = CGRectMake(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)


        //// darkOverlayOval Drawing
        let darkOverlayOvalPath = UIBezierPath(ovalInRect: CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4))
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.outerShadow.shadowOffset, DrawingKit.outerShadow.shadowBlurRadius, (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
        color.setFill()
        darkOverlayOvalPath.fill()

        ////// darkOverlayOval Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, darkOverlayOvalPath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let darkOverlayOvalOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, darkOverlayOvalOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, .SourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        darkOverlayOvalOpaqueShadow.setFill()
        darkOverlayOvalPath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.strokeShadow.shadowOffset, DrawingKit.strokeShadow.shadowBlurRadius, (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
        contentColor.setStroke()
        darkOverlayOvalPath.lineWidth = 1
        darkOverlayOvalPath.stroke()
        CGContextRestoreGState(context)


        //// lightBase
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, .SoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip lightBaseClipRect
        let lightBaseClipRectPath = UIBezierPath(ovalInRect: contentAndBaseRect)
        lightBaseClipRectPath.addClip()


        //// lightBaseFillRect Drawing
        let lightBaseFillRectPath = UIBezierPath(rect: CGRectMake(0, 0, 200, 200))
        CGContextSaveGState(context)
        lightBaseFillRectPath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
            CGPointMake(100, 200),
            CGPointMake(100, 100),
            [.DrawsBeforeStartLocation, .DrawsAfterEndLocation])
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawDiamondButtonBase(color color: UIColor, contentColor: UIColor, rect: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Frames
        let frame = CGRectMake(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)

        //// Subframes
        let lightBase: CGRect = CGRectMake(frame.minX + 4, frame.minY + 4, frame.width - 8, frame.height - 8)


        //// darkOverlayDiamond Drawing
        let darkOverlayDiamondPath = UIBezierPath()
        darkOverlayDiamondPath.moveToPoint(CGPointMake(frame.minX + 2, frame.minY + 0.50000 * frame.height))
        darkOverlayDiamondPath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 2))
        darkOverlayDiamondPath.addLineToPoint(CGPointMake(frame.maxX - 2, frame.minY + 0.50000 * frame.height))
        darkOverlayDiamondPath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.maxY - 2))
        darkOverlayDiamondPath.addLineToPoint(CGPointMake(frame.minX + 2, frame.minY + 0.50000 * frame.height))
        darkOverlayDiamondPath.closePath()
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.outerShadow.shadowOffset, DrawingKit.outerShadow.shadowBlurRadius, (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
        color.setFill()
        darkOverlayDiamondPath.fill()

        ////// darkOverlayDiamond Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, darkOverlayDiamondPath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let darkOverlayDiamondOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, darkOverlayDiamondOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, .SourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        darkOverlayDiamondOpaqueShadow.setFill()
        darkOverlayDiamondPath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.strokeShadow.shadowOffset, DrawingKit.strokeShadow.shadowBlurRadius, (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
        contentColor.setStroke()
        darkOverlayDiamondPath.lineWidth = 1
        darkOverlayDiamondPath.stroke()
        CGContextRestoreGState(context)


        //// lightBase
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, .SoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip lightBaseClipRect
        let lightBaseClipRectPath = UIBezierPath()
        lightBaseClipRectPath.moveToPoint(CGPointMake(lightBase.minX + 0.00000 * lightBase.width, lightBase.minY + 0.50000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.50000 * lightBase.width, lightBase.minY + 0.00000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 1.00000 * lightBase.width, lightBase.minY + 0.50000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.50000 * lightBase.width, lightBase.minY + 1.00000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.00000 * lightBase.width, lightBase.minY + 0.50000 * lightBase.height))
        lightBaseClipRectPath.closePath()
        lightBaseClipRectPath.addClip()


        //// lightBaseFillRect Drawing
        let lightBaseFillRectRect = CGRectMake(lightBase.minX + floor(lightBase.width * -0.02083 + 0.5), lightBase.minY + floor(lightBase.height * -0.02083 + 0.5), floor(lightBase.width * 1.02083 + 0.5) - floor(lightBase.width * -0.02083 + 0.5), floor(lightBase.height * 1.02083 + 0.5) - floor(lightBase.height * -0.02083 + 0.5))
        let lightBaseFillRectPath = UIBezierPath(rect: lightBaseFillRectRect)
        CGContextSaveGState(context)
        lightBaseFillRectPath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 200, lightBaseFillRectRect.midY + 100 * lightBaseFillRectRect.height / 200),
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 200, lightBaseFillRectRect.midY + 0 * lightBaseFillRectRect.height / 200),
            [.DrawsBeforeStartLocation, .DrawsAfterEndLocation])
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawTriangleButtonBase(color color: UIColor, contentColor: UIColor, rect: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Frames
        let frame = CGRectMake(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)

        //// Subframes
        let overlayGroup: CGRect = CGRectMake(frame.minX + 7.2, frame.minY + 9.5, frame.width - 13.4, frame.height - 25)
        let lightBase: CGRect = CGRectMake(frame.minX + 7.2, frame.minY + 9.5, frame.width - 13.4, frame.height - 25)


        //// Overlay Group
        //// darkOverlayTriangle Drawing
        let darkOverlayTrianglePath = UIBezierPath()
        darkOverlayTrianglePath.moveToPoint(CGPointMake(overlayGroup.minX + 0.50000 * overlayGroup.width, overlayGroup.minY + 0.00000 * overlayGroup.height))
        darkOverlayTrianglePath.addLineToPoint(CGPointMake(overlayGroup.minX + 0.75000 * overlayGroup.width, overlayGroup.minY + 0.50000 * overlayGroup.height))
        darkOverlayTrianglePath.addLineToPoint(CGPointMake(overlayGroup.minX + 1.00000 * overlayGroup.width, overlayGroup.minY + 1.00000 * overlayGroup.height))
        darkOverlayTrianglePath.addLineToPoint(CGPointMake(overlayGroup.minX + 0.50000 * overlayGroup.width, overlayGroup.minY + 1.00000 * overlayGroup.height))
        darkOverlayTrianglePath.addLineToPoint(CGPointMake(overlayGroup.minX + 0.00000 * overlayGroup.width, overlayGroup.minY + 1.00000 * overlayGroup.height))
        darkOverlayTrianglePath.addLineToPoint(CGPointMake(overlayGroup.minX + 0.25000 * overlayGroup.width, overlayGroup.minY + 0.50000 * overlayGroup.height))
        darkOverlayTrianglePath.addLineToPoint(CGPointMake(overlayGroup.minX + 0.50000 * overlayGroup.width, overlayGroup.minY + 0.00000 * overlayGroup.height))
        darkOverlayTrianglePath.closePath()
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.outerShadow.shadowOffset, DrawingKit.outerShadow.shadowBlurRadius, (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
        color.setFill()
        darkOverlayTrianglePath.fill()

        ////// darkOverlayTriangle Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, darkOverlayTrianglePath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let darkOverlayTriangleOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, darkOverlayTriangleOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, .SourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        darkOverlayTriangleOpaqueShadow.setFill()
        darkOverlayTrianglePath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.strokeShadow.shadowOffset, DrawingKit.strokeShadow.shadowBlurRadius, (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
        contentColor.setStroke()
        darkOverlayTrianglePath.lineWidth = 1
        darkOverlayTrianglePath.stroke()
        CGContextRestoreGState(context)




        //// lightBase
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, .SoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip lightBaseClipRect
        let lightBaseClipRectPath = UIBezierPath()
        lightBaseClipRectPath.moveToPoint(CGPointMake(lightBase.minX + 0.50000 * lightBase.width, lightBase.minY + 0.00000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.75000 * lightBase.width, lightBase.minY + 0.50000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 1.00000 * lightBase.width, lightBase.minY + 1.00000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.50000 * lightBase.width, lightBase.minY + 1.00000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.00000 * lightBase.width, lightBase.minY + 1.00000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.25000 * lightBase.width, lightBase.minY + 0.50000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.50000 * lightBase.width, lightBase.minY + 0.00000 * lightBase.height))
        lightBaseClipRectPath.closePath()
        lightBaseClipRectPath.addClip()


        //// lightBaseFillRect Drawing
        let lightBaseFillRectRect = CGRectMake(lightBase.minX + floor(lightBase.width * -0.03858 - 0.3) + 0.8, lightBase.minY + floor(lightBase.height * -0.05429) + 0.5, floor(lightBase.width * 1.03322 - 0.3) - floor(lightBase.width * -0.03858 - 0.3), floor(lightBase.height * 1.08857) - floor(lightBase.height * -0.05429))
        let lightBaseFillRectPath = UIBezierPath(rect: lightBaseFillRectRect)
        CGContextSaveGState(context)
        lightBaseFillRectPath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 200, lightBaseFillRectRect.midY + 100 * lightBaseFillRectRect.height / 200),
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 200, lightBaseFillRectRect.midY + 0 * lightBaseFillRectRect.height / 200),
            [.DrawsBeforeStartLocation, .DrawsAfterEndLocation])
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawBatteryStatus(batteryBaseColor batteryBaseColor: UIColor, hasPower: Bool, chargeLevel: CGFloat, containingFrame: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()


        //// Variable Declarations
        let squaredContainingFrameSize = CGSizeMake(min(containingFrame.size.width, containingFrame.size.height), min(containingFrame.size.width, containingFrame.size.height))
        let squaredContainingFrame = CGRectMake(containingFrame.origin.x + (containingFrame.size.width - squaredContainingFrameSize.width) / 2.0, containingFrame.origin.y + (containingFrame.size.height - squaredContainingFrameSize.height) / 2.0, squaredContainingFrameSize.width, squaredContainingFrameSize.height)
        let batteryFrame = CGRectMake(squaredContainingFrame.origin.x, squaredContainingFrame.origin.y + (squaredContainingFrame.size.height - squaredContainingFrame.size.width * 4 / 7.0) / 2.0, squaredContainingFrame.size.width, squaredContainingFrame.size.width * 4 / 7.0)

        //// Frames
        let frame = CGRectMake(batteryFrame.origin.x, batteryFrame.origin.y, batteryFrame.size.width, batteryFrame.size.height)


        //// Symbol Drawing
        let symbolRect = CGRectMake(frame.minX + floor(frame.width * 0.00000 + 0.5), frame.minY + floor(frame.height * -0.00000 + 0.5), floor(frame.width * 1.00000 + 0.5) - floor(frame.width * 0.00000 + 0.5), floor(frame.height * 1.00000 + 0.21) - floor(frame.height * -0.00000 + 0.5) + 0.29)
        CGContextSaveGState(context)
        UIRectClip(symbolRect)
        CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)
        CGContextScaleCTM(context, symbolRect.size.width / 224, symbolRect.size.height / 128)

        DrawingKit.drawBatteryIcon(batteryBaseColor: batteryBaseColor, hasPower: hasPower, chargeLevel: chargeLevel)
        CGContextRestoreGState(context)
    }

    public class func drawBatteryIcon(batteryBaseColor batteryBaseColor: UIColor, hasPower: Bool, chargeLevel: CGFloat) {
        //// Color Declarations
        let batteryIconColor = batteryBaseColor.colorWithHighlight(0.3)

        //// Variable Declarations
        let showPower = hasPower && chargeLevel == 1
        let showCharging = hasPower && chargeLevel < 1
        let chargeMaxX: CGFloat = 16 + 175 * chargeLevel

        //// Outline Drawing
        let outlinePath = UIBezierPath()
        outlinePath.moveToPoint(CGPointMake(208, 44))
        outlinePath.addLineToPoint(CGPointMake(208, 84))
        outlinePath.addCurveToPoint(CGPointMake(216, 76), controlPoint1: CGPointMake(212.42, 84), controlPoint2: CGPointMake(216, 80.42))
        outlinePath.addLineToPoint(CGPointMake(216, 52))
        outlinePath.addCurveToPoint(CGPointMake(208, 44), controlPoint1: CGPointMake(216, 47.58), controlPoint2: CGPointMake(212.42, 44))
        outlinePath.closePath()
        outlinePath.moveToPoint(CGPointMake(144, 16))
        outlinePath.addLineToPoint(CGPointMake(16.03, 16))
        outlinePath.addLineToPoint(CGPointMake(16.03, 112))
        outlinePath.addCurveToPoint(CGPointMake(16, 16), controlPoint1: CGPointMake(16, 112), controlPoint2: CGPointMake(16, 16))
        outlinePath.addLineToPoint(CGPointMake(144, 16))
        outlinePath.closePath()
        outlinePath.moveToPoint(CGPointMake(192, 8))
        outlinePath.addLineToPoint(CGPointMake(16, 8))
        outlinePath.addCurveToPoint(CGPointMake(8, 16), controlPoint1: CGPointMake(11.58, 8), controlPoint2: CGPointMake(8, 11.58))
        outlinePath.addLineToPoint(CGPointMake(8, 112))
        outlinePath.addCurveToPoint(CGPointMake(16, 120), controlPoint1: CGPointMake(8, 116.42), controlPoint2: CGPointMake(11.58, 120))
        outlinePath.addLineToPoint(CGPointMake(192, 120))
        outlinePath.addCurveToPoint(CGPointMake(200, 112), controlPoint1: CGPointMake(196.42, 120), controlPoint2: CGPointMake(200, 116.42))
        outlinePath.addLineToPoint(CGPointMake(200, 16))
        outlinePath.addCurveToPoint(CGPointMake(192, 8), controlPoint1: CGPointMake(200, 11.58), controlPoint2: CGPointMake(196.42, 8))
        outlinePath.closePath()
        outlinePath.moveToPoint(CGPointMake(208, 16))
        outlinePath.addLineToPoint(CGPointMake(208, 36))
        outlinePath.addLineToPoint(CGPointMake(216, 36))
        outlinePath.addCurveToPoint(CGPointMake(224, 44), controlPoint1: CGPointMake(220.42, 36), controlPoint2: CGPointMake(224, 39.58))
        outlinePath.addLineToPoint(CGPointMake(224, 84))
        outlinePath.addCurveToPoint(CGPointMake(216, 92), controlPoint1: CGPointMake(224, 88.42), controlPoint2: CGPointMake(220.42, 92))
        outlinePath.addLineToPoint(CGPointMake(208, 92))
        outlinePath.addLineToPoint(CGPointMake(208, 112))
        outlinePath.addCurveToPoint(CGPointMake(192, 128), controlPoint1: CGPointMake(208, 120.84), controlPoint2: CGPointMake(200.84, 128))
        outlinePath.addLineToPoint(CGPointMake(16, 128))
        outlinePath.addCurveToPoint(CGPointMake(0, 112), controlPoint1: CGPointMake(7.16, 128), controlPoint2: CGPointMake(0, 120.84))
        outlinePath.addLineToPoint(CGPointMake(0, 16))
        outlinePath.addCurveToPoint(CGPointMake(10.1, 1.12), controlPoint1: CGPointMake(0, 9.25), controlPoint2: CGPointMake(4.18, 3.47))
        outlinePath.addCurveToPoint(CGPointMake(16, 0), controlPoint1: CGPointMake(11.93, 0.4), controlPoint2: CGPointMake(13.92, 0))
        outlinePath.addLineToPoint(CGPointMake(192, 0))
        outlinePath.addCurveToPoint(CGPointMake(208, 16), controlPoint1: CGPointMake(200.84, 0), controlPoint2: CGPointMake(208, 7.16))
        outlinePath.closePath()
        batteryBaseColor.setFill()
        outlinePath.fill()


        //// Charge Drawing
        let chargePath = UIBezierPath()
        chargePath.moveToPoint(CGPointMake(16, 112))
        chargePath.addLineToPoint(CGPointMake(chargeMaxX, 112))
        chargePath.addLineToPoint(CGPointMake(chargeMaxX, 16))
        chargePath.addLineToPoint(CGPointMake(16, 16))
        chargePath.addLineToPoint(CGPointMake(16, 112))
        chargePath.closePath()
        batteryBaseColor.setFill()
        chargePath.fill()


        if (showCharging) {
            //// Lightning Bolt Drawing
            let lightningBoltPath = UIBezierPath()
            lightningBoltPath.moveToPoint(CGPointMake(130.91, 51.57))
            lightningBoltPath.addLineToPoint(CGPointMake(109.6, 51.57))
            lightningBoltPath.addLineToPoint(CGPointMake(120.26, 14.27))
            lightningBoltPath.addLineToPoint(CGPointMake(95.39, 14.27))
            lightningBoltPath.addLineToPoint(CGPointMake(81.18, 71.1))
            lightningBoltPath.addLineToPoint(CGPointMake(106.05, 71.1))
            lightningBoltPath.addLineToPoint(CGPointMake(100.72, 113.73))
            lightningBoltPath.addLineToPoint(CGPointMake(130.91, 51.57))
            lightningBoltPath.closePath()
            lightningBoltPath.usesEvenOddFillRule = true;

            batteryIconColor.setFill()
            lightningBoltPath.fill()
        }


        if (showPower) {
            //// Plug Drawing
            let plugPath = UIBezierPath()
            plugPath.moveToPoint(CGPointMake(161.55, 56))
            plugPath.addLineToPoint(CGPointMake(161.55, 48))
            plugPath.addLineToPoint(CGPointMake(141.55, 48))
            plugPath.addLineToPoint(CGPointMake(141.55, 36))
            plugPath.addLineToPoint(CGPointMake(107.55, 36))
            plugPath.addCurveToPoint(CGPointMake(104.35, 37.6), controlPoint1: CGPointMake(106.29, 36), controlPoint2: CGPointMake(105.1, 36.59))
            plugPath.addLineToPoint(CGPointMake(93.55, 52))
            plugPath.addLineToPoint(CGPointMake(53.55, 52))
            plugPath.addCurveToPoint(CGPointMake(49.55, 56), controlPoint1: CGPointMake(51.34, 52), controlPoint2: CGPointMake(49.55, 53.79))
            plugPath.addLineToPoint(CGPointMake(49.55, 72))
            plugPath.addCurveToPoint(CGPointMake(53.55, 76), controlPoint1: CGPointMake(49.55, 74.21), controlPoint2: CGPointMake(51.34, 76))
            plugPath.addLineToPoint(CGPointMake(93.55, 76))
            plugPath.addLineToPoint(CGPointMake(104.35, 90.4))
            plugPath.addCurveToPoint(CGPointMake(107.55, 92), controlPoint1: CGPointMake(105.1, 91.41), controlPoint2: CGPointMake(106.29, 92))
            plugPath.addLineToPoint(CGPointMake(141.55, 92))
            plugPath.addLineToPoint(CGPointMake(141.55, 80))
            plugPath.addLineToPoint(CGPointMake(161.55, 80))
            plugPath.addLineToPoint(CGPointMake(161.55, 72))
            plugPath.addLineToPoint(CGPointMake(141.55, 72))
            plugPath.addLineToPoint(CGPointMake(141.55, 56))
            plugPath.addLineToPoint(CGPointMake(161.55, 56))
            plugPath.closePath()
            batteryIconColor.setFill()
            plugPath.fill()
        }
    }

    public class func drawWifiIcon(iconColor iconColor: UIColor, connected: Bool) {

        //// Variable Declarations
        let notConnected = !connected

        if (connected) {
            //// Connected Icon Drawing
            let connectedIconPath = UIBezierPath()
            connectedIconPath.moveToPoint(CGPointMake(181.46, 43.82))
            connectedIconPath.addLineToPoint(CGPointMake(181.52, 43.79))
            connectedIconPath.addCurveToPoint(CGPointMake(91, 0), controlPoint1: CGPointMake(180.42, 42), controlPoint2: CGPointMake(153.85, 0))
            connectedIconPath.addCurveToPoint(CGPointMake(0.48, 43.79), controlPoint1: CGPointMake(28.15, 0), controlPoint2: CGPointMake(1.58, 42))
            connectedIconPath.addLineToPoint(CGPointMake(0.54, 43.82))
            connectedIconPath.addCurveToPoint(CGPointMake(0, 45.52), controlPoint1: CGPointMake(0.23, 44.33), controlPoint2: CGPointMake(0, 44.88))
            connectedIconPath.addCurveToPoint(CGPointMake(0.95, 47.81), controlPoint1: CGPointMake(0, 46.41), controlPoint2: CGPointMake(0.36, 47.23))
            connectedIconPath.addLineToPoint(CGPointMake(10.7, 57.56))
            connectedIconPath.addCurveToPoint(CGPointMake(13, 58.51), controlPoint1: CGPointMake(11.29, 58.15), controlPoint2: CGPointMake(12.1, 58.51))
            connectedIconPath.addCurveToPoint(CGPointMake(15.67, 57.02), controlPoint1: CGPointMake(14.14, 58.51), controlPoint2: CGPointMake(15.09, 57.9))
            connectedIconPath.addLineToPoint(CGPointMake(15.7, 57.04))
            connectedIconPath.addCurveToPoint(CGPointMake(91, 19.5), controlPoint1: CGPointMake(15.95, 56.67), controlPoint2: CGPointMake(41.31, 19.5))
            connectedIconPath.addCurveToPoint(CGPointMake(166.3, 57.05), controlPoint1: CGPointMake(140.55, 19.5), controlPoint2: CGPointMake(166.05, 56.67))
            connectedIconPath.addLineToPoint(CGPointMake(166.34, 57.02))
            connectedIconPath.addCurveToPoint(CGPointMake(169, 58.51), controlPoint1: CGPointMake(166.92, 57.9), controlPoint2: CGPointMake(167.87, 58.51))
            connectedIconPath.addCurveToPoint(CGPointMake(171.3, 57.56), controlPoint1: CGPointMake(169.9, 58.51), controlPoint2: CGPointMake(170.71, 58.15))
            connectedIconPath.addLineToPoint(CGPointMake(181.05, 47.81))
            connectedIconPath.addCurveToPoint(CGPointMake(182, 45.52), controlPoint1: CGPointMake(181.64, 47.23), controlPoint2: CGPointMake(182, 46.41))
            connectedIconPath.addCurveToPoint(CGPointMake(181.46, 43.82), controlPoint1: CGPointMake(182, 44.88), controlPoint2: CGPointMake(181.77, 44.33))
            connectedIconPath.closePath()
            connectedIconPath.moveToPoint(CGPointMake(129.29, 95.45))
            connectedIconPath.addCurveToPoint(CGPointMake(91, 77.99), controlPoint1: CGPointMake(128.72, 94.74), controlPoint2: CGPointMake(115.04, 77.99))
            connectedIconPath.addCurveToPoint(CGPointMake(52.71, 95.45), controlPoint1: CGPointMake(66.97, 77.99), controlPoint2: CGPointMake(53.28, 94.74))
            connectedIconPath.addLineToPoint(CGPointMake(52.76, 95.49))
            connectedIconPath.addCurveToPoint(CGPointMake(52, 97.51), controlPoint1: CGPointMake(52.31, 96.05), controlPoint2: CGPointMake(52, 96.73))
            connectedIconPath.addCurveToPoint(CGPointMake(52.95, 99.8), controlPoint1: CGPointMake(52, 98.4), controlPoint2: CGPointMake(52.36, 99.22))
            connectedIconPath.addLineToPoint(CGPointMake(62.7, 109.55))
            connectedIconPath.addCurveToPoint(CGPointMake(65, 110.5), controlPoint1: CGPointMake(63.29, 110.14), controlPoint2: CGPointMake(64.1, 110.5))
            connectedIconPath.addCurveToPoint(CGPointMake(67.56, 109.16), controlPoint1: CGPointMake(66.07, 110.5), controlPoint2: CGPointMake(66.97, 109.96))
            connectedIconPath.addLineToPoint(CGPointMake(67.6, 109.19))
            connectedIconPath.addCurveToPoint(CGPointMake(91, 97.48), controlPoint1: CGPointMake(67.68, 109.07), controlPoint2: CGPointMake(76.64, 97.48))
            connectedIconPath.addCurveToPoint(CGPointMake(114.4, 109.18), controlPoint1: CGPointMake(105.36, 97.48), controlPoint2: CGPointMake(114.32, 109.07))
            connectedIconPath.addLineToPoint(CGPointMake(114.43, 109.16))
            connectedIconPath.addCurveToPoint(CGPointMake(117, 110.5), controlPoint1: CGPointMake(115.03, 109.95), controlPoint2: CGPointMake(115.93, 110.5))
            connectedIconPath.addCurveToPoint(CGPointMake(119.3, 109.55), controlPoint1: CGPointMake(117.9, 110.5), controlPoint2: CGPointMake(118.71, 110.14))
            connectedIconPath.addLineToPoint(CGPointMake(129.05, 99.8))
            connectedIconPath.addCurveToPoint(CGPointMake(130, 97.51), controlPoint1: CGPointMake(129.64, 99.22), controlPoint2: CGPointMake(130, 98.4))
            connectedIconPath.addCurveToPoint(CGPointMake(129.24, 95.49), controlPoint1: CGPointMake(130, 96.73), controlPoint2: CGPointMake(129.69, 96.05))
            connectedIconPath.addLineToPoint(CGPointMake(129.29, 95.45))
            connectedIconPath.closePath()
            connectedIconPath.moveToPoint(CGPointMake(103.66, 122.02))
            connectedIconPath.addCurveToPoint(CGPointMake(91, 113.73), controlPoint1: CGPointMake(103.49, 121.69), controlPoint2: CGPointMake(99.41, 113.73))
            connectedIconPath.addCurveToPoint(CGPointMake(78.34, 122.02), controlPoint1: CGPointMake(82.59, 113.73), controlPoint2: CGPointMake(78.51, 121.69))
            connectedIconPath.addLineToPoint(CGPointMake(78.38, 122.05))
            connectedIconPath.addCurveToPoint(CGPointMake(78, 123.5), controlPoint1: CGPointMake(78.16, 122.49), controlPoint2: CGPointMake(78, 122.97))
            connectedIconPath.addCurveToPoint(CGPointMake(78.95, 125.8), controlPoint1: CGPointMake(78, 124.4), controlPoint2: CGPointMake(78.36, 125.21))
            connectedIconPath.addLineToPoint(CGPointMake(88.7, 135.55))
            connectedIconPath.addCurveToPoint(CGPointMake(91, 136.5), controlPoint1: CGPointMake(89.29, 136.14), controlPoint2: CGPointMake(90.1, 136.5))
            connectedIconPath.addCurveToPoint(CGPointMake(93.3, 135.55), controlPoint1: CGPointMake(91.9, 136.5), controlPoint2: CGPointMake(92.71, 136.14))
            connectedIconPath.addLineToPoint(CGPointMake(103.05, 125.8))
            connectedIconPath.addCurveToPoint(CGPointMake(104, 123.5), controlPoint1: CGPointMake(103.64, 125.21), controlPoint2: CGPointMake(104, 124.4))
            connectedIconPath.addCurveToPoint(CGPointMake(103.62, 122.05), controlPoint1: CGPointMake(104, 122.97), controlPoint2: CGPointMake(103.84, 122.49))
            connectedIconPath.addLineToPoint(CGPointMake(103.66, 122.02))
            connectedIconPath.closePath()
            connectedIconPath.moveToPoint(CGPointMake(155.31, 69.49))
            connectedIconPath.addCurveToPoint(CGPointMake(91, 38.99), controlPoint1: CGPointMake(154.35, 68.25), controlPoint2: CGPointMake(131.13, 38.99))
            connectedIconPath.addCurveToPoint(CGPointMake(26.69, 69.49), controlPoint1: CGPointMake(50.87, 38.99), controlPoint2: CGPointMake(27.65, 68.25))
            connectedIconPath.addLineToPoint(CGPointMake(26.74, 69.53))
            connectedIconPath.addCurveToPoint(CGPointMake(26, 71.51), controlPoint1: CGPointMake(26.3, 70.09), controlPoint2: CGPointMake(26, 70.76))
            connectedIconPath.addCurveToPoint(CGPointMake(26.95, 73.81), controlPoint1: CGPointMake(26, 72.41), controlPoint2: CGPointMake(26.36, 73.22))
            connectedIconPath.addLineToPoint(CGPointMake(36.7, 83.56))
            connectedIconPath.addCurveToPoint(CGPointMake(39, 84.51), controlPoint1: CGPointMake(37.29, 84.15), controlPoint2: CGPointMake(38.1, 84.51))
            connectedIconPath.addCurveToPoint(CGPointMake(41.56, 83.16), controlPoint1: CGPointMake(40.07, 84.51), controlPoint2: CGPointMake(40.97, 83.96))
            connectedIconPath.addLineToPoint(CGPointMake(41.6, 83.19))
            connectedIconPath.addCurveToPoint(CGPointMake(91, 58.49), controlPoint1: CGPointMake(41.79, 82.94), controlPoint2: CGPointMake(60.58, 58.49))
            connectedIconPath.addCurveToPoint(CGPointMake(140.4, 83.19), controlPoint1: CGPointMake(121.42, 58.49), controlPoint2: CGPointMake(140.22, 82.94))
            connectedIconPath.addLineToPoint(CGPointMake(140.44, 83.16))
            connectedIconPath.addCurveToPoint(CGPointMake(143, 84.51), controlPoint1: CGPointMake(141.03, 83.96), controlPoint2: CGPointMake(141.93, 84.51))
            connectedIconPath.addCurveToPoint(CGPointMake(145.3, 83.56), controlPoint1: CGPointMake(143.9, 84.51), controlPoint2: CGPointMake(144.71, 84.15))
            connectedIconPath.addLineToPoint(CGPointMake(155.05, 73.81))
            connectedIconPath.addCurveToPoint(CGPointMake(156, 71.51), controlPoint1: CGPointMake(155.64, 73.22), controlPoint2: CGPointMake(156, 72.41))
            connectedIconPath.addCurveToPoint(CGPointMake(155.27, 69.53), controlPoint1: CGPointMake(156, 70.76), controlPoint2: CGPointMake(155.7, 70.09))
            connectedIconPath.addLineToPoint(CGPointMake(155.31, 69.49))
            connectedIconPath.closePath()
            iconColor.setFill()
            connectedIconPath.fill()
        }


        if (notConnected) {
            //// Not Connected Icon Drawing
            let notConnectedIconPath = UIBezierPath()
            notConnectedIconPath.moveToPoint(CGPointMake(103.66, 122.02))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 113.73), controlPoint1: CGPointMake(103.49, 121.69), controlPoint2: CGPointMake(99.41, 113.73))
            notConnectedIconPath.addCurveToPoint(CGPointMake(78.34, 122.02), controlPoint1: CGPointMake(82.59, 113.73), controlPoint2: CGPointMake(78.51, 121.69))
            notConnectedIconPath.addLineToPoint(CGPointMake(78.38, 122.05))
            notConnectedIconPath.addCurveToPoint(CGPointMake(78, 123.5), controlPoint1: CGPointMake(78.16, 122.49), controlPoint2: CGPointMake(78, 122.97))
            notConnectedIconPath.addCurveToPoint(CGPointMake(78.95, 125.8), controlPoint1: CGPointMake(78, 124.4), controlPoint2: CGPointMake(78.36, 125.21))
            notConnectedIconPath.addLineToPoint(CGPointMake(88.7, 135.55))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 136.5), controlPoint1: CGPointMake(89.29, 136.14), controlPoint2: CGPointMake(90.1, 136.5))
            notConnectedIconPath.addCurveToPoint(CGPointMake(93.3, 135.55), controlPoint1: CGPointMake(91.9, 136.5), controlPoint2: CGPointMake(92.71, 136.14))
            notConnectedIconPath.addLineToPoint(CGPointMake(103.05, 125.8))
            notConnectedIconPath.addCurveToPoint(CGPointMake(104, 123.5), controlPoint1: CGPointMake(103.64, 125.21), controlPoint2: CGPointMake(104, 124.4))
            notConnectedIconPath.addCurveToPoint(CGPointMake(103.62, 122.05), controlPoint1: CGPointMake(104, 122.97), controlPoint2: CGPointMake(103.84, 122.49))
            notConnectedIconPath.addLineToPoint(CGPointMake(103.66, 122.02))
            notConnectedIconPath.closePath()
            notConnectedIconPath.moveToPoint(CGPointMake(91, 128.66))
            notConnectedIconPath.addLineToPoint(CGPointMake(85.46, 123.12))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 120.23), controlPoint1: CGPointMake(86.61, 121.79), controlPoint2: CGPointMake(88.47, 120.23))
            notConnectedIconPath.addCurveToPoint(CGPointMake(96.54, 123.12), controlPoint1: CGPointMake(93.53, 120.23), controlPoint2: CGPointMake(95.39, 121.79))
            notConnectedIconPath.addLineToPoint(CGPointMake(91, 128.66))
            notConnectedIconPath.closePath()
            notConnectedIconPath.moveToPoint(CGPointMake(129.29, 95.45))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 77.99), controlPoint1: CGPointMake(128.72, 94.74), controlPoint2: CGPointMake(115.03, 77.99))
            notConnectedIconPath.addCurveToPoint(CGPointMake(52.71, 95.45), controlPoint1: CGPointMake(66.96, 77.99), controlPoint2: CGPointMake(53.28, 94.74))
            notConnectedIconPath.addLineToPoint(CGPointMake(52.76, 95.49))
            notConnectedIconPath.addCurveToPoint(CGPointMake(52, 97.51), controlPoint1: CGPointMake(52.31, 96.05), controlPoint2: CGPointMake(52, 96.73))
            notConnectedIconPath.addCurveToPoint(CGPointMake(52.95, 99.8), controlPoint1: CGPointMake(52, 98.4), controlPoint2: CGPointMake(52.36, 99.22))
            notConnectedIconPath.addLineToPoint(CGPointMake(62.7, 109.55))
            notConnectedIconPath.addCurveToPoint(CGPointMake(65, 110.5), controlPoint1: CGPointMake(63.29, 110.14), controlPoint2: CGPointMake(64.1, 110.5))
            notConnectedIconPath.addCurveToPoint(CGPointMake(67.56, 109.16), controlPoint1: CGPointMake(66.07, 110.5), controlPoint2: CGPointMake(66.97, 109.96))
            notConnectedIconPath.addLineToPoint(CGPointMake(67.6, 109.19))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 97.48), controlPoint1: CGPointMake(67.68, 109.07), controlPoint2: CGPointMake(76.64, 97.48))
            notConnectedIconPath.addCurveToPoint(CGPointMake(114.4, 109.18), controlPoint1: CGPointMake(105.36, 97.48), controlPoint2: CGPointMake(114.32, 109.07))
            notConnectedIconPath.addLineToPoint(CGPointMake(114.43, 109.16))
            notConnectedIconPath.addCurveToPoint(CGPointMake(117, 110.5), controlPoint1: CGPointMake(115.03, 109.95), controlPoint2: CGPointMake(115.93, 110.5))
            notConnectedIconPath.addCurveToPoint(CGPointMake(119.3, 109.55), controlPoint1: CGPointMake(117.9, 110.5), controlPoint2: CGPointMake(118.71, 110.14))
            notConnectedIconPath.addLineToPoint(CGPointMake(129.05, 99.8))
            notConnectedIconPath.addCurveToPoint(CGPointMake(130, 97.51), controlPoint1: CGPointMake(129.64, 99.22), controlPoint2: CGPointMake(130, 98.4))
            notConnectedIconPath.addCurveToPoint(CGPointMake(129.24, 95.49), controlPoint1: CGPointMake(130, 96.73), controlPoint2: CGPointMake(129.69, 96.05))
            notConnectedIconPath.addLineToPoint(CGPointMake(129.29, 95.45))
            notConnectedIconPath.closePath()
            notConnectedIconPath.moveToPoint(CGPointMake(117.15, 102.51))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 90.98), controlPoint1: CGPointMake(113.04, 98.36), controlPoint2: CGPointMake(103.97, 90.98))
            notConnectedIconPath.addCurveToPoint(CGPointMake(64.85, 102.51), controlPoint1: CGPointMake(78.03, 90.98), controlPoint2: CGPointMake(68.96, 98.36))
            notConnectedIconPath.addLineToPoint(CGPointMake(59.76, 97.42))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 84.48), controlPoint1: CGPointMake(63.97, 93.3), controlPoint2: CGPointMake(74.86, 84.48))
            notConnectedIconPath.addCurveToPoint(CGPointMake(122.23, 97.43), controlPoint1: CGPointMake(107.05, 84.48), controlPoint2: CGPointMake(118, 93.31))
            notConnectedIconPath.addLineToPoint(CGPointMake(117.15, 102.51))
            notConnectedIconPath.closePath()
            notConnectedIconPath.moveToPoint(CGPointMake(155.31, 69.49))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 38.99), controlPoint1: CGPointMake(154.35, 68.25), controlPoint2: CGPointMake(131.13, 38.99))
            notConnectedIconPath.addCurveToPoint(CGPointMake(26.69, 69.49), controlPoint1: CGPointMake(50.87, 38.99), controlPoint2: CGPointMake(27.65, 68.25))
            notConnectedIconPath.addLineToPoint(CGPointMake(26.74, 69.53))
            notConnectedIconPath.addCurveToPoint(CGPointMake(26, 71.51), controlPoint1: CGPointMake(26.3, 70.09), controlPoint2: CGPointMake(26, 70.76))
            notConnectedIconPath.addCurveToPoint(CGPointMake(26.95, 73.81), controlPoint1: CGPointMake(26, 72.41), controlPoint2: CGPointMake(26.36, 73.22))
            notConnectedIconPath.addLineToPoint(CGPointMake(36.7, 83.56))
            notConnectedIconPath.addCurveToPoint(CGPointMake(39, 84.51), controlPoint1: CGPointMake(37.29, 84.15), controlPoint2: CGPointMake(38.1, 84.51))
            notConnectedIconPath.addCurveToPoint(CGPointMake(41.56, 83.16), controlPoint1: CGPointMake(40.07, 84.51), controlPoint2: CGPointMake(40.97, 83.96))
            notConnectedIconPath.addLineToPoint(CGPointMake(41.6, 83.19))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 58.49), controlPoint1: CGPointMake(41.78, 82.94), controlPoint2: CGPointMake(60.58, 58.49))
            notConnectedIconPath.addCurveToPoint(CGPointMake(140.4, 83.19), controlPoint1: CGPointMake(121.42, 58.49), controlPoint2: CGPointMake(140.22, 82.94))
            notConnectedIconPath.addLineToPoint(CGPointMake(140.44, 83.16))
            notConnectedIconPath.addCurveToPoint(CGPointMake(143, 84.51), controlPoint1: CGPointMake(141.03, 83.96), controlPoint2: CGPointMake(141.93, 84.51))
            notConnectedIconPath.addCurveToPoint(CGPointMake(145.3, 83.56), controlPoint1: CGPointMake(143.9, 84.51), controlPoint2: CGPointMake(144.71, 84.15))
            notConnectedIconPath.addLineToPoint(CGPointMake(155.05, 73.81))
            notConnectedIconPath.addCurveToPoint(CGPointMake(156, 71.51), controlPoint1: CGPointMake(155.64, 73.22), controlPoint2: CGPointMake(156, 72.41))
            notConnectedIconPath.addCurveToPoint(CGPointMake(155.26, 69.53), controlPoint1: CGPointMake(156, 70.76), controlPoint2: CGPointMake(155.7, 70.09))
            notConnectedIconPath.addLineToPoint(CGPointMake(155.31, 69.49))
            notConnectedIconPath.closePath()
            notConnectedIconPath.moveToPoint(CGPointMake(143.22, 76.44))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 51.99), controlPoint1: CGPointMake(136.94, 69.43), controlPoint2: CGPointMake(118.55, 51.99))
            notConnectedIconPath.addCurveToPoint(CGPointMake(38.78, 76.44), controlPoint1: CGPointMake(63.45, 51.99), controlPoint2: CGPointMake(45.06, 69.43))
            notConnectedIconPath.addLineToPoint(CGPointMake(33.69, 71.35))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 45.49), controlPoint1: CGPointMake(39.68, 64.86), controlPoint2: CGPointMake(60.13, 45.49))
            notConnectedIconPath.addCurveToPoint(CGPointMake(148.31, 71.35), controlPoint1: CGPointMake(121.87, 45.49), controlPoint2: CGPointMake(142.32, 64.86))
            notConnectedIconPath.addLineToPoint(CGPointMake(143.22, 76.44))
            notConnectedIconPath.closePath()
            notConnectedIconPath.moveToPoint(CGPointMake(181.46, 43.82))
            notConnectedIconPath.addLineToPoint(CGPointMake(181.52, 43.79))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 0), controlPoint1: CGPointMake(180.42, 42), controlPoint2: CGPointMake(153.85, 0))
            notConnectedIconPath.addCurveToPoint(CGPointMake(0.48, 43.79), controlPoint1: CGPointMake(28.15, 0), controlPoint2: CGPointMake(1.58, 42))
            notConnectedIconPath.addLineToPoint(CGPointMake(0.54, 43.82))
            notConnectedIconPath.addCurveToPoint(CGPointMake(0, 45.52), controlPoint1: CGPointMake(0.23, 44.33), controlPoint2: CGPointMake(0, 44.88))
            notConnectedIconPath.addCurveToPoint(CGPointMake(0.95, 47.81), controlPoint1: CGPointMake(0, 46.41), controlPoint2: CGPointMake(0.36, 47.23))
            notConnectedIconPath.addLineToPoint(CGPointMake(10.7, 57.56))
            notConnectedIconPath.addCurveToPoint(CGPointMake(13, 58.51), controlPoint1: CGPointMake(11.29, 58.15), controlPoint2: CGPointMake(12.1, 58.51))
            notConnectedIconPath.addCurveToPoint(CGPointMake(15.67, 57.02), controlPoint1: CGPointMake(14.14, 58.51), controlPoint2: CGPointMake(15.09, 57.9))
            notConnectedIconPath.addLineToPoint(CGPointMake(15.7, 57.04))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 19.5), controlPoint1: CGPointMake(15.95, 56.67), controlPoint2: CGPointMake(41.31, 19.5))
            notConnectedIconPath.addCurveToPoint(CGPointMake(166.3, 57.05), controlPoint1: CGPointMake(140.55, 19.5), controlPoint2: CGPointMake(166.05, 56.67))
            notConnectedIconPath.addLineToPoint(CGPointMake(166.34, 57.02))
            notConnectedIconPath.addCurveToPoint(CGPointMake(169, 58.51), controlPoint1: CGPointMake(166.92, 57.9), controlPoint2: CGPointMake(167.87, 58.51))
            notConnectedIconPath.addCurveToPoint(CGPointMake(171.3, 57.56), controlPoint1: CGPointMake(169.9, 58.51), controlPoint2: CGPointMake(170.71, 58.15))
            notConnectedIconPath.addLineToPoint(CGPointMake(181.05, 47.81))
            notConnectedIconPath.addCurveToPoint(CGPointMake(182, 45.52), controlPoint1: CGPointMake(181.64, 47.23), controlPoint2: CGPointMake(182, 46.41))
            notConnectedIconPath.addCurveToPoint(CGPointMake(181.46, 43.82), controlPoint1: CGPointMake(182, 44.88), controlPoint2: CGPointMake(181.77, 44.33))
            notConnectedIconPath.closePath()
            notConnectedIconPath.moveToPoint(CGPointMake(169.37, 50.3))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 13), controlPoint1: CGPointMake(161.79, 40.74), controlPoint2: CGPointMake(135.93, 13))
            notConnectedIconPath.addCurveToPoint(CGPointMake(12.63, 50.3), controlPoint1: CGPointMake(46.07, 13), controlPoint2: CGPointMake(20.21, 40.74))
            notConnectedIconPath.addLineToPoint(CGPointMake(7.46, 45.13))
            notConnectedIconPath.addCurveToPoint(CGPointMake(26.15, 26.8), controlPoint1: CGPointMake(10.04, 41.63), controlPoint2: CGPointMake(16.15, 34.18))
            notConnectedIconPath.addCurveToPoint(CGPointMake(91, 6.5), controlPoint1: CGPointMake(38.7, 17.54), controlPoint2: CGPointMake(60.13, 6.5))
            notConnectedIconPath.addCurveToPoint(CGPointMake(155.85, 26.8), controlPoint1: CGPointMake(121.87, 6.5), controlPoint2: CGPointMake(143.3, 17.54))
            notConnectedIconPath.addCurveToPoint(CGPointMake(174.54, 45.13), controlPoint1: CGPointMake(165.85, 34.18), controlPoint2: CGPointMake(171.96, 41.63))
            notConnectedIconPath.addLineToPoint(CGPointMake(169.37, 50.3))
            notConnectedIconPath.closePath()
            iconColor.setFill()
            notConnectedIconPath.fill()
        }
    }

    public class func drawWifiStatus(iconColor iconColor: UIColor, connected: Bool, containingFrame: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()


        //// Variable Declarations
        let squaredContainingFrameSize = CGSizeMake(min(containingFrame.size.width, containingFrame.size.height), min(containingFrame.size.width, containingFrame.size.height))
        let squaredContainingFrame = CGRectMake(containingFrame.origin.x + (containingFrame.size.width - squaredContainingFrameSize.width) / 2.0, containingFrame.origin.y + (containingFrame.size.height - squaredContainingFrameSize.height) / 2.0, squaredContainingFrameSize.width, squaredContainingFrameSize.height)
        let wifiFrame = CGRectMake(squaredContainingFrame.origin.x, squaredContainingFrame.origin.y + (squaredContainingFrame.size.height - squaredContainingFrame.size.width * 4.25 / 5.69) / 2.0, squaredContainingFrame.size.width, squaredContainingFrame.size.width * 4.25 / 5.69)

        //// Frames
        let frame = CGRectMake(wifiFrame.origin.x, wifiFrame.origin.y, wifiFrame.size.width, wifiFrame.size.height)


        //// Symbol Drawing
        let symbolRect = CGRectMake(frame.minX + floor(frame.width * 0.00000 + 0.5), frame.minY + floor(frame.height * 0.00000 - 0.5) + 1, floor(frame.width * 1.00000 + 0.5) - floor(frame.width * 0.00000 + 0.5), floor(frame.height * 1.00000 + 0.05) - floor(frame.height * 0.00000 - 0.5) - 0.55)
        CGContextSaveGState(context)
        UIRectClip(symbolRect)
        CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)
        CGContextScaleCTM(context, symbolRect.size.width / 182, symbolRect.size.height / 136)

        DrawingKit.drawWifiIcon(iconColor: iconColor, connected: connected)
        CGContextRestoreGState(context)
    }

    public class func drawDiamondPath(frame frame: CGRect, contentColor: UIColor) {

        //// Shape Drawing
        let shapePath = UIBezierPath()
        shapePath.moveToPoint(CGPointMake(frame.minX + 0.00000 * frame.width, frame.minY + 0.50000 * frame.height))
        shapePath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 0.00000 * frame.height))
        shapePath.addLineToPoint(CGPointMake(frame.minX + 1.00000 * frame.width, frame.minY + 0.50000 * frame.height))
        shapePath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 1.00000 * frame.height))
        shapePath.addLineToPoint(CGPointMake(frame.minX + 0.00000 * frame.width, frame.minY + 0.50000 * frame.height))
        shapePath.closePath()
        contentColor.setFill()
        shapePath.fill()
    }

    public class func drawOvalPath(frame frame: CGRect, contentColor: UIColor) {

        //// Shape Drawing
        let shapePath = UIBezierPath(ovalInRect: CGRectMake(frame.minX, frame.minY, frame.width, frame.height))
        contentColor.setFill()
        shapePath.fill()
    }

    public class func drawTrianglePath(frame frame: CGRect, contentColor: UIColor) {

        //// Shape Drawing
        let shapePath = UIBezierPath()
        shapePath.moveToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 0.00000 * frame.height))
        shapePath.addLineToPoint(CGPointMake(frame.minX + 0.75000 * frame.width, frame.minY + 0.50000 * frame.height))
        shapePath.addLineToPoint(CGPointMake(frame.minX + 1.00000 * frame.width, frame.minY + 1.00000 * frame.height))
        shapePath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 1.00000 * frame.height))
        shapePath.addLineToPoint(CGPointMake(frame.minX + 0.00000 * frame.width, frame.minY + 1.00000 * frame.height))
        shapePath.addLineToPoint(CGPointMake(frame.minX + 0.25000 * frame.width, frame.minY + 0.50000 * frame.height))
        shapePath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 0.00000 * frame.height))
        shapePath.closePath()
        contentColor.setFill()
        shapePath.fill()
    }

    public class func drawRectangularPath(frame frame: CGRect, contentColor: UIColor) {

        //// Shape Drawing
        let shapePath = UIBezierPath(rect: CGRectMake(frame.minX, frame.minY, frame.width, frame.height))
        contentColor.setFill()
        shapePath.fill()
    }

    public class func drawRoundedRectanglePath(frame frame: CGRect, contentColor: UIColor, radius: CGFloat) {

        //// Shape Drawing
        let shapePath = UIBezierPath(roundedRect: CGRectMake(frame.minX, frame.minY, frame.width, frame.height), cornerRadius: radius)
        contentColor.setFill()
        shapePath.fill()
    }

    public class func drawRectangleGloss(frame frame: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Rectangle Drawing
        let rectangleRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
        let rectanglePath = UIBezierPath(rect: rectangleRect)
        CGContextSaveGState(context)
        rectanglePath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
            CGPointMake(rectangleRect.midX + 0 * rectangleRect.width / 200, rectangleRect.midY + 100 * rectangleRect.height / 200),
            CGPointMake(rectangleRect.midX + 0 * rectangleRect.width / 200, rectangleRect.midY + 0 * rectangleRect.height / 200),
            [.DrawsBeforeStartLocation, .DrawsAfterEndLocation])
        CGContextRestoreGState(context)
    }

    public class func drawRoundedGloss(frame frame: CGRect, radius: CGFloat) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Rounded Drawing
        let roundedRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
        let roundedPath = UIBezierPath(roundedRect: roundedRect, cornerRadius: radius)
        CGContextSaveGState(context)
        roundedPath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
            CGPointMake(roundedRect.midX + 0 * roundedRect.width / 200, roundedRect.midY + 100 * roundedRect.height / 200),
            CGPointMake(roundedRect.midX + 0 * roundedRect.width / 200, roundedRect.midY + 0 * roundedRect.height / 200),
            [.DrawsBeforeStartLocation, .DrawsAfterEndLocation])
        CGContextRestoreGState(context)
    }

    public class func drawOvalGloss(frame frame: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Oval Drawing
        let ovalRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
        let ovalPath = UIBezierPath(ovalInRect: ovalRect)
        CGContextSaveGState(context)
        ovalPath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
            CGPointMake(ovalRect.midX + 0 * ovalRect.width / 200, ovalRect.midY + 100 * ovalRect.height / 200),
            CGPointMake(ovalRect.midX + 0 * ovalRect.width / 200, ovalRect.midY + 0 * ovalRect.height / 200),
            [.DrawsBeforeStartLocation, .DrawsAfterEndLocation])
        CGContextRestoreGState(context)
    }

    public class func drawDiamondGloss(frame frame: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Diamond Drawing
        let diamondPath = UIBezierPath()
        diamondPath.moveToPoint(CGPointMake(frame.minX + 0.00000 * frame.width, frame.minY + 0.50000 * frame.height))
        diamondPath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 0.00000 * frame.height))
        diamondPath.addLineToPoint(CGPointMake(frame.minX + 1.00000 * frame.width, frame.minY + 0.50000 * frame.height))
        diamondPath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 1.00000 * frame.height))
        diamondPath.addLineToPoint(CGPointMake(frame.minX + 0.00000 * frame.width, frame.minY + 0.50000 * frame.height))
        diamondPath.closePath()
        CGContextSaveGState(context)
        diamondPath.addClip()
        let diamondBounds: CGRect = CGPathGetPathBoundingBox(diamondPath.CGPath)
        CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
            CGPointMake(diamondBounds.midX + 0 * diamondBounds.width / 200, diamondBounds.midY + 100 * diamondBounds.height / 200),
            CGPointMake(diamondBounds.midX + 0 * diamondBounds.width / 200, diamondBounds.midY + 0 * diamondBounds.height / 200),
            [.DrawsBeforeStartLocation, .DrawsAfterEndLocation])
        CGContextRestoreGState(context)
    }

    public class func drawTriangleGloss(frame frame: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Triangle Drawing
        let trianglePath = UIBezierPath()
        trianglePath.moveToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 0.00000 * frame.height))
        trianglePath.addLineToPoint(CGPointMake(frame.minX + 0.75000 * frame.width, frame.minY + 0.50000 * frame.height))
        trianglePath.addLineToPoint(CGPointMake(frame.minX + 1.00000 * frame.width, frame.minY + 1.00000 * frame.height))
        trianglePath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 1.00000 * frame.height))
        trianglePath.addLineToPoint(CGPointMake(frame.minX + -0.00000 * frame.width, frame.minY + 1.00000 * frame.height))
        trianglePath.addLineToPoint(CGPointMake(frame.minX + 0.25000 * frame.width, frame.minY + 0.50000 * frame.height))
        trianglePath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 0.00000 * frame.height))
        trianglePath.closePath()
        CGContextSaveGState(context)
        trianglePath.addClip()
        let triangleBounds: CGRect = CGPathGetPathBoundingBox(trianglePath.CGPath)
        CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
            CGPointMake(triangleBounds.midX + 0 * triangleBounds.width / 200, triangleBounds.midY + 100 * triangleBounds.height / 200),
            CGPointMake(triangleBounds.midX + -0.21 * triangleBounds.width / 200, triangleBounds.midY + 50.3 * triangleBounds.height / 200),
            [.DrawsBeforeStartLocation, .DrawsAfterEndLocation])
        CGContextRestoreGState(context)
    }

    public class func drawButton(color color: UIColor, contentColor: UIColor, iconImage: UIImage, radius: CGFloat, text: String, applyGloss: Bool, baseShape: String, rect: CGRect, highlighted: Bool, shouldDrawIcon: Bool, shouldDrawText: Bool) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()


        //// Variable Declarations
        let iconSize = iconImage.size
        let widthBasedFontSize: CGFloat = rect.size.width / CGFloat(text.utf16.count)
        let heightBasedFontSize: CGFloat = rect.size.height
        let appliedFontSize: CGFloat = min(widthBasedFontSize, heightBasedFontSize)
        let offsetIcon = CGPointMake((rect.size.width - iconSize.width) / 2.0, (rect.size.height - iconSize.height) / 2.0)
        let contentAndBaseRect = CGRectMake(4, 4, rect.size.width - 8, rect.size.height - 8)
        let bleedGroupRect = CGRectMake(contentAndBaseRect.origin.x + 4, contentAndBaseRect.origin.y + 4, contentAndBaseRect.size.width - 8, contentAndBaseRect.size.height - 8)
        let contentOuterShadow = highlighted ? NSShadow(color: contentColor, offset: CGSizeMake(0, -0), blurRadius: 5) : NSShadow(color: UIColor(red: 0, green: 0, blue: 0, alpha: 0), offset: CGSizeMake(0, -0), blurRadius: 0)

        //// Frames
        let frame = CGRectMake(rect.origin.x, rect.origin.y, rect.size.width, rect.size.height)

        //// Subframes
        let glossOverlayGroup: CGRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)


        //// Bleed
        //// Bleed Base Drawing
        let bleedBaseRect = CGRectMake(bleedGroupRect.origin.x, bleedGroupRect.origin.y, bleedGroupRect.size.width, bleedGroupRect.size.height)
        CGContextSaveGState(context)
        UIRectClip(bleedBaseRect)
        CGContextTranslateCTM(context, bleedBaseRect.origin.x, bleedBaseRect.origin.y)

        DrawingKit.drawSelectedButtonShape(frame: CGRectMake(0, 0, bleedBaseRect.size.width, bleedBaseRect.size.height), contentColor: contentColor, radius: radius, baseShape: baseShape)
        CGContextRestoreGState(context)




        //// Content And Base Group
        CGContextSaveGState(context)
        CGContextBeginTransparencyLayer(context, nil)


        //// Base Group
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, contentOuterShadow.shadowOffset, contentOuterShadow.shadowBlurRadius, (contentOuterShadow.shadowColor as! UIColor).CGColor)
        CGContextBeginTransparencyLayer(context, nil)


        //// Button Base Drawing
        let buttonBaseRect = CGRectMake(contentAndBaseRect.origin.x, contentAndBaseRect.origin.y, contentAndBaseRect.size.width, contentAndBaseRect.size.height)
        CGContextSaveGState(context)
        UIRectClip(buttonBaseRect)
        CGContextTranslateCTM(context, buttonBaseRect.origin.x, buttonBaseRect.origin.y)

        DrawingKit.drawSelectedButtonBase(frame: CGRectMake(0, 0, buttonBaseRect.size.width, buttonBaseRect.size.height), color: color, contentColor: contentColor, radius: radius, baseShape: baseShape)
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)


        //// Cutout Group
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, .DestinationOut)
        CGContextBeginTransparencyLayer(context, nil)


        if (shouldDrawIcon) {
            //// Icon Group
            CGContextSaveGState(context)
            CGContextTranslateCTM(context, offsetIcon.x, offsetIcon.y)

            CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, (DrawingKit.innerShadow.shadowColor as! UIColor).CGColor)
            CGContextSetAlpha(context, 0.9)
            CGContextBeginTransparencyLayer(context, nil)


            //// Icon Path Drawing
            let iconPathPath = UIBezierPath(rect: CGRectMake(0, 0, 100, 100))
            CGContextSaveGState(context)
            CGContextSetShadowWithColor(context, contentOuterShadow.shadowOffset, contentOuterShadow.shadowBlurRadius, (contentOuterShadow.shadowColor as! UIColor).CGColor)
            CGContextBeginTransparencyLayer(context, nil)
            CGContextSaveGState(context)
            iconPathPath.addClip()
            iconImage.drawInRect(CGRectMake(0, 0, iconImage.size.width, iconImage.size.height))
            CGContextRestoreGState(context)
            CGContextEndTransparencyLayer(context)
            CGContextRestoreGState(context)



            CGContextEndTransparencyLayer(context)

            CGContextRestoreGState(context)
        }


        if (shouldDrawText) {
            //// Label Group
            //// label Drawing
            let labelRect = CGRectMake(bleedGroupRect.origin.x, bleedGroupRect.origin.y, bleedGroupRect.size.width, bleedGroupRect.size.height)
            CGContextSaveGState(context)
            CGContextSetShadowWithColor(context, contentOuterShadow.shadowOffset, contentOuterShadow.shadowBlurRadius, (contentOuterShadow.shadowColor as! UIColor).CGColor)
            let labelStyle = NSParagraphStyle.defaultParagraphStyle().mutableCopy() as! NSMutableParagraphStyle
            labelStyle.alignment = NSTextAlignment.Center

            let labelFontAttributes = [NSFontAttributeName: UIFont(name: "HelveticaNeue-Bold", size: appliedFontSize)!, NSForegroundColorAttributeName: UIColor.blackColor(), NSParagraphStyleAttributeName: labelStyle]

            let labelTextHeight: CGFloat = NSString(string: text).boundingRectWithSize(CGSizeMake(labelRect.width, CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: labelFontAttributes, context: nil).size.height
            CGContextSaveGState(context)
            CGContextClipToRect(context, labelRect);
            NSString(string: text).drawInRect(CGRectMake(labelRect.minX, labelRect.minY + (labelRect.height - labelTextHeight) / 2, labelRect.width, labelTextHeight), withAttributes: labelFontAttributes)
            CGContextRestoreGState(context)
            CGContextRestoreGState(context)



        }


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)


        if (applyGloss) {
            //// Gloss Overlay Group
            CGContextSaveGState(context)
            CGContextSetAlpha(context, 0.1)
            CGContextSetBlendMode(context, .SourceAtop)
            CGContextBeginTransparencyLayer(context, nil)


            //// Gloss Overlay Drawing
            let glossOverlayRect = CGRectMake(glossOverlayGroup.minX + floor(glossOverlayGroup.width * 0.00000 + 0.5), glossOverlayGroup.minY + floor(glossOverlayGroup.height * 0.00000 + 0.5), floor(glossOverlayGroup.width * 1.00000 + 0.5) - floor(glossOverlayGroup.width * 0.00000 + 0.5), floor(glossOverlayGroup.height * 1.00000 + 0.5) - floor(glossOverlayGroup.height * 0.00000 + 0.5))
            CGContextSaveGState(context)
            UIRectClip(glossOverlayRect)
            CGContextTranslateCTM(context, glossOverlayRect.origin.x, glossOverlayRect.origin.y)

            DrawingKit.drawSelectedGloss(frame: CGRectMake(0, 0, glossOverlayRect.size.width, glossOverlayRect.size.height), radius: radius, baseShape: baseShape)
            CGContextRestoreGState(context)


            CGContextEndTransparencyLayer(context)
            CGContextRestoreGState(context)
        }
    }

    public class func drawSelectedButtonShape(frame frame: CGRect, contentColor: UIColor, radius: CGFloat, baseShape: String) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()


        //// Variable Declarations
        let useOvalBase = baseShape == "oval"
        let useDiamondBase = baseShape == "diamond"
        let useTriangleBase = baseShape == "triangle"
        let useRoundedBase = baseShape == "rounded-rectangle"
        let useRectangularBase = baseShape == "rectangle"

        if (useDiamondBase) {
            //// Diamond Drawing
            let diamondRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(diamondRect)
            CGContextTranslateCTM(context, diamondRect.origin.x, diamondRect.origin.y)

            DrawingKit.drawDiamondPath(frame: CGRectMake(0, 0, diamondRect.size.width, diamondRect.size.height), contentColor: contentColor)
            CGContextRestoreGState(context)
        }


        if (useOvalBase) {
            //// Oval Drawing
            let ovalRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(ovalRect)
            CGContextTranslateCTM(context, ovalRect.origin.x, ovalRect.origin.y)

            DrawingKit.drawOvalPath(frame: CGRectMake(0, 0, ovalRect.size.width, ovalRect.size.height), contentColor: contentColor)
            CGContextRestoreGState(context)
        }


        if (useTriangleBase) {
            //// Triangle Drawing
            let triangleRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(triangleRect)
            CGContextTranslateCTM(context, triangleRect.origin.x, triangleRect.origin.y)

            DrawingKit.drawTrianglePath(frame: CGRectMake(0, 0, triangleRect.size.width, triangleRect.size.height), contentColor: contentColor)
            CGContextRestoreGState(context)
        }


        if (useRectangularBase) {
            //// Rectangle Drawing
            let rectangleRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(rectangleRect)
            CGContextTranslateCTM(context, rectangleRect.origin.x, rectangleRect.origin.y)

            DrawingKit.drawRectangularPath(frame: CGRectMake(0, 0, rectangleRect.size.width, rectangleRect.size.height), contentColor: contentColor)
            CGContextRestoreGState(context)
        }


        if (useRoundedBase) {
            //// Rounded Drawing
            let roundedRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(roundedRect)
            CGContextTranslateCTM(context, roundedRect.origin.x, roundedRect.origin.y)

            DrawingKit.drawRoundedRectanglePath(frame: CGRectMake(0, 0, roundedRect.size.width, roundedRect.size.height), contentColor: contentColor, radius: radius)
            CGContextRestoreGState(context)
        }
    }

    public class func drawSelectedButtonBase(frame frame: CGRect, color: UIColor, contentColor: UIColor, radius: CGFloat, baseShape: String) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()


        //// Variable Declarations
        let useOvalBase = baseShape == "oval"
        let useDiamondBase = baseShape == "diamond"
        let useTriangleBase = baseShape == "triangle"
        let useRoundedBase = baseShape == "rounded"
        let useRectangularBase = baseShape == "rectangle"

        if (useDiamondBase) {
            //// Diamond Drawing
            let diamondRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(diamondRect)
            CGContextTranslateCTM(context, diamondRect.origin.x, diamondRect.origin.y)
            CGContextScaleCTM(context, diamondRect.size.width / 200, diamondRect.size.height / 200)

            DrawingKit.drawDiamondButtonBase(color: color, contentColor: contentColor, rect: CGRectMake(0, 0, 200, 200))
            CGContextRestoreGState(context)
        }


        if (useTriangleBase) {
            //// Triangle Drawing
            let triangleRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(triangleRect)
            CGContextTranslateCTM(context, triangleRect.origin.x, triangleRect.origin.y)
            CGContextScaleCTM(context, triangleRect.size.width / 200, triangleRect.size.height / 200)

            DrawingKit.drawTriangleButtonBase(color: color, contentColor: contentColor, rect: CGRectMake(0, 0, 200, 200))
            CGContextRestoreGState(context)
        }


        if (useOvalBase) {
            //// Oval Drawing
            let ovalRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(ovalRect)
            CGContextTranslateCTM(context, ovalRect.origin.x, ovalRect.origin.y)
            CGContextScaleCTM(context, ovalRect.size.width / 200, ovalRect.size.height / 200)

            DrawingKit.drawOvalButtonBase(color: color, contentColor: contentColor, rect: CGRectMake(0, 0, 200, 200))
            CGContextRestoreGState(context)
        }


        if (useRectangularBase) {
            //// Rectangle Drawing
            let rectangleRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(rectangleRect)
            CGContextTranslateCTM(context, rectangleRect.origin.x, rectangleRect.origin.y)
            CGContextScaleCTM(context, rectangleRect.size.width / 200, rectangleRect.size.height / 200)

            DrawingKit.drawRectangularButtonBase(color: color, contentColor: contentColor, rect: CGRectMake(0, 0, 200, 200))
            CGContextRestoreGState(context)
        }


        if (useRoundedBase) {
            //// Rounded Drawing
            let roundedRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(roundedRect)
            CGContextTranslateCTM(context, roundedRect.origin.x, roundedRect.origin.y)
            CGContextScaleCTM(context, roundedRect.size.width / 200, roundedRect.size.height / 200)

            DrawingKit.drawRoundedButtonBase(color: color, contentColor: contentColor, radius: radius, rect: CGRectMake(0, 0, 200, 200))
            CGContextRestoreGState(context)
        }
    }

    public class func drawSelectedGloss(frame frame: CGRect, radius: CGFloat, baseShape: String) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()


        //// Variable Declarations
        let useOvalBase = baseShape == "oval"
        let useDiamondBase = baseShape == "diamond"
        let useTriangleBase = baseShape == "triangle"
        let useRoundedBase = baseShape == "rounded"
        let useRectangularBase = baseShape == "rectangle"

        if (useRoundedBase) {
            //// Rounded Drawing
            let roundedRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(roundedRect)
            CGContextTranslateCTM(context, roundedRect.origin.x, roundedRect.origin.y)

            DrawingKit.drawRoundedGloss(frame: CGRectMake(0, 0, roundedRect.size.width, roundedRect.size.height), radius: radius)
            CGContextRestoreGState(context)
        }


        if (useRectangularBase) {
            //// Rectangle Drawing
            let rectangleRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(rectangleRect)
            CGContextTranslateCTM(context, rectangleRect.origin.x, rectangleRect.origin.y)

            DrawingKit.drawRectangleGloss(frame: CGRectMake(0, 0, rectangleRect.size.width, rectangleRect.size.height))
            CGContextRestoreGState(context)
        }


        if (useOvalBase) {
            //// Oval Drawing
            let ovalRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(ovalRect)
            CGContextTranslateCTM(context, ovalRect.origin.x, ovalRect.origin.y)

            DrawingKit.drawOvalGloss(frame: CGRectMake(0, 0, ovalRect.size.width, ovalRect.size.height))
            CGContextRestoreGState(context)
        }


        if (useDiamondBase) {
            //// Diamond Drawing
            let diamondRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(diamondRect)
            CGContextTranslateCTM(context, diamondRect.origin.x, diamondRect.origin.y)

            DrawingKit.drawDiamondGloss(frame: CGRectMake(0, 0, diamondRect.size.width, diamondRect.size.height))
            CGContextRestoreGState(context)
        }


        if (useTriangleBase) {
            //// Triangle Drawing
            let triangleRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)
            CGContextSaveGState(context)
            UIRectClip(triangleRect)
            CGContextTranslateCTM(context, triangleRect.origin.x, triangleRect.origin.y)

            DrawingKit.drawTriangleGloss(frame: CGRectMake(0, 0, triangleRect.size.width, triangleRect.size.height))
            CGContextRestoreGState(context)
        }
    }

}



extension UIColor {
    func colorWithHue(newHue: CGFloat) -> UIColor {
        var saturation: CGFloat = 1.0, brightness: CGFloat = 1.0, alpha: CGFloat = 1.0
        self.getHue(nil, saturation: &saturation, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: newHue, saturation: saturation, brightness: brightness, alpha: alpha)
    }
    func colorWithSaturation(newSaturation: CGFloat) -> UIColor {
        var hue: CGFloat = 1.0, brightness: CGFloat = 1.0, alpha: CGFloat = 1.0
        self.getHue(&hue, saturation: nil, brightness: &brightness, alpha: &alpha)
        return UIColor(hue: hue, saturation: newSaturation, brightness: brightness, alpha: alpha)
    }
    func colorWithBrightness(newBrightness: CGFloat) -> UIColor {
        var hue: CGFloat = 1.0, saturation: CGFloat = 1.0, alpha: CGFloat = 1.0
        self.getHue(&hue, saturation: &saturation, brightness: nil, alpha: &alpha)
        return UIColor(hue: hue, saturation: saturation, brightness: newBrightness, alpha: alpha)
    }
    func colorWithAlpha(newAlpha: CGFloat) -> UIColor {
        var hue: CGFloat = 1.0, saturation: CGFloat = 1.0, brightness: CGFloat = 1.0
        self.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: nil)
        return UIColor(hue: hue, saturation: saturation, brightness: brightness, alpha: newAlpha)
    }
    func colorWithHighlight(highlight: CGFloat) -> UIColor {
        var red: CGFloat = 1.0, green: CGFloat = 1.0, blue: CGFloat = 1.0, alpha: CGFloat = 1.0
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-highlight) + highlight, green: green * (1-highlight) + highlight, blue: blue * (1-highlight) + highlight, alpha: alpha * (1-highlight) + highlight)
    }
    func colorWithShadow(shadow: CGFloat) -> UIColor {
        var red: CGFloat = 1.0, green: CGFloat = 1.0, blue: CGFloat = 1.0, alpha: CGFloat = 1.0
        self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
        return UIColor(red: red * (1-shadow), green: green * (1-shadow), blue: blue * (1-shadow), alpha: alpha * (1-shadow) + shadow)
    }
    func blendedColorWithFraction(fraction: CGFloat, ofColor color: UIColor) -> UIColor {
        var r1: CGFloat = 1.0, g1: CGFloat = 1.0, b1: CGFloat = 1.0, a1: CGFloat = 1.0
        var r2: CGFloat = 1.0, g2: CGFloat = 1.0, b2: CGFloat = 1.0, a2: CGFloat = 1.0

        self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
        color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

        return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
            green: g1 * (1 - fraction) + g2 * fraction,
            blue: b1 * (1 - fraction) + b2 * fraction,
            alpha: a1 * (1 - fraction) + a2 * fraction);
    }
}



extension NSShadow {
    convenience init(color: AnyObject!, offset: CGSize, blurRadius: CGFloat) {
        self.init()
        self.shadowColor = color
        self.shadowOffset = offset
        self.shadowBlurRadius = blurRadius
    }
}

@objc protocol StyleKitSettableImage {
    func setImage(image: UIImage!)
}

@objc protocol StyleKitSettableSelectedImage {
    func setSelectedImage(image: UIImage!)
}
