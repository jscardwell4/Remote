//
//  DrawingKit.swift
//  Remote
//
//  Created by Moondeer on 4/23/15.
//  Copyright (c) 2015 Moondeer Studios. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

import UIKit
import MoonKit

public class DrawingKit : NSObject {

    //// Cache

    private struct Cache {
        static var buttonBaseColor: UIColor = UIColor(red: 0.261, green: 0.258, blue: 0.258, alpha: 1.000)
        static var buttonStrokeColor: UIColor = DrawingKit.buttonBaseColor.colorWithHighlight(0.2)
        static var gradientColor: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
        static var gradient: CGGradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [DrawingKit.gradientColor.CGColor, DrawingKit.gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor, UIColor.whiteColor().CGColor], [0, 1, 1])
        static var innerShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 2)
        static var outerShadow: NSShadow = NSShadow(color: UIColor.blackColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 2)
        static var strokeShadow: NSShadow = NSShadow(color: UIColor.lightGrayColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 1)
        static var insettingShadow: NSShadow = NSShadow(color: UIColor.whiteColor().colorWithAlphaComponent(0.5), offset: CGSizeMake(0.1, 0.6), blurRadius: 0)
        static var plasticShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSizeMake(0.1, -0.6), blurRadius: 1)
        static var cutoutShadow: NSShadow = NSShadow(color: UIColor.blackColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 1)
        static var glowingShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSizeMake(0.1, -0.1), blurRadius: 5)
    }

    //// Colors

    public class var buttonBaseColor: UIColor { return Cache.buttonBaseColor }
    public class var buttonStrokeColor: UIColor { return Cache.buttonStrokeColor }
    public class var gradientColor: UIColor { return Cache.gradientColor }

    //// Gradients

    public class var gradient: CGGradient { return Cache.gradient }

    //// Shadows

    public class var innerShadow: NSShadow { return Cache.innerShadow }
    public class var outerShadow: NSShadow { return Cache.outerShadow }
    public class var strokeShadow: NSShadow { return Cache.strokeShadow }
    public class var insettingShadow: NSShadow { return Cache.insettingShadow }
    public class var plasticShadow: NSShadow { return Cache.plasticShadow }
    public class var cutoutShadow: NSShadow { return Cache.cutoutShadow }
    public class var glowingShadow: NSShadow { return Cache.glowingShadow }

    //// Drawing Methods

    public class func drawRoundishButtonBase(#frame: CGRect, color: UIColor, radius: CGFloat) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.4)


        //// Subframes
        let lightBase: CGRect = CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4)


        //// darkOverlayRectangle Drawing
        let darkOverlayRectanglePath = UIBezierPath(roundedRect: CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4), cornerRadius: radius)
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.outerShadow.shadowOffset, DrawingKit.outerShadow.shadowBlurRadius, (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
        color.setFill()
        darkOverlayRectanglePath.fill()

        ////// darkOverlayRectangle Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, darkOverlayRectanglePath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let darkOverlayRectangleOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, darkOverlayRectangleOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, kCGBlendModeSourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        darkOverlayRectangleOpaqueShadow.setFill()
        darkOverlayRectanglePath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.strokeShadow.shadowOffset, DrawingKit.strokeShadow.shadowBlurRadius, (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
        strokeColor.setStroke()
        darkOverlayRectanglePath.lineWidth = 1
        darkOverlayRectanglePath.stroke()
        CGContextRestoreGState(context)


        //// lightBase
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, kCGBlendModeSoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip lightBaseClip
        let lightBaseClipPath = UIBezierPath(roundedRect: CGRectMake(lightBase.minX + floor(lightBase.width * 0.00000 + 0.5), lightBase.minY + floor(lightBase.height * 0.00000 + 0.5), floor(lightBase.width * 1.00000 + 0.5) - floor(lightBase.width * 0.00000 + 0.5), floor(lightBase.height * 1.00000 + 0.5) - floor(lightBase.height * 0.00000 + 0.5)), cornerRadius: radius)
        lightBaseClipPath.addClip()


        //// lightBaseFillRect Drawing
        let lightBaseFillRectRect = CGRectMake(lightBase.minX + floor(lightBase.width * -0.02083 + 0.5), lightBase.minY + floor(lightBase.height * -0.03125 + 0.5), floor(lightBase.width * 1.02083 + 0.5) - floor(lightBase.width * -0.02083 + 0.5), floor(lightBase.height * 1.01042 + 0.5) - floor(lightBase.height * -0.03125 + 0.5))
        let lightBaseFillRectPath = UIBezierPath(rect: lightBaseFillRectRect)
        CGContextSaveGState(context)
        lightBaseFillRectPath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.gradient,
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 100, lightBaseFillRectRect.midY + 50 * lightBaseFillRectRect.height / 100),
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 100, lightBaseFillRectRect.midY + 0 * lightBaseFillRectRect.height / 100),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawGloss(#frame: CGRect) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()


        //// Subframes
        let group: CGRect = CGRectMake(frame.minX, frame.minY, frame.width, frame.height)


        //// Group
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, kCGBlendModeSoftLight)
        CGContextBeginTransparencyLayer(context, nil)


        //// Rectangle Drawing
        let rectangleRect = CGRectMake(group.minX + floor(group.width * 0.00000 + 0.5), group.minY + floor(group.height * 0.00000 + 0.5), floor(group.width * 1.00000 + 0.5) - floor(group.width * 0.00000 + 0.5), floor(group.height * 1.00000 + 0.5) - floor(group.height * 0.00000 + 0.5))
        let rectanglePath = UIBezierPath(rect: rectangleRect)
        CGContextSaveGState(context)
        rectanglePath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.gradient,
            CGPointMake(rectangleRect.midX + 0 * rectangleRect.width / 100, rectangleRect.midY + 50 * rectangleRect.height / 100),
            CGPointMake(rectangleRect.midX + 0 * rectangleRect.width / 100, rectangleRect.midY + 0 * rectangleRect.height / 100),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawRectangularButtonBase(#frame: CGRect, color: UIColor) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.4)


        //// Subframes
        let lightBase: CGRect = CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4)


        //// darkOverlayRect Drawing
        let darkOverlayRectPath = UIBezierPath(rect: CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4))
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.outerShadow.shadowOffset, DrawingKit.outerShadow.shadowBlurRadius, (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
        color.setFill()
        darkOverlayRectPath.fill()

        ////// darkOverlayRect Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, darkOverlayRectPath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let darkOverlayRectOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, darkOverlayRectOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, kCGBlendModeSourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        darkOverlayRectOpaqueShadow.setFill()
        darkOverlayRectPath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.strokeShadow.shadowOffset, DrawingKit.strokeShadow.shadowBlurRadius, (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
        strokeColor.setStroke()
        darkOverlayRectPath.lineWidth = 1
        darkOverlayRectPath.stroke()
        CGContextRestoreGState(context)


        //// lightBase
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, kCGBlendModeSoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip lightBaseClipRect
        let lightBaseClipRectPath = UIBezierPath(rect: CGRectMake(lightBase.minX + floor(lightBase.width * 0.00000 + 0.5), lightBase.minY + floor(lightBase.height * 0.00000 + 0.5), floor(lightBase.width * 1.00000 + 0.5) - floor(lightBase.width * 0.00000 + 0.5), floor(lightBase.height * 1.00000 + 0.5) - floor(lightBase.height * 0.00000 + 0.5)))
        lightBaseClipRectPath.addClip()


        //// lightBaseFillRect Drawing
        let lightBaseFillRectRect = CGRectMake(lightBase.minX + floor(lightBase.width * -0.01042 + 0.5), lightBase.minY + floor(lightBase.height * -0.02604) + 0.5, floor(lightBase.width * 1.03125 + 0.5) - floor(lightBase.width * -0.01042 + 0.5), floor(lightBase.height * 1.01562) - floor(lightBase.height * -0.02604))
        let lightBaseFillRectPath = UIBezierPath(rect: lightBaseFillRectRect)
        CGContextSaveGState(context)
        lightBaseFillRectPath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.gradient,
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 100, lightBaseFillRectRect.midY + 50 * lightBaseFillRectRect.height / 100),
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 100, lightBaseFillRectRect.midY + 0 * lightBaseFillRectRect.height / 100),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawOvalButtonBase(#frame: CGRect, color: UIColor) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.4)


        //// Subframes
        let lightBase: CGRect = CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4)


        //// darkOverlayOval Drawing
        var darkOverlayOvalPath = UIBezierPath(ovalInRect: CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4))
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.outerShadow.shadowOffset, DrawingKit.outerShadow.shadowBlurRadius, (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
        color.setFill()
        darkOverlayOvalPath.fill()

        ////// darkOverlayOval Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, darkOverlayOvalPath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let darkOverlayOvalOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, darkOverlayOvalOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, kCGBlendModeSourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        darkOverlayOvalOpaqueShadow.setFill()
        darkOverlayOvalPath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.strokeShadow.shadowOffset, DrawingKit.strokeShadow.shadowBlurRadius, (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
        strokeColor.setStroke()
        darkOverlayOvalPath.lineWidth = 1
        darkOverlayOvalPath.stroke()
        CGContextRestoreGState(context)


        //// lightBase
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, kCGBlendModeSoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip lightBaseClipRect
        var lightBaseClipRectPath = UIBezierPath(ovalInRect: CGRectMake(lightBase.minX + floor(lightBase.width * 0.00000 + 0.5), lightBase.minY + floor(lightBase.height * 0.00000 + 0.5), floor(lightBase.width * 1.00000 + 0.5) - floor(lightBase.width * 0.00000 + 0.5), floor(lightBase.height * 1.00000 + 0.5) - floor(lightBase.height * 0.00000 + 0.5)))
        lightBaseClipRectPath.addClip()


        //// lightBaseFillRect Drawing
        let lightBaseFillRectRect = CGRectMake(lightBase.minX + floor(lightBase.width * -0.02083 + 0.5), lightBase.minY + floor(lightBase.height * -0.02083 + 0.5), floor(lightBase.width * 1.02083 + 0.5) - floor(lightBase.width * -0.02083 + 0.5), floor(lightBase.height * 1.02083 + 0.5) - floor(lightBase.height * -0.02083 + 0.5))
        let lightBaseFillRectPath = UIBezierPath(rect: lightBaseFillRectRect)
        CGContextSaveGState(context)
        lightBaseFillRectPath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.gradient,
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 100, lightBaseFillRectRect.midY + 50 * lightBaseFillRectRect.height / 100),
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 100, lightBaseFillRectRect.midY + 0 * lightBaseFillRectRect.height / 100),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawDiamondButtonBase(#frame: CGRect, color: UIColor) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.4)


        //// Subframes
        let lightBase: CGRect = CGRectMake(frame.minX + 2, frame.minY + 2, frame.width - 4, frame.height - 4)


        //// darkOverlayDiamond Drawing
        var darkOverlayDiamondPath = UIBezierPath()
        darkOverlayDiamondPath.moveToPoint(CGPointMake(frame.minX + 2, frame.minY + 0.50000 * frame.height))
        darkOverlayDiamondPath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.minY + 2))
        darkOverlayDiamondPath.addLineToPoint(CGPointMake(frame.maxX - 2, frame.minY + 0.50000 * frame.height))
        darkOverlayDiamondPath.addLineToPoint(CGPointMake(frame.minX + 0.50000 * frame.width, frame.maxY - 2))
        darkOverlayDiamondPath.addLineToPoint(CGPointMake(frame.minX + 2, frame.minY + 0.50000 * frame.height))
        darkOverlayDiamondPath.closePath()
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.outerShadow.shadowOffset, DrawingKit.outerShadow.shadowBlurRadius, (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
        color.setFill()
        darkOverlayDiamondPath.fill()

        ////// darkOverlayDiamond Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, darkOverlayDiamondPath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let darkOverlayDiamondOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, darkOverlayDiamondOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, kCGBlendModeSourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        darkOverlayDiamondOpaqueShadow.setFill()
        darkOverlayDiamondPath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.strokeShadow.shadowOffset, DrawingKit.strokeShadow.shadowBlurRadius, (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
        strokeColor.setStroke()
        darkOverlayDiamondPath.lineWidth = 1
        darkOverlayDiamondPath.stroke()
        CGContextRestoreGState(context)


        //// lightBase
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, kCGBlendModeSoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip lightBaseClipRect
        var lightBaseClipRectPath = UIBezierPath()
        lightBaseClipRectPath.moveToPoint(CGPointMake(lightBase.minX + 0.00000 * lightBase.width, lightBase.minY + 0.50000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.50000 * lightBase.width, lightBase.minY + 0.00000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 1.00000 * lightBase.width, lightBase.minY + 0.50000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.50000 * lightBase.width, lightBase.minY + 1.00000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.00000 * lightBase.width, lightBase.minY + 0.50000 * lightBase.height))
        lightBaseClipRectPath.closePath()
        lightBaseClipRectPath.addClip()


        //// lightBaseFillRect Drawing
        let lightBaseFillRectRect = CGRectMake(lightBase.minX + floor(lightBase.width * -0.02083 + 0.5), lightBase.minY + floor(lightBase.height * -0.02083 + 0.5), floor(lightBase.width * 1.02083 + 0.5) - floor(lightBase.width * -0.02083 + 0.5), floor(lightBase.height * 1.02083 + 0.5) - floor(lightBase.height * -0.02083 + 0.5))
        let lightBaseFillRectPath = UIBezierPath(rect: lightBaseFillRectRect)
        CGContextSaveGState(context)
        lightBaseFillRectPath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.gradient,
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 100, lightBaseFillRectRect.midY + 50 * lightBaseFillRectRect.height / 100),
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 100, lightBaseFillRectRect.midY + 0 * lightBaseFillRectRect.height / 100),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawTriangleButtonBase(#frame: CGRect, color: UIColor) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.4)


        //// Subframes
        let lightBase: CGRect = CGRectMake(frame.minX + 7.2, frame.minY + 9.5, frame.width - 13.4, frame.height - 25)


        //// darkOverlayTriangle Drawing
        var darkOverlayTrianglePath = UIBezierPath()
        darkOverlayTrianglePath.moveToPoint(CGPointMake(frame.minX + 0.50500 * frame.width, frame.minY + 9.5))
        darkOverlayTrianglePath.addLineToPoint(CGPointMake(frame.minX + 0.72151 * frame.width, frame.minY + 47))
        darkOverlayTrianglePath.addLineToPoint(CGPointMake(frame.minX + 0.93801 * frame.width, frame.minY + 84.5))
        darkOverlayTrianglePath.addLineToPoint(CGPointMake(frame.minX + 0.50500 * frame.width, frame.minY + 84.5))
        darkOverlayTrianglePath.addLineToPoint(CGPointMake(frame.minX + 0.07199 * frame.width, frame.minY + 84.5))
        darkOverlayTrianglePath.addLineToPoint(CGPointMake(frame.minX + 0.28849 * frame.width, frame.minY + 47))
        darkOverlayTrianglePath.addLineToPoint(CGPointMake(frame.minX + 0.50500 * frame.width, frame.minY + 9.5))
        darkOverlayTrianglePath.closePath()
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.outerShadow.shadowOffset, DrawingKit.outerShadow.shadowBlurRadius, (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
        color.setFill()
        darkOverlayTrianglePath.fill()

        ////// darkOverlayTriangle Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, darkOverlayTrianglePath.bounds)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let darkOverlayTriangleOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, darkOverlayTriangleOpaqueShadow.CGColor)
        CGContextSetBlendMode(context, kCGBlendModeSourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        darkOverlayTriangleOpaqueShadow.setFill()
        darkOverlayTrianglePath.fill()

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)

        CGContextRestoreGState(context)

        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.strokeShadow.shadowOffset, DrawingKit.strokeShadow.shadowBlurRadius, (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
        strokeColor.setStroke()
        darkOverlayTrianglePath.lineWidth = 1
        darkOverlayTrianglePath.stroke()
        CGContextRestoreGState(context)


        //// lightBase
        CGContextSaveGState(context)
        CGContextSetBlendMode(context, kCGBlendModeSoftLight)
        CGContextBeginTransparencyLayer(context, nil)

        //// Clip lightBaseClipRect
        var lightBaseClipRectPath = UIBezierPath()
        lightBaseClipRectPath.moveToPoint(CGPointMake(lightBase.minX + 0.50000 * lightBase.width, lightBase.minY + 0.00000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.75000 * lightBase.width, lightBase.minY + 0.50000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 1.00000 * lightBase.width, lightBase.minY + 1.00000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.50000 * lightBase.width, lightBase.minY + 1.00000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.00000 * lightBase.width, lightBase.minY + 1.00000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.25000 * lightBase.width, lightBase.minY + 0.50000 * lightBase.height))
        lightBaseClipRectPath.addLineToPoint(CGPointMake(lightBase.minX + 0.50000 * lightBase.width, lightBase.minY + 0.00000 * lightBase.height))
        lightBaseClipRectPath.closePath()
        lightBaseClipRectPath.addClip()


        //// lightBaseFillRect Drawing
        let lightBaseFillRectRect = CGRectMake(lightBase.minX + floor(lightBase.width * -0.08312 - 0.3) + 0.8, lightBase.minY + floor(lightBase.height * -0.13333 + 0.5), floor(lightBase.width * 1.07158 - 0.3) - floor(lightBase.width * -0.08312 - 0.3), floor(lightBase.height * 1.20000 + 0.5) - floor(lightBase.height * -0.13333 + 0.5))
        let lightBaseFillRectPath = UIBezierPath(rect: lightBaseFillRectRect)
        CGContextSaveGState(context)
        lightBaseFillRectPath.addClip()
        CGContextDrawLinearGradient(context, DrawingKit.gradient,
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 100, lightBaseFillRectRect.midY + 50 * lightBaseFillRectRect.height / 100),
            CGPointMake(lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 100, lightBaseFillRectRect.midY + 0 * lightBaseFillRectRect.height / 100),
            UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
        CGContextRestoreGState(context)


        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)
    }

    public class func drawBatteryStatus(#frame: CGRect, color: UIColor, hasPower: Bool, chargeLevel: CGFloat) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.4)

        //// Variable Declarations
        let showPower = hasPower && chargeLevel == 1
        let showCharging = hasPower && chargeLevel < 1

        //// Group
        //// Battery Fill Drawing
        CGContextSaveGState(context)
        CGContextTranslateCTM(context, frame.minX + 0.06250 * frame.width, frame.minY + 0.10938 * frame.height)
        CGContextScaleCTM(context, chargeLevel, 1)

        let batteryFillPath = UIBezierPath(rect: CGRectMake(0, 0, 45, 25))
        color.setFill()
        batteryFillPath.fill()

        CGContextRestoreGState(context)


        //// Battery Frame Drawing
        let batteryFramePath = UIBezierPath(roundedRect: CGRectMake(frame.minX + 2, frame.minY + 2, 48, 28), cornerRadius: 1)
        color.setStroke()
        batteryFramePath.lineWidth = 1
        batteryFramePath.stroke()


        //// Battery Tip Drawing
        var batteryTipPath = UIBezierPath(roundedRect: CGRectMake(frame.minX + 50, frame.minY + 9.5, 4, 13), byRoundingCorners: UIRectCorner.TopRight | UIRectCorner.BottomRight, cornerRadii: CGSizeMake(1, 1))
        batteryTipPath.closePath()
        color.setStroke()
        batteryTipPath.lineWidth = 1
        batteryTipPath.stroke()




        if (showPower) {
            //// Power Drawing
            var powerPath = UIBezierPath()
            powerPath.moveToPoint(CGPointMake(frame.minX + 0.71429 * frame.width, frame.minY + 0.43750 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.71429 * frame.width, frame.minY + 0.37500 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.62500 * frame.width, frame.minY + 0.37500 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.62500 * frame.width, frame.minY + 0.28125 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.47321 * frame.width, frame.minY + 0.28125 * frame.height))
            powerPath.addCurveToPoint(CGPointMake(frame.minX + 0.45893 * frame.width, frame.minY + 0.29375 * frame.height), controlPoint1: CGPointMake(frame.minX + 0.46786 * frame.width, frame.minY + 0.28125 * frame.height), controlPoint2: CGPointMake(frame.minX + 0.46250 * frame.width, frame.minY + 0.28438 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.41071 * frame.width, frame.minY + 0.40625 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.23214 * frame.width, frame.minY + 0.40625 * frame.height))
            powerPath.addCurveToPoint(CGPointMake(frame.minX + 0.21429 * frame.width, frame.minY + 0.43750 * frame.height), controlPoint1: CGPointMake(frame.minX + 0.22143 * frame.width, frame.minY + 0.40625 * frame.height), controlPoint2: CGPointMake(frame.minX + 0.21429 * frame.width, frame.minY + 0.41875 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.21429 * frame.width, frame.minY + 0.56250 * frame.height))
            powerPath.addCurveToPoint(CGPointMake(frame.minX + 0.23214 * frame.width, frame.minY + 0.59375 * frame.height), controlPoint1: CGPointMake(frame.minX + 0.21429 * frame.width, frame.minY + 0.58125 * frame.height), controlPoint2: CGPointMake(frame.minX + 0.22143 * frame.width, frame.minY + 0.59375 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.41071 * frame.width, frame.minY + 0.59375 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.45893 * frame.width, frame.minY + 0.70625 * frame.height))
            powerPath.addCurveToPoint(CGPointMake(frame.minX + 0.47321 * frame.width, frame.minY + 0.71875 * frame.height), controlPoint1: CGPointMake(frame.minX + 0.46250 * frame.width, frame.minY + 0.71562 * frame.height), controlPoint2: CGPointMake(frame.minX + 0.46786 * frame.width, frame.minY + 0.71875 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.62500 * frame.width, frame.minY + 0.71875 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.62500 * frame.width, frame.minY + 0.62500 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.71429 * frame.width, frame.minY + 0.62500 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.71429 * frame.width, frame.minY + 0.56250 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.62500 * frame.width, frame.minY + 0.56250 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.62500 * frame.width, frame.minY + 0.43750 * frame.height))
            powerPath.addLineToPoint(CGPointMake(frame.minX + 0.71429 * frame.width, frame.minY + 0.43750 * frame.height))
            powerPath.closePath()
            powerPath.miterLimit = 4;

            strokeColor.setFill()
            powerPath.fill()
        }


        if (showCharging) {
            //// Lightning Drawing
            var lightningPath = UIBezierPath()
            lightningPath.moveToPoint(CGPointMake(frame.minX + 0.55153 * frame.width, frame.minY + 0.42366 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.47675 * frame.width, frame.minY + 0.42366 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.51414 * frame.width, frame.minY + 0.19463 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.42689 * frame.width, frame.minY + 0.19463 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.37704 * frame.width, frame.minY + 0.54362 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.46429 * frame.width, frame.minY + 0.54362 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.44559 * frame.width, frame.minY + 0.80537 * frame.height))
            lightningPath.addLineToPoint(CGPointMake(frame.minX + 0.55153 * frame.width, frame.minY + 0.42366 * frame.height))
            lightningPath.closePath()
            lightningPath.miterLimit = 4;

            strokeColor.setFill()
            lightningPath.fill()
        }
    }

    public class func drawRoundishButtonWithText(#color: UIColor, buttonText: String) {
        //// General Declarations
        let context = UIGraphicsGetCurrentContext()

        //// Color Declarations
        let strokeColor = color.colorWithHighlight(0.4)

        //// roundishButton Drawing
        let roundishButtonRect = CGRectMake(0, 0, 240, 120)
        CGContextSaveGState(context)
        UIRectClip(roundishButtonRect)
        CGContextTranslateCTM(context, roundishButtonRect.origin.x, roundishButtonRect.origin.y)

        DrawingKit.drawRoundishButtonBase(frame: CGRectMake(0, 0, roundishButtonRect.size.width, roundishButtonRect.size.height), color: color, radius: 5)
        CGContextRestoreGState(context)


        //// label Drawing
        let labelRect = CGRectMake(20, 20, 200, 80)
        CGContextSaveGState(context)
        CGContextSetShadowWithColor(context, DrawingKit.insettingShadow.shadowOffset, DrawingKit.insettingShadow.shadowBlurRadius, (DrawingKit.insettingShadow.shadowColor as! UIColor).CGColor)
        let labelStyle = NSParagraphStyle.defaultParagraphStyle().mutableCopy() as! NSMutableParagraphStyle
        labelStyle.alignment = NSTextAlignment.Center

        let labelFontAttributes = [NSFontAttributeName: UIFont(name: "HelveticaNeue-Bold", size: 20)!, NSForegroundColorAttributeName: strokeColor, NSParagraphStyleAttributeName: labelStyle]

        let labelTextHeight: CGFloat = NSString(string: buttonText).boundingRectWithSize(CGSizeMake(labelRect.width, CGFloat.infinity), options: NSStringDrawingOptions.UsesLineFragmentOrigin, attributes: labelFontAttributes, context: nil).size.height
        let labelTextRect: CGRect = CGRectMake(labelRect.minX, labelRect.minY + (labelRect.height - labelTextHeight) / 2, labelRect.width, labelTextHeight)
        CGContextSaveGState(context)
        CGContextClipToRect(context, labelRect);
        NSString(string: buttonText).drawInRect(labelTextRect, withAttributes: labelFontAttributes)
        CGContextRestoreGState(context)
        
        ////// label Text Inner Shadow
        CGContextSaveGState(context)
        CGContextClipToRect(context, labelRect)
        CGContextSetShadow(context, CGSizeMake(0, 0), 0)
        CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.cutoutShadow.shadowColor as! UIColor).CGColor))
        CGContextBeginTransparencyLayer(context, nil)
        let labelOpaqueTextShadow = (DrawingKit.cutoutShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
        CGContextSetShadowWithColor(context, DrawingKit.cutoutShadow.shadowOffset, DrawingKit.cutoutShadow.shadowBlurRadius, labelOpaqueTextShadow.CGColor)
        CGContextSetBlendMode(context, kCGBlendModeSourceOut)
        CGContextBeginTransparencyLayer(context, nil)

        labelOpaqueTextShadow.setFill()

        let labelInnerShadowFontAttributes = [NSFontAttributeName: UIFont(name: "HelveticaNeue-Bold", size: 20)!, NSForegroundColorAttributeName: (DrawingKit.cutoutShadow.shadowColor as! UIColor), NSParagraphStyleAttributeName: labelStyle]
        NSString(string: buttonText).drawInRect(labelTextRect, withAttributes: labelInnerShadowFontAttributes)

        CGContextEndTransparencyLayer(context)
        CGContextEndTransparencyLayer(context)
        CGContextRestoreGState(context)


        CGContextRestoreGState(context)



        //// glossOverlay Drawing
        let glossOverlayRect = CGRectMake(0, 0, 240, 120)
        CGContextSaveGState(context)
        UIRectClip(glossOverlayRect)
        CGContextTranslateCTM(context, glossOverlayRect.origin.x, glossOverlayRect.origin.y)

        DrawingKit.drawGloss(frame: CGRectMake(0, 0, glossOverlayRect.size.width, glossOverlayRect.size.height))
        CGContextRestoreGState(context)
    }

}
