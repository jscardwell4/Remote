//
//  DrawingKit.swift
//  Remote
//
//  Created by Moondeer on 4/21/15.
//  Copyright (c) 2015 Moondeer Studios. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//

import UIKit
import MoonKit


public final class DrawingKit {

  // MARK: - Colors
  public static let buttonBaseColor: UIColor = UIColor(red: 0.261, green: 0.258, blue: 0.258, alpha: 1.000)
  public static let buttonStrokeColor: UIColor = DrawingKit.buttonBaseColor.colorWithHighlight(0.2)

  // MARK: - Shadows
  public static let innerShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 2)
  public static let outerShadow: NSShadow = NSShadow(color: UIColor.blackColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 2)
  public static let strokeShadow: NSShadow = NSShadow(color: UIColor.lightGrayColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 1)
  public static let insettingShadow: NSShadow = NSShadow(color: UIColor.whiteColor().colorWithAlphaComponent(0.5), offset: CGSize(width: 0.1, height: 0.6), blurRadius: 0)
  public static let plasticShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSize(width: 0.1, height: -0.6), blurRadius: 1)
  public static let cutoutShadow: NSShadow = NSShadow(color: UIColor.blackColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 4)
  public static let glowingShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 5)


  // MARK: - Drawing Methods

  /**
  drawRoundishButtonBase:color:radius:

  :param: #frame CGRect
  :param: color UIColor
  :param: radius CGFloat
  */
  public class func drawRoundishButtonBase(#frame: CGRect, color: UIColor, radius: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let strokeColor = color.colorWithHighlight(0.4)
    let gradientColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

    // Gradient Declarations
    let gradient = CGGradientCreateWithColors(
      CGColorSpaceCreateDeviceRGB(),
      [gradientColor.CGColor,
        gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor,
        UIColor.whiteColor().CGColor],
      [0, 1, 1])


    // Subframes
    let group2: CGRect = CGRect(x: frame.minX + 2, y: frame.minY + 2, width: frame.width - 4, height: frame.height - 4)


    // Rectangle Drawing
    let rectanglePath = UIBezierPath(roundedRect: CGRect(x: frame.minX + 2, y: frame.minY + 2, width: frame.width - 4, height: frame.height - 4), cornerRadius: radius)
    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context, DrawingKit.outerShadow.shadowOffset, DrawingKit.outerShadow.shadowBlurRadius, (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
    color.setFill()
    rectanglePath.fill()

    // Rectangle Inner Shadow
    CGContextSaveGState(context)
    CGContextClipToRect(context, rectanglePath.bounds)
    CGContextSetShadow(context, CGSize(width: 0, height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let rectangleOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, rectangleOpaqueShadow.CGColor)
    CGContextSetBlendMode(context, kCGBlendModeSourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    rectangleOpaqueShadow.setFill()
    rectanglePath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)

    CGContextRestoreGState(context)

    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context, DrawingKit.strokeShadow.shadowOffset, DrawingKit.strokeShadow.shadowBlurRadius, (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
    strokeColor.setStroke()
    rectanglePath.lineWidth = 1
    rectanglePath.stroke()
    CGContextRestoreGState(context)


    // Group 2
    CGContextSaveGState(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)

    // Clip Rectangle 3
    let rectangle3Path = UIBezierPath(roundedRect: CGRect(x: group2.minX + floor(group2.width * 0.00000 + 0.5), y: group2.minY + floor(group2.height * 0.00000 + 0.5), width: floor(group2.width * 1.00000 + 0.5) - floor(group2.width * 0.00000 + 0.5), height: floor(group2.height * 1.00000 + 0.5) - floor(group2.height * 0.00000 + 0.5)), cornerRadius: radius)
    rectangle3Path.addClip()


    // Rectangle 2 Drawing
    let rectangle2Rect = CGRect(x: group2.minX + floor(group2.width * -0.02083 + 0.5), y: group2.minY + floor(group2.height * -0.03125 + 0.5), width: floor(group2.width * 1.02083 + 0.5) - floor(group2.width * -0.02083 + 0.5), height: floor(group2.height * 1.01042 + 0.5) - floor(group2.height * -0.03125 + 0.5))
    let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
    CGContextSaveGState(context)
    rectangle2Path.addClip()
    CGContextDrawLinearGradient(context, gradient,
      CGPoint(x: rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, y: rectangle2Rect.midY + 50 * rectangle2Rect.height / 100),
      CGPoint(x: rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, y: rectangle2Rect.midY + 0 * rectangle2Rect.height / 100),
      UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
    CGContextRestoreGState(context)


    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)
  }

  /**
  drawGloss:

  :param: #frame CGRect
  */
  public class func drawGloss(#frame: CGRect) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let gradientColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

    // Gradient Declarations
    let gradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [gradientColor.CGColor, gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor, UIColor.whiteColor().CGColor], [0, 1, 1])


    // Subframes
    let group: CGRect = CGRect(x: frame.minX, y: frame.minY, width: frame.width, height: frame.height)


    // Group
    CGContextSaveGState(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)


    // Rectangle Drawing
    let rectangleRect = CGRect(x: group.minX + floor(group.width * 0.00000 + 0.5), y: group.minY + floor(group.height * 0.00000 + 0.5), width: floor(group.width * 1.00000 + 0.5) - floor(group.width * 0.00000 + 0.5), height: floor(group.height * 1.00000 + 0.5) - floor(group.height * 0.00000 + 0.5))
    let rectanglePath = UIBezierPath(rect: rectangleRect)
    CGContextSaveGState(context)
    rectanglePath.addClip()
    CGContextDrawLinearGradient(context, gradient,
      CGPoint(x: rectangleRect.midX + 0 * rectangleRect.width / 100, y: rectangleRect.midY + 50 * rectangleRect.height / 100),
      CGPoint(x: rectangleRect.midX + 0 * rectangleRect.width / 100, y: rectangleRect.midY + 0 * rectangleRect.height / 100),
      UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
    CGContextRestoreGState(context)


    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)
  }

  /**
  drawRectangularButtonBase:color:

  :param: #frame CGRect
  :param: color UIColor
  */
  public class func drawRectangularButtonBase(#frame: CGRect, color: UIColor) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let strokeColor = color.colorWithHighlight(0.4)
    let gradientColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

    // Gradient Declarations
    let gradient = CGGradientCreateWithColors(CGColorSpaceCreateDeviceRGB(), [gradientColor.CGColor, gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor, UIColor.whiteColor().CGColor], [0, 1, 1])


    // Subframes
    let group2: CGRect = CGRect(x: frame.minX + 2, y: frame.minY + 2, width: frame.width - 4, height: frame.height - 4)


    // Rectangle Drawing
    let rectanglePath = UIBezierPath(rect: CGRect(x: frame.minX + 2, y: frame.minY + 2, width: frame.width - 4, height: frame.height - 4))
    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                DrawingKit.outerShadow.shadowOffset,
                                DrawingKit.outerShadow.shadowBlurRadius,
                                (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
    color.setFill()
    rectanglePath.fill()

    // Rectangle Inner Shadow
    CGContextSaveGState(context)
    CGContextClipToRect(context, rectanglePath.bounds)
    CGContextSetShadow(context, CGSize(width: 0, height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let rectangleOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(context,
                                DrawingKit.innerShadow.shadowOffset,
                                DrawingKit.innerShadow.shadowBlurRadius,
                                rectangleOpaqueShadow.CGColor)
    CGContextSetBlendMode(context, kCGBlendModeSourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    rectangleOpaqueShadow.setFill()
    rectanglePath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)

    CGContextRestoreGState(context)

    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                DrawingKit.strokeShadow.shadowOffset,
                                DrawingKit.strokeShadow.shadowBlurRadius,
                                (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
    strokeColor.setStroke()
    rectanglePath.lineWidth = 1
    rectanglePath.stroke()
    CGContextRestoreGState(context)


    // Group 2
    CGContextSaveGState(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)

    // Clip Rectangle 3
    let rectangle3Path = UIBezierPath(rect: CGRect(x: group2.minX + floor(group2.width * 0 + 0.5),
                                                   y: group2.minY + floor(group2.height * 0 + 0.5),
                                                   width: floor(group2.width * 1 + 0.5) - floor(group2.width * 0 + 0.5),
                                                   height: floor(group2.height * 1 + 0.5) - floor(group2.height * 0 + 0.5)))
    rectangle3Path.addClip()


    // Rectangle 2 Drawing
    let rectangle2Rect = CGRect(x: group2.minX + floor(group2.width * -0.01042 + 0.5),
                                y: group2.minY + floor(group2.height * -0.02604) + 0.5,
                                width: floor(group2.width * 1.03125 + 0.5) - floor(group2.width * -0.01042 + 0.5),
                                height: floor(group2.height * 1.01562) - floor(group2.height * -0.02604))
    let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
    CGContextSaveGState(context)
    rectangle2Path.addClip()
    CGContextDrawLinearGradient(context, gradient,
      CGPoint(x: rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, y: rectangle2Rect.midY + 50 * rectangle2Rect.height / 100),
      CGPoint(x: rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, y: rectangle2Rect.midY + 0 * rectangle2Rect.height / 100),
      UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
    CGContextRestoreGState(context)


    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)
  }

  /**
  drawOvalButtonBase:color:

  :param: #frame CGRect
  :param: color UIColor
  */
  public class func drawOvalButtonBase(#frame: CGRect, color: UIColor) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let strokeColor = color.colorWithHighlight(0.4)
    let gradientColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

    // Gradient Declarations
    let gradient = CGGradientCreateWithColors(
      CGColorSpaceCreateDeviceRGB(),
      [gradientColor.CGColor,
        gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor,
        UIColor.whiteColor().CGColor],
      [0, 1, 1])


    // Subframes
    let group2: CGRect = CGRect(x: frame.minX + 2, y: frame.minY + 2, width: frame.width - 4, height: frame.height - 4)


    // Oval Drawing
    var ovalPath = UIBezierPath(ovalInRect: CGRect(x: frame.minX + 2, y: frame.minY + 2, width: frame.width - 4, height: frame.height - 4))
    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                DrawingKit.outerShadow.shadowOffset,
                                DrawingKit.outerShadow.shadowBlurRadius,
                                (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
    color.setFill()
    ovalPath.fill()

    // Oval Inner Shadow
    CGContextSaveGState(context)
    CGContextClipToRect(context, ovalPath.bounds)
    CGContextSetShadow(context, CGSize(width: 0, height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let ovalOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(context, DrawingKit.innerShadow.shadowOffset, DrawingKit.innerShadow.shadowBlurRadius, ovalOpaqueShadow.CGColor)
    CGContextSetBlendMode(context, kCGBlendModeSourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    ovalOpaqueShadow.setFill()
    ovalPath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)

    CGContextRestoreGState(context)

    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                DrawingKit.strokeShadow.shadowOffset,
                                DrawingKit.strokeShadow.shadowBlurRadius,
                                (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
    strokeColor.setStroke()
    ovalPath.lineWidth = 1
    ovalPath.stroke()
    CGContextRestoreGState(context)


    // Group 2
    CGContextSaveGState(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)

    // Clip Oval 2
    var oval2Path = UIBezierPath(ovalInRect: CGRect(x: group2.minX + floor(group2.width * 0.0 + 0.5),
                                                    y: group2.minY + floor(group2.height * 0.0 + 0.5),
                                                    width: floor(group2.width * 1.0 + 0.5) - floor(group2.width * 0.0 + 0.5),
                                                    height: floor(group2.height * 1.0 + 0.5) - floor(group2.height * 0.0 + 0.5)))
    oval2Path.addClip()


    // Rectangle 2 Drawing
    let rectangle2Rect = CGRect(x: group2.minX + floor(group2.width * -0.02083 + 0.5),
                                y: group2.minY + floor(group2.height * -0.02083 + 0.5),
                                width: floor(group2.width * 1.02083 + 0.5) - floor(group2.width * -0.02083 + 0.5),
                                height: floor(group2.height * 1.02083 + 0.5) - floor(group2.height * -0.02083 + 0.5))
    let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
    CGContextSaveGState(context)
    rectangle2Path.addClip()
    CGContextDrawLinearGradient(context, gradient,
      CGPoint(x: rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, y: rectangle2Rect.midY + 50 * rectangle2Rect.height / 100),
      CGPoint(x: rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, y: rectangle2Rect.midY + 0 * rectangle2Rect.height / 100),
      UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
    CGContextRestoreGState(context)


    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)
  }

  /**
  drawDiamondButtonBase:color:

  :param: #frame CGRect
  :param: color UIColor
  */
  public class func drawDiamondButtonBase(#frame: CGRect, color: UIColor) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let strokeColor = color.colorWithHighlight(0.4)
    let gradientColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

    // Gradient Declarations
    let gradient = CGGradientCreateWithColors(
      CGColorSpaceCreateDeviceRGB(),
      [gradientColor.CGColor,
        gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor,
        UIColor.whiteColor().CGColor],
      [0, 1, 1])


    // Subframes
    let group2: CGRect = CGRect(x: frame.minX + 2, y: frame.minY + 2, width: frame.width - 4, height: frame.height - 4)


    // Bezier Drawing
    var bezierPath = UIBezierPath()
    bezierPath.moveToPoint(CGPoint(x: frame.minX + 2, y: frame.minY + 0.50000 * frame.height))
    bezierPath.addLineToPoint(CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.minY + 2))
    bezierPath.addLineToPoint(CGPoint(x: frame.maxX - 2, y: frame.minY + 0.50000 * frame.height))
    bezierPath.addLineToPoint(CGPoint(x: frame.minX + 0.50000 * frame.width, y: frame.maxY - 2))
    bezierPath.addLineToPoint(CGPoint(x: frame.minX + 2, y: frame.minY + 0.50000 * frame.height))
    bezierPath.closePath()
    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                DrawingKit.outerShadow.shadowOffset,
                                DrawingKit.outerShadow.shadowBlurRadius,
                                (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
    color.setFill()
    bezierPath.fill()

    // Bezier Inner Shadow
    CGContextSaveGState(context)
    CGContextClipToRect(context, bezierPath.bounds)
    CGContextSetShadow(context, CGSize(width: 0, height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let bezierOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(context,
                                DrawingKit.innerShadow.shadowOffset,
                                DrawingKit.innerShadow.shadowBlurRadius,
                                bezierOpaqueShadow.CGColor)
    CGContextSetBlendMode(context, kCGBlendModeSourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    bezierOpaqueShadow.setFill()
    bezierPath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)

    CGContextRestoreGState(context)

    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                DrawingKit.strokeShadow.shadowOffset,
                                DrawingKit.strokeShadow.shadowBlurRadius,
                                (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
    strokeColor.setStroke()
    bezierPath.lineWidth = 1
    bezierPath.stroke()
    CGContextRestoreGState(context)


    // Group 2
    CGContextSaveGState(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)

    // Clip Bezier 2
    var bezier2Path = UIBezierPath()
    bezier2Path.moveToPoint(CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.50000 * group2.height))
    bezier2Path.addLineToPoint(CGPoint(x: group2.minX + 0.50000 * group2.width, y: group2.minY + 0.00000 * group2.height))
    bezier2Path.addLineToPoint(CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 0.50000 * group2.height))
    bezier2Path.addLineToPoint(CGPoint(x: group2.minX + 0.50000 * group2.width, y: group2.minY + 1.00000 * group2.height))
    bezier2Path.addLineToPoint(CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 0.50000 * group2.height))
    bezier2Path.closePath()
    bezier2Path.addClip()


    // Rectangle 2 Drawing
    let rectangle2Rect = CGRect(x: group2.minX + floor(group2.width * -0.02083 + 0.5),
                                y: group2.minY + floor(group2.height * -0.02083 + 0.5),
                                width: floor(group2.width * 1.02083 + 0.5) - floor(group2.width * -0.02083 + 0.5),
                                height: floor(group2.height * 1.02083 + 0.5) - floor(group2.height * -0.02083 + 0.5))
    let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
    CGContextSaveGState(context)
    rectangle2Path.addClip()
    CGContextDrawLinearGradient(context, gradient,
      CGPoint(x: rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, y: rectangle2Rect.midY + 50 * rectangle2Rect.height / 100),
      CGPoint(x: rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, y: rectangle2Rect.midY + 0 * rectangle2Rect.height / 100),
      UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
    CGContextRestoreGState(context)


    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)
  }

  /**
  drawTriangleButtonBase:color:

  :param: #frame CGRect
  :param: color UIColor
  */
  public class func drawTriangleButtonBase(#frame: CGRect, color: UIColor) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let strokeColor = color.colorWithHighlight(0.4)
    let gradientColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)

    // Gradient Declarations
    let gradient = CGGradientCreateWithColors(
      CGColorSpaceCreateDeviceRGB(),
      [gradientColor.CGColor,
        gradientColor.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor,
        UIColor.whiteColor().CGColor],
      [0, 1, 1])


    // Subframes
    let group2: CGRect = CGRect(x: frame.minX + 7.2, y: frame.minY + 9.5, width: frame.width - 13.4, height: frame.height - 25)


    // Star Drawing
    var starPath = UIBezierPath()
    starPath.moveToPoint(CGPoint(x: frame.minX + 0.50500 * frame.width, y: frame.minY + 9.5))
    starPath.addLineToPoint(CGPoint(x: frame.minX + 0.72151 * frame.width, y: frame.minY + 47))
    starPath.addLineToPoint(CGPoint(x: frame.minX + 0.93801 * frame.width, y: frame.minY + 84.5))
    starPath.addLineToPoint(CGPoint(x: frame.minX + 0.50500 * frame.width, y: frame.minY + 84.5))
    starPath.addLineToPoint(CGPoint(x: frame.minX + 0.07199 * frame.width, y: frame.minY + 84.5))
    starPath.addLineToPoint(CGPoint(x: frame.minX + 0.28849 * frame.width, y: frame.minY + 47))
    starPath.addLineToPoint(CGPoint(x: frame.minX + 0.50500 * frame.width, y: frame.minY + 9.5))
    starPath.closePath()
    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                DrawingKit.outerShadow.shadowOffset,
                                DrawingKit.outerShadow.shadowBlurRadius,
                                (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor)
    color.setFill()
    starPath.fill()

    // Star Inner Shadow
    CGContextSaveGState(context)
    CGContextClipToRect(context, starPath.bounds)
    CGContextSetShadow(context, CGSize(width: 0, height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let starOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(context,
                                DrawingKit.innerShadow.shadowOffset,
                                DrawingKit.innerShadow.shadowBlurRadius,
                                starOpaqueShadow.CGColor)
    CGContextSetBlendMode(context, kCGBlendModeSourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    starOpaqueShadow.setFill()
    starPath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)

    CGContextRestoreGState(context)

    CGContextSaveGState(context)
    CGContextSetShadowWithColor(context,
                                DrawingKit.strokeShadow.shadowOffset,
                                DrawingKit.strokeShadow.shadowBlurRadius,
                                (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor)
    strokeColor.setStroke()
    starPath.lineWidth = 1
    starPath.stroke()
    CGContextRestoreGState(context)


    // Group 2
    CGContextSaveGState(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)

    // Clip Star 2
    var star2Path = UIBezierPath()
    star2Path.moveToPoint(CGPoint(x: group2.minX + 0.50000 * group2.width, y: group2.minY + 0.00000 * group2.height))
    star2Path.addLineToPoint(CGPoint(x: group2.minX + 0.75000 * group2.width, y: group2.minY + 0.50000 * group2.height))
    star2Path.addLineToPoint(CGPoint(x: group2.minX + 1.00000 * group2.width, y: group2.minY + 1.00000 * group2.height))
    star2Path.addLineToPoint(CGPoint(x: group2.minX + 0.50000 * group2.width, y: group2.minY + 1.00000 * group2.height))
    star2Path.addLineToPoint(CGPoint(x: group2.minX + 0.00000 * group2.width, y: group2.minY + 1.00000 * group2.height))
    star2Path.addLineToPoint(CGPoint(x: group2.minX + 0.25000 * group2.width, y: group2.minY + 0.50000 * group2.height))
    star2Path.addLineToPoint(CGPoint(x: group2.minX + 0.50000 * group2.width, y: group2.minY + 0.00000 * group2.height))
    star2Path.closePath()
    star2Path.addClip()


    // Rectangle 2 Drawing
    let rectangle2Rect = CGRect(x: group2.minX + floor(group2.width * -0.08312 - 0.3) + 0.8,
                                y: group2.minY + floor(group2.height * -0.13333 + 0.5),
                                width: floor(group2.width * 1.07158 - 0.3) - floor(group2.width * -0.08312 - 0.3),
                                height: floor(group2.height * 1.20000 + 0.5) - floor(group2.height * -0.13333 + 0.5))
    let rectangle2Path = UIBezierPath(rect: rectangle2Rect)
    CGContextSaveGState(context)
    rectangle2Path.addClip()
    CGContextDrawLinearGradient(context, gradient,
      CGPoint(x: rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, y: rectangle2Rect.midY + 50 * rectangle2Rect.height / 100),
      CGPoint(x: rectangle2Rect.midX + 0 * rectangle2Rect.width / 100, y: rectangle2Rect.midY + 0 * rectangle2Rect.height / 100),
      UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
    CGContextRestoreGState(context)


    CGContextEndTransparencyLayer(context)
    CGContextRestoreGState(context)
  }

  /**
  drawBatteryStatus:color:hasPower:chargeLevel:

  :param: #frame CGRect
  :param: color UIColor
  :param: hasPower Bool
  :param: chargeLevel CGFloat
  */
  public class func drawBatteryStatus(#frame: CGRect, color: UIColor, hasPower: Bool, chargeLevel: CGFloat) {
    // General Declarations
    let context = UIGraphicsGetCurrentContext()

    // Color Declarations
    let strokeColor = color.colorWithHighlight(0.4)

    // Variable Declarations
    let showPower = hasPower && chargeLevel == 1
    let showCharging = hasPower && chargeLevel < 1

    // Group
    // Battery Fill Drawing
    CGContextSaveGState(context)
    CGContextTranslateCTM(context, frame.minX + 0.06250 * frame.width, frame.minY + 0.10938 * frame.height)
    CGContextScaleCTM(context, chargeLevel, 1)

    let batteryFillPath = UIBezierPath(rect: CGRect(x: 0, y: 0, width: 45, height: 25))
    color.setFill()
    batteryFillPath.fill()

    CGContextRestoreGState(context)


    // Battery Frame Drawing
    let batteryFramePath = UIBezierPath(roundedRect: CGRect(x: frame.minX + 2, y: frame.minY + 2, width: 48, height: 28),
                                        cornerRadius: 1)
    color.setStroke()
    batteryFramePath.lineWidth = 1
    batteryFramePath.stroke()


    // Battery Tip Drawing
    var batteryTipPath = UIBezierPath(roundedRect: CGRect(x: frame.minX + 50, y: frame.minY + 9.5, width: 4, height: 13),
                                      byRoundingCorners: UIRectCorner.TopRight | UIRectCorner.BottomRight,
                                      cornerRadii: CGSize(width: 1, height: 1))
    batteryTipPath.closePath()
    color.setStroke()
    batteryTipPath.lineWidth = 1
    batteryTipPath.stroke()

    if (showPower) {
      // Power Drawing
      var powerPath = UIBezierPath()
      powerPath.moveToPoint(CGPoint(x: frame.minX + 0.71429 * frame.width, y: frame.minY + 0.43750 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.71429 * frame.width, y: frame.minY + 0.37500 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.62500 * frame.width, y: frame.minY + 0.37500 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.62500 * frame.width, y: frame.minY + 0.28125 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.47321 * frame.width, y: frame.minY + 0.28125 * frame.height))
      powerPath.addCurveToPoint(CGPoint(x: frame.minX + 0.45893 * frame.width, y: frame.minY + 0.29375 * frame.height),
                  controlPoint1: CGPoint(x: frame.minX + 0.46786 * frame.width, y: frame.minY + 0.28125 * frame.height),
                  controlPoint2: CGPoint(x: frame.minX + 0.46250 * frame.width, y: frame.minY + 0.28438 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.41071 * frame.width, y: frame.minY + 0.40625 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.23214 * frame.width, y: frame.minY + 0.40625 * frame.height))
      powerPath.addCurveToPoint(CGPoint(x: frame.minX + 0.21429 * frame.width, y: frame.minY + 0.43750 * frame.height),
                  controlPoint1: CGPoint(x: frame.minX + 0.22143 * frame.width, y: frame.minY + 0.40625 * frame.height),
                  controlPoint2: CGPoint(x: frame.minX + 0.21429 * frame.width, y: frame.minY + 0.41875 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.21429 * frame.width, y: frame.minY + 0.56250 * frame.height))
      powerPath.addCurveToPoint(CGPoint(x: frame.minX + 0.23214 * frame.width, y: frame.minY + 0.59375 * frame.height),
                  controlPoint1: CGPoint(x: frame.minX + 0.21429 * frame.width, y: frame.minY + 0.58125 * frame.height),
                  controlPoint2: CGPoint(x: frame.minX + 0.22143 * frame.width, y: frame.minY + 0.59375 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.41071 * frame.width, y: frame.minY + 0.59375 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.45893 * frame.width, y: frame.minY + 0.70625 * frame.height))
      powerPath.addCurveToPoint(CGPoint(x: frame.minX + 0.47321 * frame.width, y: frame.minY + 0.71875 * frame.height),
                  controlPoint1: CGPoint(x: frame.minX + 0.46250 * frame.width, y: frame.minY + 0.71562 * frame.height),
                  controlPoint2: CGPoint(x: frame.minX + 0.46786 * frame.width, y: frame.minY + 0.71875 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.62500 * frame.width, y: frame.minY + 0.71875 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.62500 * frame.width, y: frame.minY + 0.62500 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.71429 * frame.width, y: frame.minY + 0.62500 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.71429 * frame.width, y: frame.minY + 0.56250 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.62500 * frame.width, y: frame.minY + 0.56250 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.62500 * frame.width, y: frame.minY + 0.43750 * frame.height))
      powerPath.addLineToPoint(CGPoint(x: frame.minX + 0.71429 * frame.width, y: frame.minY + 0.43750 * frame.height))
      powerPath.closePath()
      powerPath.miterLimit = 4;

      strokeColor.setFill()
      powerPath.fill()
    }


    if (showCharging) {
      // Lightning Drawing
      var lightningPath = UIBezierPath()
      lightningPath.moveToPoint(CGPoint(x: frame.minX + 0.55153 * frame.width, y: frame.minY + 0.42366 * frame.height))
      lightningPath.addLineToPoint(CGPoint(x: frame.minX + 0.47675 * frame.width, y: frame.minY + 0.42366 * frame.height))
      lightningPath.addLineToPoint(CGPoint(x: frame.minX + 0.51414 * frame.width, y: frame.minY + 0.19463 * frame.height))
      lightningPath.addLineToPoint(CGPoint(x: frame.minX + 0.42689 * frame.width, y: frame.minY + 0.19463 * frame.height))
      lightningPath.addLineToPoint(CGPoint(x: frame.minX + 0.37704 * frame.width, y: frame.minY + 0.54362 * frame.height))
      lightningPath.addLineToPoint(CGPoint(x: frame.minX + 0.46429 * frame.width, y: frame.minY + 0.54362 * frame.height))
      lightningPath.addLineToPoint(CGPoint(x: frame.minX + 0.44559 * frame.width, y: frame.minY + 0.80537 * frame.height))
      lightningPath.addLineToPoint(CGPoint(x: frame.minX + 0.55153 * frame.width, y: frame.minY + 0.42366 * frame.height))
      lightningPath.closePath()
      lightningPath.miterLimit = 4;

      strokeColor.setFill()
      lightningPath.fill()
    }
  }

}
