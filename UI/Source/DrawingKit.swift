//
//  DrawingKit.swift
//  Remote
//
//  Created by Moondeer on 4/24/15.
//  Copyright (c) 2015 Moondeer Studios. All rights reserved.
//
//  Generated by PaintCode (www.paintcodeapp.com)
//



import UIKit

public class DrawingKit : NSObject {

  //// Cache

  private struct Cache {
    static var buttonBaseColor: UIColor = UIColor(red: 0.261, green: 0.258, blue: 0.258, alpha: 1.000)
    static var buttonStrokeColor: UIColor = DrawingKit.buttonBaseColor.colorWithHighlight(0.2)
    static var verticalGlossStop: UIColor = UIColor(red: 1.000, green: 1.000, blue: 1.000, alpha: 0.000)
    static var verticalGloss: CGGradient = CGGradientCreateWithColors(
      CGColorSpaceCreateDeviceRGB(),
      [DrawingKit.verticalGlossStop.CGColor,
       DrawingKit.verticalGlossStop.blendedColorWithFraction(0.5, ofColor: UIColor.whiteColor()).CGColor,
       UIColor.whiteColor().CGColor],
     [0, 1, 1]
   )
    static var innerShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 2)
    static var outerShadow: NSShadow = NSShadow(color: UIColor.blackColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 2)
    static var strokeShadow: NSShadow = NSShadow(color: UIColor.lightGrayColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 1)
    static var insettingShadow: NSShadow = NSShadow(color: UIColor.whiteColor().colorWithAlphaComponent(0.5), offset: CGSize(width: 0.1, height: 0.6), blurRadius: 0)
    static var plasticShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSize(width: 0.1, height: -0.6), blurRadius: 1)
    static var cutoutShadow: NSShadow = NSShadow(color: UIColor.blackColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 1)
    static var glowingShadow: NSShadow = NSShadow(color: UIColor.whiteColor(), offset: CGSize(width: 0.1, height: -0.1), blurRadius: 5)
  }

  //// Colors

  public class var buttonBaseColor: UIColor { return Cache.buttonBaseColor }
  public class var buttonStrokeColor: UIColor { return Cache.buttonStrokeColor }
  public class var verticalGlossStop: UIColor { return Cache.verticalGlossStop }

  //// Gradients

  public class var verticalGloss: CGGradient { return Cache.verticalGloss }

  //// Shadows

  public class var innerShadow: NSShadow { return Cache.innerShadow }
  public class var outerShadow: NSShadow { return Cache.outerShadow }
  public class var strokeShadow: NSShadow { return Cache.strokeShadow }
  public class var insettingShadow: NSShadow { return Cache.insettingShadow }
  public class var plasticShadow: NSShadow { return Cache.plasticShadow }
  public class var cutoutShadow: NSShadow { return Cache.cutoutShadow }
  public class var glowingShadow: NSShadow { return Cache.glowingShadow }

  //// Drawing Methods

  public class func drawRoundishButtonBase(#frame: CGRect, color: UIColor, radius: CGFloat) {
    //// General Declarations
    let context = UIGraphicsGetCurrentContext()

    //// Color Declarations
    let strokeColor = color.colorWithHighlight(0.4)


    //// Subframes
    let lightBase: CGRect = CGRect(
      x: frame.minX + 2,
      y: frame.minY + 2,
      width: frame.width - 4,
      height: frame.height - 4)


    //// darkOverlayRectangle Drawing
    let darkOverlayRectanglePath = UIBezierPath(roundedRect: CGRect(
      x: frame.minX + 2,
      y: frame.minY + 2,
      width: frame.width - 4,
      height: frame.height - 4), cornerRadius: radius)
    UIGraphicsPushContext(context)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.outerShadow.shadowOffset,
      DrawingKit.outerShadow.shadowBlurRadius,
      (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor
    )
    color.setFill()
    darkOverlayRectanglePath.fill()

    ////// darkOverlayRectangle Inner Shadow
    UIGraphicsPushContext(context)
    CGContextClipToRect(context, darkOverlayRectanglePath.bounds)
    CGContextSetShadow(context, CGSize(
      width: 0,
      height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let darkOverlayRectangleOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.innerShadow.shadowOffset,
      DrawingKit.innerShadow.shadowBlurRadius,
      darkOverlayRectangleOpaqueShadow.CGColor
    )
    CGContextSetBlendMode(context, kCGBlendModeSourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    darkOverlayRectangleOpaqueShadow.setFill()
    darkOverlayRectanglePath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()

    UIGraphicsPopContext()

    UIGraphicsPushContext(context)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.strokeShadow.shadowOffset,
      DrawingKit.strokeShadow.shadowBlurRadius,
      (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor
    )
    strokeColor.setStroke()
    darkOverlayRectanglePath.lineWidth = 1
    darkOverlayRectanglePath.stroke()
    UIGraphicsPopContext()


    //// lightBase
    UIGraphicsPushContext(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)

    //// Clip lightBaseClip
    let lightBaseClipPath = UIBezierPath(roundedRect: CGRect(
      x: lightBase.minX + floor(lightBase.width * 0.0 + 0.5),
      y: lightBase.minY + floor(lightBase.height * 0.0 + 0.5),
      width: floor(lightBase.width * 1.0 + 0.5) - floor(lightBase.width * 0.0 + 0.5),
      height: floor(lightBase.height * 1.0 + 0.5) - floor(lightBase.height * 0.0 + 0.5)), cornerRadius: radius)
    lightBaseClipPath.addClip()


    //// lightBaseFillRect Drawing
    let lightBaseFillRectRect = CGRect(
      x: lightBase.minX + floor(lightBase.width * -0.02041 + 0.5),
      y: lightBase.minY + floor(lightBase.height * -0.03061 + 0.5),
      width: floor(lightBase.width * 1.02041 + 0.5) - floor(lightBase.width * -0.02041 + 0.5),
      height: floor(lightBase.height * 1.01020 + 0.5) - floor(lightBase.height * -0.03061 + 0.5))
    let lightBaseFillRectPath = UIBezierPath(rect: lightBaseFillRectRect)
    UIGraphicsPushContext(context)
    lightBaseFillRectPath.addClip()
    CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
      CGPoint(
        x: lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 204,
        y: lightBaseFillRectRect.midY + 102 * lightBaseFillRectRect.height / 204),
      CGPoint(
        x: lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 204,
        y: lightBaseFillRectRect.midY + 0 * lightBaseFillRectRect.height / 204),
      UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
    UIGraphicsPopContext()


    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()
  }

  public class func drawGloss(#frame: CGRect) {
    //// General Declarations
    let context = UIGraphicsGetCurrentContext()


    //// Subframes
    let group: CGRect = CGRect(
      x: frame.minX,
      y: frame.minY,
      width: frame.width,
      height: frame.height)


    //// Group
    UIGraphicsPushContext(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)


    //// Rectangle Drawing
    let rectangleRect = CGRect(
      x: group.minX + floor(group.width * 0.0 + 0.5),
      y: group.minY + floor(group.height * 0.0 + 0.5),
      width: floor(group.width * 1.0 + 0.5) - floor(group.width * 0.0 + 0.5),
      height: floor(group.height * 1.0 + 0.5) - floor(group.height * 0.0 + 0.5))
    let rectanglePath = UIBezierPath(rect: rectangleRect)
    UIGraphicsPushContext(context)
    rectanglePath.addClip()
    CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
      CGPoint(
        x: rectangleRect.midX + 0 * rectangleRect.width / 200,
        y: rectangleRect.midY + 100 * rectangleRect.height / 200),
      CGPoint(
        x: rectangleRect.midX + 0 * rectangleRect.width / 200,
        y: rectangleRect.midY + 0 * rectangleRect.height / 200),
      UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
    UIGraphicsPopContext()


    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()
  }

  public class func drawRectangularButtonBase(#frame: CGRect, color: UIColor) {
    //// General Declarations
    let context = UIGraphicsGetCurrentContext()

    //// Color Declarations
    let strokeColor = color.colorWithHighlight(0.4)


    //// Subframes
    let lightBase: CGRect = CGRect(
      x: frame.minX + 2,
      y: frame.minY + 2,
      width: frame.width - 4,
      height: frame.height - 4)


    //// darkOverlayRect Drawing
    let darkOverlayRectPath = UIBezierPath(rect: CGRect(
      x: frame.minX + 2,
      y: frame.minY + 2,
      width: frame.width - 4,
      height: frame.height - 4))
    UIGraphicsPushContext(context)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.outerShadow.shadowOffset,
      DrawingKit.outerShadow.shadowBlurRadius,
      (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor
    )
    color.setFill()
    darkOverlayRectPath.fill()

    ////// darkOverlayRect Inner Shadow
    UIGraphicsPushContext(context)
    CGContextClipToRect(context, darkOverlayRectPath.bounds)
    CGContextSetShadow(context, CGSize(
      width: 0,
      height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let darkOverlayRectOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.innerShadow.shadowOffset,
      DrawingKit.innerShadow.shadowBlurRadius,
      darkOverlayRectOpaqueShadow.CGColor
    )
    CGContextSetBlendMode(context, kCGBlendModeSourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    darkOverlayRectOpaqueShadow.setFill()
    darkOverlayRectPath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()

    UIGraphicsPopContext()

    UIGraphicsPushContext(context)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.strokeShadow.shadowOffset,
      DrawingKit.strokeShadow.shadowBlurRadius,
      (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor
    )
    strokeColor.setStroke()
    darkOverlayRectPath.lineWidth = 1
    darkOverlayRectPath.stroke()
    UIGraphicsPopContext()


    //// lightBase
    UIGraphicsPushContext(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)

    //// Clip lightBaseClipRect
    let lightBaseClipRectPath = UIBezierPath(rect: CGRect(
      x: lightBase.minX + floor(lightBase.width * 0.0 + 0.5),
      y: lightBase.minY + floor(lightBase.height * 0.0 + 0.5),
      width: floor(lightBase.width * 1.0 + 0.5) - floor(lightBase.width * 0.0 + 0.5),
      height: floor(lightBase.height * 1.0 + 0.5) - floor(lightBase.height * 0.0 + 0.5)))
    lightBaseClipRectPath.addClip()


    //// lightBaseFillRect Drawing
    let lightBaseFillRectRect = CGRect(
      x: lightBase.minX + floor(lightBase.width * -0.01020 + 0.5),
      y: lightBase.minY + floor(lightBase.height * -0.02806) + 0.5,
      width: floor(lightBase.width * 1.03061 + 0.5) - floor(lightBase.width * -0.01020 + 0.5),
      height: floor(lightBase.height * 1.01786) - floor(lightBase.height * -0.02806))
    let lightBaseFillRectPath = UIBezierPath(rect: lightBaseFillRectRect)
    UIGraphicsPushContext(context)
    lightBaseFillRectPath.addClip()
    CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
      CGPoint(
        x: lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 204,
        y: lightBaseFillRectRect.midY + 102.5 * lightBaseFillRectRect.height / 205),
      CGPoint(
        x: lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 204,
        y: lightBaseFillRectRect.midY + 0 * lightBaseFillRectRect.height / 205),
      UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
    UIGraphicsPopContext()


    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()
  }

  public class func drawOvalButtonBase(#frame: CGRect, color: UIColor) {
    //// General Declarations
    let context = UIGraphicsGetCurrentContext()

    //// Color Declarations
    let strokeColor = color.colorWithHighlight(0.4)


    //// Subframes
    let lightBase: CGRect = CGRect(x: frame.minX + 2, y: frame.minY + 2, width: frame.width - 4, height: frame.height - 4)


    //// darkOverlayOval Drawing
    var darkOverlayOvalPath = UIBezierPath(ovalInRect: CGRect(x: frame.minX + 2, y: frame.minY + 2, width: frame.width - 4, height: frame.height - 4))
    UIGraphicsPushContext(context)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.outerShadow.shadowOffset,
      DrawingKit.outerShadow.shadowBlurRadius,
      (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor
    )
    color.setFill()
    darkOverlayOvalPath.fill()

    ////// darkOverlayOval Inner Shadow
    UIGraphicsPushContext(context)
    CGContextClipToRect(context, darkOverlayOvalPath.bounds)
    CGContextSetShadow(context, CGSize(
      width: 0,
      height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let darkOverlayOvalOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.innerShadow.shadowOffset,
      DrawingKit.innerShadow.shadowBlurRadius,
      darkOverlayOvalOpaqueShadow.CGColor
    )
    CGContextSetBlendMode(context, kCGBlendModeSourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    darkOverlayOvalOpaqueShadow.setFill()
    darkOverlayOvalPath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()

    UIGraphicsPopContext()

    UIGraphicsPushContext(context)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.strokeShadow.shadowOffset,
      DrawingKit.strokeShadow.shadowBlurRadius,
      (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor
    )
    strokeColor.setStroke()
    darkOverlayOvalPath.lineWidth = 1
    darkOverlayOvalPath.stroke()
    UIGraphicsPopContext()


    //// lightBase
    UIGraphicsPushContext(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)

    //// Clip lightBaseClipRect
    var lightBaseClipRectPath = UIBezierPath(ovalInRect: CGRect(
      x: lightBase.minX + floor(lightBase.width * 0.0 + 0.5),
      y: lightBase.minY + floor(lightBase.height * 0.0 + 0.5),
      width: floor(lightBase.width * 1.0 + 0.5) - floor(lightBase.width * 0.0 + 0.5),
      height: floor(lightBase.height * 1.0 + 0.5) - floor(lightBase.height * 0.0 + 0.5)))
    lightBaseClipRectPath.addClip()


    //// lightBaseFillRect Drawing
    let lightBaseFillRectRect = CGRect(
      x: lightBase.minX + floor(lightBase.width * -0.02041 + 0.5),
      y: lightBase.minY + floor(lightBase.height * -0.02041 + 0.5),
      width: floor(lightBase.width * 1.02041 + 0.5) - floor(lightBase.width * -0.02041 + 0.5),
      height: floor(lightBase.height * 1.02041 + 0.5) - floor(lightBase.height * -0.02041 + 0.5))
    let lightBaseFillRectPath = UIBezierPath(rect: lightBaseFillRectRect)
    UIGraphicsPushContext(context)
    lightBaseFillRectPath.addClip()
    CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
      CGPoint(
        x: lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 204,
        y: lightBaseFillRectRect.midY + 102 * lightBaseFillRectRect.height / 204),
      CGPoint(
        x: lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 204,
        y: lightBaseFillRectRect.midY + 0 * lightBaseFillRectRect.height / 204),
      UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
    UIGraphicsPopContext()


    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()
  }

  public class func drawDiamondButtonBase(#frame: CGRect, color: UIColor) {
    //// General Declarations
    let context = UIGraphicsGetCurrentContext()

    //// Color Declarations
    let strokeColor = color.colorWithHighlight(0.4)


    //// Subframes
    let lightBase: CGRect = CGRect(
      x: frame.minX + 2,
      y: frame.minY + 2,
      width: frame.width - 4,
      height: frame.height - 4)


    //// darkOverlayDiamond Drawing
    var darkOverlayDiamondPath = UIBezierPath()
    darkOverlayDiamondPath.moveToPoint(CGPoint(x: frame.minX + 2, y: frame.minY + 0.5 * frame.height))
    darkOverlayDiamondPath.addLineToPoint(CGPoint(x: frame.minX + 0.5 * frame.width, y: frame.minY + 2))
    darkOverlayDiamondPath.addLineToPoint(CGPoint(x: frame.maxX - 2, y: frame.minY + 0.5 * frame.height))
    darkOverlayDiamondPath.addLineToPoint(CGPoint(x: frame.minX + 0.5 * frame.width, y: frame.maxY - 2))
    darkOverlayDiamondPath.addLineToPoint(CGPoint(x: frame.minX + 2, y: frame.minY + 0.5 * frame.height))
    darkOverlayDiamondPath.closePath()
    UIGraphicsPushContext(context)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.outerShadow.shadowOffset,
      DrawingKit.outerShadow.shadowBlurRadius,
      (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor
    )
    color.setFill()
    darkOverlayDiamondPath.fill()

    ////// darkOverlayDiamond Inner Shadow
    UIGraphicsPushContext(context)
    CGContextClipToRect(context, darkOverlayDiamondPath.bounds)
    CGContextSetShadow(context, CGSize(
      width: 0,
      height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let darkOverlayDiamondOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.innerShadow.shadowOffset,
      DrawingKit.innerShadow.shadowBlurRadius,
      darkOverlayDiamondOpaqueShadow.CGColor
    )
    CGContextSetBlendMode(context, kCGBlendModeSourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    darkOverlayDiamondOpaqueShadow.setFill()
    darkOverlayDiamondPath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()

    UIGraphicsPopContext()

    UIGraphicsPushContext(context)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.strokeShadow.shadowOffset,
      DrawingKit.strokeShadow.shadowBlurRadius,
      (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor
    )
    strokeColor.setStroke()
    darkOverlayDiamondPath.lineWidth = 1
    darkOverlayDiamondPath.stroke()
    UIGraphicsPopContext()


    //// lightBase
    UIGraphicsPushContext(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)

    //// Clip lightBaseClipRect
    var lightBaseClipRectPath = UIBezierPath()
    lightBaseClipRectPath.moveToPoint(CGPoint(x: lightBase.minX + 0.0 * lightBase.width, y: lightBase.minY + 0.5 * lightBase.height))
    lightBaseClipRectPath.addLineToPoint(CGPoint(x: lightBase.minX + 0.5 * lightBase.width, y: lightBase.minY + 0.0 * lightBase.height))
    lightBaseClipRectPath.addLineToPoint(CGPoint(x: lightBase.minX + 1.0 * lightBase.width, y: lightBase.minY + 0.5 * lightBase.height))
    lightBaseClipRectPath.addLineToPoint(CGPoint(x: lightBase.minX + 0.5 * lightBase.width, y: lightBase.minY + 1.0 * lightBase.height))
    lightBaseClipRectPath.addLineToPoint(CGPoint(x: lightBase.minX + 0.0 * lightBase.width, y: lightBase.minY + 0.5 * lightBase.height))
    lightBaseClipRectPath.closePath()
    lightBaseClipRectPath.addClip()


    //// lightBaseFillRect Drawing
    let lightBaseFillRectRect = CGRect(
      x: lightBase.minX + floor(lightBase.width * -0.02041 + 0.5),
      y: lightBase.minY + floor(lightBase.height * -0.02041 + 0.5),
      width: floor(lightBase.width * 1.02041 + 0.5) - floor(lightBase.width * -0.02041 + 0.5),
      height: floor(lightBase.height * 1.02041 + 0.5) - floor(lightBase.height * -0.02041 + 0.5))
    let lightBaseFillRectPath = UIBezierPath(rect: lightBaseFillRectRect)
    UIGraphicsPushContext(context)
    lightBaseFillRectPath.addClip()
    CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
      CGPoint(
        x: lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 204,
        y: lightBaseFillRectRect.midY + 102 * lightBaseFillRectRect.height / 204),
      CGPoint(
        x: lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 204,
        y: lightBaseFillRectRect.midY + 0 * lightBaseFillRectRect.height / 204),
      UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
    UIGraphicsPopContext()


    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()
  }

  public class func drawTriangleButtonBase(#frame: CGRect, color: UIColor) {
    //// General Declarations
    let context = UIGraphicsGetCurrentContext()

    //// Color Declarations
    let strokeColor = color.colorWithHighlight(0.4)


    //// Subframes
    let overlayGroup: CGRect = CGRect(
      x: frame.minX + 7.2,
      y: frame.minY + 9.5,
      width: frame.width - 13.4,
      height: frame.height - 25)
    let lightBase: CGRect = CGRect(
      x: frame.minX + 7.2,
      y: frame.minY + 9.5,
      width: frame.width - 13.4,
      height: frame.height - 25)


    //// Overlay Group
    //// darkOverlayTriangle Drawing
    var darkOverlayTrianglePath = UIBezierPath()
    darkOverlayTrianglePath.moveToPoint(CGPoint(x: overlayGroup.minX + 0.5 * overlayGroup.width, y: overlayGroup.minY + 0.0 * overlayGroup.height))
    darkOverlayTrianglePath.addLineToPoint(CGPoint(x: overlayGroup.minX + 0.75 * overlayGroup.width, y: overlayGroup.minY + 0.5 * overlayGroup.height))
    darkOverlayTrianglePath.addLineToPoint(CGPoint(x: overlayGroup.minX + 1.0 * overlayGroup.width, y: overlayGroup.minY + 1.0 * overlayGroup.height))
    darkOverlayTrianglePath.addLineToPoint(CGPoint(x: overlayGroup.minX + 0.5 * overlayGroup.width, y: overlayGroup.minY + 1.0 * overlayGroup.height))
    darkOverlayTrianglePath.addLineToPoint(CGPoint(x: overlayGroup.minX + 0.0 * overlayGroup.width, y: overlayGroup.minY + 1.0 * overlayGroup.height))
    darkOverlayTrianglePath.addLineToPoint(CGPoint(x: overlayGroup.minX + 0.25 * overlayGroup.width, y: overlayGroup.minY + 0.5 * overlayGroup.height))
    darkOverlayTrianglePath.addLineToPoint(CGPoint(x: overlayGroup.minX + 0.5 * overlayGroup.width, y: overlayGroup.minY + 0.0 * overlayGroup.height))
    darkOverlayTrianglePath.closePath()
    UIGraphicsPushContext(context)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.outerShadow.shadowOffset,
      DrawingKit.outerShadow.shadowBlurRadius,
      (DrawingKit.outerShadow.shadowColor as! UIColor).CGColor
    )
    color.setFill()
    darkOverlayTrianglePath.fill()

    ////// darkOverlayTriangle Inner Shadow
    UIGraphicsPushContext(context)
    CGContextClipToRect(context, darkOverlayTrianglePath.bounds)
    CGContextSetShadow(context, CGSize(
      width: 0,
      height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.innerShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let darkOverlayTriangleOpaqueShadow = (DrawingKit.innerShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.innerShadow.shadowOffset,
      DrawingKit.innerShadow.shadowBlurRadius,
      darkOverlayTriangleOpaqueShadow.CGColor
    )
    CGContextSetBlendMode(context, kCGBlendModeSourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    darkOverlayTriangleOpaqueShadow.setFill()
    darkOverlayTrianglePath.fill()

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()

    UIGraphicsPopContext()

    UIGraphicsPushContext(context)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.strokeShadow.shadowOffset,
      DrawingKit.strokeShadow.shadowBlurRadius,
      (DrawingKit.strokeShadow.shadowColor as! UIColor).CGColor
    )
    strokeColor.setStroke()
    darkOverlayTrianglePath.lineWidth = 1
    darkOverlayTrianglePath.stroke()
    UIGraphicsPopContext()




    //// lightBase
    UIGraphicsPushContext(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)

    //// Clip lightBaseClipRect
    var lightBaseClipRectPath = UIBezierPath()
    lightBaseClipRectPath.moveToPoint(CGPoint(x: lightBase.minX + 0.5 * lightBase.width, y: lightBase.minY + 0.0 * lightBase.height))
    lightBaseClipRectPath.addLineToPoint(CGPoint(x: lightBase.minX + 0.75 * lightBase.width, y: lightBase.minY + 0.5 * lightBase.height))
    lightBaseClipRectPath.addLineToPoint(CGPoint(x: lightBase.minX + 1.0 * lightBase.width, y: lightBase.minY + 1.0 * lightBase.height))
    lightBaseClipRectPath.addLineToPoint(CGPoint(x: lightBase.minX + 0.5 * lightBase.width, y: lightBase.minY + 1.0 * lightBase.height))
    lightBaseClipRectPath.addLineToPoint(CGPoint(x: lightBase.minX + 0.0 * lightBase.width, y: lightBase.minY + 1.0 * lightBase.height))
    lightBaseClipRectPath.addLineToPoint(CGPoint(x: lightBase.minX + 0.25 * lightBase.width, y: lightBase.minY + 0.5 * lightBase.height))
    lightBaseClipRectPath.addLineToPoint(CGPoint(x: lightBase.minX + 0.5 * lightBase.width, y: lightBase.minY + 0.0 * lightBase.height))
    lightBaseClipRectPath.closePath()
    lightBaseClipRectPath.addClip()


    //// lightBaseFillRect Drawing
    let lightBaseFillRectRect = CGRect(
      x: lightBase.minX + floor(lightBase.width * -0.08145 - 0.3) + 0.8,
      y: lightBase.minY + floor(lightBase.height * -0.13143 + 0.5),
      width: floor(lightBase.width * 1.07073 - 0.3) - floor(lightBase.width * -0.08145 - 0.3),
      height: floor(lightBase.height * 1.20000 + 0.5) - floor(lightBase.height * -0.13143 + 0.5))
    let lightBaseFillRectPath = UIBezierPath(rect: lightBaseFillRectRect)
    UIGraphicsPushContext(context)
    lightBaseFillRectPath.addClip()
    CGContextDrawLinearGradient(context, DrawingKit.verticalGloss,
      CGPoint(
        x: lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 215,
        y: lightBaseFillRectRect.midY + 116.5 * lightBaseFillRectRect.height / 233),
      CGPoint(
        x: lightBaseFillRectRect.midX + 0 * lightBaseFillRectRect.width / 215,
        y: lightBaseFillRectRect.midY + 0 * lightBaseFillRectRect.height / 233),
      UInt32(kCGGradientDrawsBeforeStartLocation) | UInt32(kCGGradientDrawsAfterEndLocation))
    UIGraphicsPopContext()


    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()
  }

  public class func drawBatteryStatus(#batteryBaseColor: UIColor, hasPower: Bool, chargeLevel: CGFloat, containingFrame: CGRect) {
    //// General Declarations
    let context = UIGraphicsGetCurrentContext()


    //// Variable Declarations
    let squaredContainingFrameSize = CGSize(
      width: min(containingFrame.size.width, containingFrame.size.height),
      height: min(containingFrame.size.width, containingFrame.size.height))
    let squaredContainingFrame = CGRect(
      x: containingFrame.origin.x + (containingFrame.size.width - squaredContainingFrameSize.width) / 2.0,
      y: containingFrame.origin.y + (containingFrame.size.height - squaredContainingFrameSize.height) / 2.0,
      width: squaredContainingFrameSize.width,
      height: squaredContainingFrameSize.height)
    let batteryFrame = CGRect(
      x: squaredContainingFrame.origin.x,
      y: squaredContainingFrame.origin.y + (squaredContainingFrame.size.height - squaredContainingFrame.size.width * 4 / 7.0) / 2.0,
      width: squaredContainingFrame.size.width,
      height: squaredContainingFrame.size.width * 4 / 7.0)

    //// Frames
    let frame = CGRect(
      x: batteryFrame.origin.x,
      y: batteryFrame.origin.y,
      width: batteryFrame.size.width,
      height: batteryFrame.size.height)


    //// Symbol Drawing
    let symbolRect = CGRect(
      x: frame.minX + floor(frame.width * 0.0 + 0.5),
      y: frame.minY + floor(frame.height * -0.0 + 0.5),
      width: floor(frame.width * 1.0 + 0.5) - floor(frame.width * 0.0 + 0.5),
      height: floor(frame.height * 1.0 + 0.21) - floor(frame.height * -0.0 + 0.5) + 0.29)
    UIGraphicsPushContext(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)
    CGContextScaleCTM(context, symbolRect.size.width / 224, symbolRect.size.height / 128)

    DrawingKit.drawBatteryIcon(batteryBaseColor: batteryBaseColor, hasPower: hasPower, chargeLevel: chargeLevel)
    UIGraphicsPopContext()
  }

  public class func drawBatteryIcon(#batteryBaseColor: UIColor, hasPower: Bool, chargeLevel: CGFloat) {
    //// Color Declarations
    let batteryIconColor = batteryBaseColor.colorWithHighlight(0.3)

    //// Variable Declarations
    let showPower = hasPower && chargeLevel == 1
    let showCharging = hasPower && chargeLevel < 1
    let chargeMaxX: CGFloat = 16 + 175 * chargeLevel

    //// Outline Drawing
    var outlinePath = UIBezierPath()
    outlinePath.moveToPoint(CGPoint(x: 208, y: 44))
    outlinePath.addLineToPoint(CGPoint(x: 208, y: 84))
    outlinePath.addCurveToPoint(CGPoint(x: 216, y: 76),
                           controlPoint1: CGPoint(x: 212.42, y: 84),
                           controlPoint2: CGPoint(x: 216, y: 80.42))
    outlinePath.addLineToPoint(CGPoint(x: 216, y: 52))
    outlinePath.addCurveToPoint(CGPoint(x: 208, y: 44),
                           controlPoint1: CGPoint(x: 216, y: 47.58),
                           controlPoint2: CGPoint(x: 212.42, y: 44))
    outlinePath.closePath()
    outlinePath.moveToPoint(CGPoint(x: 144, y: 16))
    outlinePath.addLineToPoint(CGPoint(x: 16.03, y: 16))
    outlinePath.addLineToPoint(CGPoint(x: 16.03, y: 112))
    outlinePath.addCurveToPoint(CGPoint(x: 16, y: 16),
                           controlPoint1: CGPoint(x: 16, y: 112),
                           controlPoint2: CGPoint(x: 16, y: 16))
    outlinePath.addLineToPoint(CGPoint(x: 144, y: 16))
    outlinePath.closePath()
    outlinePath.moveToPoint(CGPoint(x: 192, y: 8))
    outlinePath.addLineToPoint(CGPoint(x: 16, y: 8))
    outlinePath.addCurveToPoint(CGPoint(x: 8, y: 16),
                           controlPoint1: CGPoint(x: 11.58, y: 8),
                           controlPoint2: CGPoint(x: 8, y: 11.58))
    outlinePath.addLineToPoint(CGPoint(x: 8, y: 112))
    outlinePath.addCurveToPoint(CGPoint(x: 16, y: 120),
                           controlPoint1: CGPoint(x: 8, y: 116.42),
                           controlPoint2: CGPoint(x: 11.58, y: 120))
    outlinePath.addLineToPoint(CGPoint(x: 192, y: 120))
    outlinePath.addCurveToPoint(CGPoint(x: 200, y: 112),
                           controlPoint1: CGPoint(x: 196.42, y: 120),
                           controlPoint2: CGPoint(x: 200, y: 116.42))
    outlinePath.addLineToPoint(CGPoint(x: 200, y: 16))
    outlinePath.addCurveToPoint(CGPoint(x: 192, y: 8),
                           controlPoint1: CGPoint(x: 200, y: 11.58),
                           controlPoint2: CGPoint(x: 196.42, y: 8))
    outlinePath.closePath()
    outlinePath.moveToPoint(CGPoint(x: 208, y: 16))
    outlinePath.addLineToPoint(CGPoint(x: 208, y: 36))
    outlinePath.addLineToPoint(CGPoint(x: 216, y: 36))
    outlinePath.addCurveToPoint(CGPoint(x: 224, y: 44),
                           controlPoint1: CGPoint(x: 220.42, y: 36),
                           controlPoint2: CGPoint(x: 224, y: 39.58))
    outlinePath.addLineToPoint(CGPoint(x: 224, y: 84))
    outlinePath.addCurveToPoint(CGPoint(x: 216, y: 92),
                           controlPoint1: CGPoint(x: 224, y: 88.42),
                           controlPoint2: CGPoint(x: 220.42, y: 92))
    outlinePath.addLineToPoint(CGPoint(x: 208, y: 92))
    outlinePath.addLineToPoint(CGPoint(x: 208, y: 112))
    outlinePath.addCurveToPoint(CGPoint(x: 192, y: 128),
                           controlPoint1: CGPoint(x: 208, y: 120.84),
                           controlPoint2: CGPoint(x: 200.84, y: 128))
    outlinePath.addLineToPoint(CGPoint(x: 16, y: 128))
    outlinePath.addCurveToPoint(CGPoint(x: 0, y: 112),
                           controlPoint1: CGPoint(x: 7.16, y: 128),
                           controlPoint2: CGPoint(x: 0, y: 120.84))
    outlinePath.addLineToPoint(CGPoint(x: 0, y: 16))
    outlinePath.addCurveToPoint(CGPoint(x: 10.1, y: 1.12),
                           controlPoint1: CGPoint(x: 0, y: 9.25),
                           controlPoint2: CGPoint(x: 4.18, y: 3.47))
    outlinePath.addCurveToPoint(CGPoint(x: 16, y: 0),
                           controlPoint1: CGPoint(x: 11.93, y: 0.4),
                           controlPoint2: CGPoint(x: 13.92, y: 0))
    outlinePath.addLineToPoint(CGPoint(x: 192, y: 0))
    outlinePath.addCurveToPoint(CGPoint(x: 208, y: 16),
                           controlPoint1: CGPoint(x: 200.84, y: 0),
                           controlPoint2: CGPoint(x: 208, y: 7.16))
    outlinePath.closePath()
    batteryBaseColor.setFill()
    outlinePath.fill()


    //// Charge Drawing
    var chargePath = UIBezierPath()
    chargePath.moveToPoint(CGPoint(x: 16, y: 112))
    chargePath.addLineToPoint(CGPoint(x: chargeMaxX, y: 112))
    chargePath.addLineToPoint(CGPoint(x: chargeMaxX, y: 16))
    chargePath.addLineToPoint(CGPoint(x: 16, y: 16))
    chargePath.addLineToPoint(CGPoint(x: 16, y: 112))
    chargePath.closePath()
    batteryBaseColor.setFill()
    chargePath.fill()


    if (showCharging) {
      //// Lightning Bolt Drawing
      var lightningBoltPath = UIBezierPath()
      lightningBoltPath.moveToPoint(CGPoint(x: 130.91, y: 51.57))
      lightningBoltPath.addLineToPoint(CGPoint(x: 109.6, y: 51.57))
      lightningBoltPath.addLineToPoint(CGPoint(x: 120.26, y: 14.27))
      lightningBoltPath.addLineToPoint(CGPoint(x: 95.39, y: 14.27))
      lightningBoltPath.addLineToPoint(CGPoint(x: 81.18, y: 71.1))
      lightningBoltPath.addLineToPoint(CGPoint(x: 106.05, y: 71.1))
      lightningBoltPath.addLineToPoint(CGPoint(x: 100.72, y: 113.73))
      lightningBoltPath.addLineToPoint(CGPoint(x: 130.91, y: 51.57))
      lightningBoltPath.closePath()
      lightningBoltPath.usesEvenOddFillRule = true;

      batteryIconColor.setFill()
      lightningBoltPath.fill()
    }


    if (showPower) {
      //// Plug Drawing
      var plugPath = UIBezierPath()
      plugPath.moveToPoint(CGPoint(x: 161.55, y: 56))
      plugPath.addLineToPoint(CGPoint(x: 161.55, y: 48))
      plugPath.addLineToPoint(CGPoint(x: 141.55, y: 48))
      plugPath.addLineToPoint(CGPoint(x: 141.55, y: 36))
      plugPath.addLineToPoint(CGPoint(x: 107.55, y: 36))
      plugPath.addCurveToPoint(CGPoint(x: 104.35, y: 37.6),
                             controlPoint1: CGPoint(x: 106.29, y: 36),
                             controlPoint2: CGPoint(x: 105.1, y: 36.59))
      plugPath.addLineToPoint(CGPoint(x: 93.55, y: 52))
      plugPath.addLineToPoint(CGPoint(x: 53.55, y: 52))
      plugPath.addCurveToPoint(CGPoint(x: 49.55, y: 56),
                             controlPoint1: CGPoint(x: 51.34, y: 52),
                             controlPoint2: CGPoint(x: 49.55, y: 53.79))
      plugPath.addLineToPoint(CGPoint(x: 49.55, y: 72))
      plugPath.addCurveToPoint(CGPoint(x: 53.55, y: 76),
                             controlPoint1: CGPoint(x: 49.55, y: 74.21),
                             controlPoint2: CGPoint(x: 51.34, y: 76))
      plugPath.addLineToPoint(CGPoint(x: 93.55, y: 76))
      plugPath.addLineToPoint(CGPoint(x: 104.35, y: 90.4))
      plugPath.addCurveToPoint(CGPoint(x: 107.55, y: 92),
                             controlPoint1: CGPoint(x: 105.1, y: 91.41),
                             controlPoint2: CGPoint(x: 106.29, y: 92))
      plugPath.addLineToPoint(CGPoint(x: 141.55, y: 92))
      plugPath.addLineToPoint(CGPoint(x: 141.55, y: 80))
      plugPath.addLineToPoint(CGPoint(x: 161.55, y: 80))
      plugPath.addLineToPoint(CGPoint(x: 161.55, y: 72))
      plugPath.addLineToPoint(CGPoint(x: 141.55, y: 72))
      plugPath.addLineToPoint(CGPoint(x: 141.55, y: 56))
      plugPath.addLineToPoint(CGPoint(x: 161.55, y: 56))
      plugPath.closePath()
      batteryIconColor.setFill()
      plugPath.fill()
    }
  }

  public class func drawWifiIcon(#iconColor: UIColor, connected: Bool) {

    //// Variable Declarations
    let notConnected = !connected

    if (connected) {
      //// Connected Icon Drawing
      var connectedIconPath = UIBezierPath()
      connectedIconPath.moveToPoint(CGPoint(x: 181.46, y: 43.82))
      connectedIconPath.addLineToPoint(CGPoint(x: 181.52, y: 43.79))
      connectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 0),
                             controlPoint1: CGPoint(x: 180.42, y: 42),
                             controlPoint2: CGPoint(x: 153.85, y: 0))
      connectedIconPath.addCurveToPoint(CGPoint(x: 0.48, y: 43.79),
                             controlPoint1: CGPoint(x: 28.15, y: 0),
                             controlPoint2: CGPoint(x: 1.58, y: 42))
      connectedIconPath.addLineToPoint(CGPoint(x: 0.54, y: 43.82))
      connectedIconPath.addCurveToPoint(CGPoint(x: 0, y: 45.52),
                             controlPoint1: CGPoint(x: 0.23, y: 44.33),
                             controlPoint2: CGPoint(x: 0, y: 44.88))
      connectedIconPath.addCurveToPoint(CGPoint(x: 0.95, y: 47.81),
                             controlPoint1: CGPoint(x: 0, y: 46.41),
                             controlPoint2: CGPoint(x: 0.36, y: 47.23))
      connectedIconPath.addLineToPoint(CGPoint(x: 10.7, y: 57.56))
      connectedIconPath.addCurveToPoint(CGPoint(x: 13, y: 58.51),
                             controlPoint1: CGPoint(x: 11.29, y: 58.15),
                             controlPoint2: CGPoint(x: 12.1, y: 58.51))
      connectedIconPath.addCurveToPoint(CGPoint(x: 15.67, y: 57.02),
                             controlPoint1: CGPoint(x: 14.14, y: 58.51),
                             controlPoint2: CGPoint(x: 15.09, y: 57.9))
      connectedIconPath.addLineToPoint(CGPoint(x: 15.7, y: 57.04))
      connectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 19.5),
                             controlPoint1: CGPoint(x: 15.95, y: 56.67),
                             controlPoint2: CGPoint(x: 41.31, y: 19.5))
      connectedIconPath.addCurveToPoint(CGPoint(x: 166.3, y: 57.05),
                             controlPoint1: CGPoint(x: 140.55, y: 19.5),
                             controlPoint2: CGPoint(x: 166.05, y: 56.67))
      connectedIconPath.addLineToPoint(CGPoint(x: 166.34, y: 57.02))
      connectedIconPath.addCurveToPoint(CGPoint(x: 169, y: 58.51),
                             controlPoint1: CGPoint(x: 166.92, y: 57.9),
                             controlPoint2: CGPoint(x: 167.87, y: 58.51))
      connectedIconPath.addCurveToPoint(CGPoint(x: 171.3, y: 57.56),
                             controlPoint1: CGPoint(x: 169.9, y: 58.51),
                             controlPoint2: CGPoint(x: 170.71, y: 58.15))
      connectedIconPath.addLineToPoint(CGPoint(x: 181.05, y: 47.81))
      connectedIconPath.addCurveToPoint(CGPoint(x: 182, y: 45.52),
                             controlPoint1: CGPoint(x: 181.64, y: 47.23),
                             controlPoint2: CGPoint(x: 182, y: 46.41))
      connectedIconPath.addCurveToPoint(CGPoint(x: 181.46, y: 43.82),
                             controlPoint1: CGPoint(x: 182, y: 44.88),
                             controlPoint2: CGPoint(x: 181.77, y: 44.33))
      connectedIconPath.closePath()
      connectedIconPath.moveToPoint(CGPoint(x: 129.29, y: 95.45))
      connectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 77.99),
                             controlPoint1: CGPoint(x: 128.72, y: 94.74),
                             controlPoint2: CGPoint(x: 115.04, y: 77.99))
      connectedIconPath.addCurveToPoint(CGPoint(x: 52.71, y: 95.45),
                             controlPoint1: CGPoint(x: 66.97, y: 77.99),
                             controlPoint2: CGPoint(x: 53.28, y: 94.74))
      connectedIconPath.addLineToPoint(CGPoint(x: 52.76, y: 95.49))
      connectedIconPath.addCurveToPoint(CGPoint(x: 52, y: 97.51),
                             controlPoint1: CGPoint(x: 52.31, y: 96.05),
                             controlPoint2: CGPoint(x: 52, y: 96.73))
      connectedIconPath.addCurveToPoint(CGPoint(x: 52.95, y: 99.8),
                             controlPoint1: CGPoint(x: 52, y: 98.4),
                             controlPoint2: CGPoint(x: 52.36, y: 99.22))
      connectedIconPath.addLineToPoint(CGPoint(x: 62.7, y: 109.55))
      connectedIconPath.addCurveToPoint(CGPoint(x: 65, y: 110.5),
                             controlPoint1: CGPoint(x: 63.29, y: 110.14),
                             controlPoint2: CGPoint(x: 64.1, y: 110.5))
      connectedIconPath.addCurveToPoint(CGPoint(x: 67.56, y: 109.16),
                             controlPoint1: CGPoint(x: 66.07, y: 110.5),
                             controlPoint2: CGPoint(x: 66.97, y: 109.96))
      connectedIconPath.addLineToPoint(CGPoint(x: 67.6, y: 109.19))
      connectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 97.48),
                             controlPoint1: CGPoint(x: 67.68, y: 109.07),
                             controlPoint2: CGPoint(x: 76.64, y: 97.48))
      connectedIconPath.addCurveToPoint(CGPoint(x: 114.4, y: 109.18),
                             controlPoint1: CGPoint(x: 105.36, y: 97.48),
                             controlPoint2: CGPoint(x: 114.32, y: 109.07))
      connectedIconPath.addLineToPoint(CGPoint(x: 114.43, y: 109.16))
      connectedIconPath.addCurveToPoint(CGPoint(x: 117, y: 110.5),
                             controlPoint1: CGPoint(x: 115.03, y: 109.95),
                             controlPoint2: CGPoint(x: 115.93, y: 110.5))
      connectedIconPath.addCurveToPoint(CGPoint(x: 119.3, y: 109.55),
                             controlPoint1: CGPoint(x: 117.9, y: 110.5),
                             controlPoint2: CGPoint(x: 118.71, y: 110.14))
      connectedIconPath.addLineToPoint(CGPoint(x: 129.05, y: 99.8))
      connectedIconPath.addCurveToPoint(CGPoint(x: 130, y: 97.51),
                             controlPoint1: CGPoint(x: 129.64, y: 99.22),
                             controlPoint2: CGPoint(x: 130, y: 98.4))
      connectedIconPath.addCurveToPoint(CGPoint(x: 129.24, y: 95.49),
                             controlPoint1: CGPoint(x: 130, y: 96.73),
                             controlPoint2: CGPoint(x: 129.69, y: 96.05))
      connectedIconPath.addLineToPoint(CGPoint(x: 129.29, y: 95.45))
      connectedIconPath.closePath()
      connectedIconPath.moveToPoint(CGPoint(x: 103.66, y: 122.02))
      connectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 113.73),
                             controlPoint1: CGPoint(x: 103.49, y: 121.69),
                             controlPoint2: CGPoint(x: 99.41, y: 113.73))
      connectedIconPath.addCurveToPoint(CGPoint(x: 78.34, y: 122.02),
                             controlPoint1: CGPoint(x: 82.59, y: 113.73),
                             controlPoint2: CGPoint(x: 78.51, y: 121.69))
      connectedIconPath.addLineToPoint(CGPoint(x: 78.38, y: 122.05))
      connectedIconPath.addCurveToPoint(CGPoint(x: 78, y: 123.5),
                             controlPoint1: CGPoint(x: 78.16, y: 122.49),
                             controlPoint2: CGPoint(x: 78, y: 122.97))
      connectedIconPath.addCurveToPoint(CGPoint(x: 78.95, y: 125.8),
                             controlPoint1: CGPoint(x: 78, y: 124.4),
                             controlPoint2: CGPoint(x: 78.36, y: 125.21))
      connectedIconPath.addLineToPoint(CGPoint(x: 88.7, y: 135.55))
      connectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 136.5),
                             controlPoint1: CGPoint(x: 89.29, y: 136.14),
                             controlPoint2: CGPoint(x: 90.1, y: 136.5))
      connectedIconPath.addCurveToPoint(CGPoint(x: 93.3, y: 135.55),
                             controlPoint1: CGPoint(x: 91.9, y: 136.5),
                             controlPoint2: CGPoint(x: 92.71, y: 136.14))
      connectedIconPath.addLineToPoint(CGPoint(x: 103.05, y: 125.8))
      connectedIconPath.addCurveToPoint(CGPoint(x: 104, y: 123.5),
                             controlPoint1: CGPoint(x: 103.64, y: 125.21),
                             controlPoint2: CGPoint(x: 104, y: 124.4))
      connectedIconPath.addCurveToPoint(CGPoint(x: 103.62, y: 122.05),
                             controlPoint1: CGPoint(x: 104, y: 122.97),
                             controlPoint2: CGPoint(x: 103.84, y: 122.49))
      connectedIconPath.addLineToPoint(CGPoint(x: 103.66, y: 122.02))
      connectedIconPath.closePath()
      connectedIconPath.moveToPoint(CGPoint(x: 155.31, y: 69.49))
      connectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 38.99),
                             controlPoint1: CGPoint(x: 154.35, y: 68.25),
                             controlPoint2: CGPoint(x: 131.13, y: 38.99))
      connectedIconPath.addCurveToPoint(CGPoint(x: 26.69, y: 69.49),
                             controlPoint1: CGPoint(x: 50.87, y: 38.99),
                             controlPoint2: CGPoint(x: 27.65, y: 68.25))
      connectedIconPath.addLineToPoint(CGPoint(x: 26.74, y: 69.53))
      connectedIconPath.addCurveToPoint(CGPoint(x: 26, y: 71.51),
                             controlPoint1: CGPoint(x: 26.3, y: 70.09),
                             controlPoint2: CGPoint(x: 26, y: 70.76))
      connectedIconPath.addCurveToPoint(CGPoint(x: 26.95, y: 73.81),
                             controlPoint1: CGPoint(x: 26, y: 72.41),
                             controlPoint2: CGPoint(x: 26.36, y: 73.22))
      connectedIconPath.addLineToPoint(CGPoint(x: 36.7, y: 83.56))
      connectedIconPath.addCurveToPoint(CGPoint(x: 39, y: 84.51),
                             controlPoint1: CGPoint(x: 37.29, y: 84.15),
                             controlPoint2: CGPoint(x: 38.1, y: 84.51))
      connectedIconPath.addCurveToPoint(CGPoint(x: 41.56, y: 83.16),
                             controlPoint1: CGPoint(x: 40.07, y: 84.51),
                             controlPoint2: CGPoint(x: 40.97, y: 83.96))
      connectedIconPath.addLineToPoint(CGPoint(x: 41.6, y: 83.19))
      connectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 58.49),
                             controlPoint1: CGPoint(x: 41.79, y: 82.94),
                             controlPoint2: CGPoint(x: 60.58, y: 58.49))
      connectedIconPath.addCurveToPoint(CGPoint(x: 140.4, y: 83.19),
                             controlPoint1: CGPoint(x: 121.42, y: 58.49),
                             controlPoint2: CGPoint(x: 140.22, y: 82.94))
      connectedIconPath.addLineToPoint(CGPoint(x: 140.44, y: 83.16))
      connectedIconPath.addCurveToPoint(CGPoint(x: 143, y: 84.51),
                             controlPoint1: CGPoint(x: 141.03, y: 83.96),
                             controlPoint2: CGPoint(x: 141.93, y: 84.51))
      connectedIconPath.addCurveToPoint(CGPoint(x: 145.3, y: 83.56),
                             controlPoint1: CGPoint(x: 143.9, y: 84.51),
                             controlPoint2: CGPoint(x: 144.71, y: 84.15))
      connectedIconPath.addLineToPoint(CGPoint(x: 155.05, y: 73.81))
      connectedIconPath.addCurveToPoint(CGPoint(x: 156, y: 71.51),
                             controlPoint1: CGPoint(x: 155.64, y: 73.22),
                             controlPoint2: CGPoint(x: 156, y: 72.41))
      connectedIconPath.addCurveToPoint(CGPoint(x: 155.27, y: 69.53),
                             controlPoint1: CGPoint(x: 156, y: 70.76),
                             controlPoint2: CGPoint(x: 155.7, y: 70.09))
      connectedIconPath.addLineToPoint(CGPoint(x: 155.31, y: 69.49))
      connectedIconPath.closePath()
      iconColor.setFill()
      connectedIconPath.fill()
    }


    if (notConnected) {
      //// Not Connected Icon Drawing
      var notConnectedIconPath = UIBezierPath()
      notConnectedIconPath.moveToPoint(CGPoint(x: 103.66, y: 122.02))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 113.73),
                             controlPoint1: CGPoint(x: 103.49, y: 121.69),
                             controlPoint2: CGPoint(x: 99.41, y: 113.73))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 78.34, y: 122.02),
                             controlPoint1: CGPoint(x: 82.59, y: 113.73),
                             controlPoint2: CGPoint(x: 78.51, y: 121.69))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 78.38, y: 122.05))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 78, y: 123.5),
                             controlPoint1: CGPoint(x: 78.16, y: 122.49),
                             controlPoint2: CGPoint(x: 78, y: 122.97))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 78.95, y: 125.8),
                             controlPoint1: CGPoint(x: 78, y: 124.4),
                             controlPoint2: CGPoint(x: 78.36, y: 125.21))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 88.7, y: 135.55))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 136.5),
                             controlPoint1: CGPoint(x: 89.29, y: 136.14),
                             controlPoint2: CGPoint(x: 90.1, y: 136.5))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 93.3, y: 135.55),
                             controlPoint1: CGPoint(x: 91.9, y: 136.5),
                             controlPoint2: CGPoint(x: 92.71, y: 136.14))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 103.05, y: 125.8))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 104, y: 123.5),
                             controlPoint1: CGPoint(x: 103.64, y: 125.21),
                             controlPoint2: CGPoint(x: 104, y: 124.4))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 103.62, y: 122.05),
                             controlPoint1: CGPoint(x: 104, y: 122.97),
                             controlPoint2: CGPoint(x: 103.84, y: 122.49))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 103.66, y: 122.02))
      notConnectedIconPath.closePath()
      notConnectedIconPath.moveToPoint(CGPoint(x: 91, y: 128.66))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 85.46, y: 123.12))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 120.23),
                             controlPoint1: CGPoint(x: 86.61, y: 121.79),
                             controlPoint2: CGPoint(x: 88.47, y: 120.23))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 96.54, y: 123.12),
                             controlPoint1: CGPoint(x: 93.53, y: 120.23),
                             controlPoint2: CGPoint(x: 95.39, y: 121.79))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 91, y: 128.66))
      notConnectedIconPath.closePath()
      notConnectedIconPath.moveToPoint(CGPoint(x: 129.29, y: 95.45))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 77.99),
                             controlPoint1: CGPoint(x: 128.72, y: 94.74),
                             controlPoint2: CGPoint(x: 115.03, y: 77.99))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 52.71, y: 95.45),
                             controlPoint1: CGPoint(x: 66.96, y: 77.99),
                             controlPoint2: CGPoint(x: 53.28, y: 94.74))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 52.76, y: 95.49))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 52, y: 97.51),
                             controlPoint1: CGPoint(x: 52.31, y: 96.05),
                             controlPoint2: CGPoint(x: 52, y: 96.73))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 52.95, y: 99.8),
                             controlPoint1: CGPoint(x: 52, y: 98.4),
                             controlPoint2: CGPoint(x: 52.36, y: 99.22))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 62.7, y: 109.55))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 65, y: 110.5),
                             controlPoint1: CGPoint(x: 63.29, y: 110.14),
                             controlPoint2: CGPoint(x: 64.1, y: 110.5))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 67.56, y: 109.16),
                             controlPoint1: CGPoint(x: 66.07, y: 110.5),
                             controlPoint2: CGPoint(x: 66.97, y: 109.96))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 67.6, y: 109.19))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 97.48),
                             controlPoint1: CGPoint(x: 67.68, y: 109.07),
                             controlPoint2: CGPoint(x: 76.64, y: 97.48))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 114.4, y: 109.18),
                             controlPoint1: CGPoint(x: 105.36, y: 97.48),
                             controlPoint2: CGPoint(x: 114.32, y: 109.07))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 114.43, y: 109.16))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 117, y: 110.5),
                             controlPoint1: CGPoint(x: 115.03, y: 109.95),
                             controlPoint2: CGPoint(x: 115.93, y: 110.5))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 119.3, y: 109.55),
                             controlPoint1: CGPoint(x: 117.9, y: 110.5),
                             controlPoint2: CGPoint(x: 118.71, y: 110.14))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 129.05, y: 99.8))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 130, y: 97.51),
                             controlPoint1: CGPoint(x: 129.64, y: 99.22),
                             controlPoint2: CGPoint(x: 130, y: 98.4))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 129.24, y: 95.49),
                             controlPoint1: CGPoint(x: 130, y: 96.73),
                             controlPoint2: CGPoint(x: 129.69, y: 96.05))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 129.29, y: 95.45))
      notConnectedIconPath.closePath()
      notConnectedIconPath.moveToPoint(CGPoint(x: 117.15, y: 102.51))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 90.98),
                             controlPoint1: CGPoint(x: 113.04, y: 98.36),
                             controlPoint2: CGPoint(x: 103.97, y: 90.98))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 64.85, y: 102.51),
                             controlPoint1: CGPoint(x: 78.03, y: 90.98),
                             controlPoint2: CGPoint(x: 68.96, y: 98.36))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 59.76, y: 97.42))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 84.48),
                             controlPoint1: CGPoint(x: 63.97, y: 93.3),
                             controlPoint2: CGPoint(x: 74.86, y: 84.48))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 122.23, y: 97.43),
                             controlPoint1: CGPoint(x: 107.05, y: 84.48),
                             controlPoint2: CGPoint(x: 118, y: 93.31))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 117.15, y: 102.51))
      notConnectedIconPath.closePath()
      notConnectedIconPath.moveToPoint(CGPoint(x: 155.31, y: 69.49))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 38.99),
                             controlPoint1: CGPoint(x: 154.35, y: 68.25),
                             controlPoint2: CGPoint(x: 131.13, y: 38.99))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 26.69, y: 69.49),
                             controlPoint1: CGPoint(x: 50.87, y: 38.99),
                             controlPoint2: CGPoint(x: 27.65, y: 68.25))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 26.74, y: 69.53))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 26, y: 71.51),
                             controlPoint1: CGPoint(x: 26.3, y: 70.09),
                             controlPoint2: CGPoint(x: 26, y: 70.76))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 26.95, y: 73.81),
                             controlPoint1: CGPoint(x: 26, y: 72.41),
                             controlPoint2: CGPoint(x: 26.36, y: 73.22))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 36.7, y: 83.56))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 39, y: 84.51),
                             controlPoint1: CGPoint(x: 37.29, y: 84.15),
                             controlPoint2: CGPoint(x: 38.1, y: 84.51))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 41.56, y: 83.16),
                             controlPoint1: CGPoint(x: 40.07, y: 84.51),
                             controlPoint2: CGPoint(x: 40.97, y: 83.96))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 41.6, y: 83.19))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 58.49),
                             controlPoint1: CGPoint(x: 41.78, y: 82.94),
                             controlPoint2: CGPoint(x: 60.58, y: 58.49))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 140.4, y: 83.19),
                             controlPoint1: CGPoint(x: 121.42, y: 58.49),
                             controlPoint2: CGPoint(x: 140.22, y: 82.94))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 140.44, y: 83.16))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 143, y: 84.51),
                             controlPoint1: CGPoint(x: 141.03, y: 83.96),
                             controlPoint2: CGPoint(x: 141.93, y: 84.51))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 145.3, y: 83.56),
                             controlPoint1: CGPoint(x: 143.9, y: 84.51),
                             controlPoint2: CGPoint(x: 144.71, y: 84.15))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 155.05, y: 73.81))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 156, y: 71.51),
                             controlPoint1: CGPoint(x: 155.64, y: 73.22),
                             controlPoint2: CGPoint(x: 156, y: 72.41))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 155.26, y: 69.53),
                             controlPoint1: CGPoint(x: 156, y: 70.76),
                             controlPoint2: CGPoint(x: 155.7, y: 70.09))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 155.31, y: 69.49))
      notConnectedIconPath.closePath()
      notConnectedIconPath.moveToPoint(CGPoint(x: 143.22, y: 76.44))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 51.99),
                             controlPoint1: CGPoint(x: 136.94, y: 69.43),
                             controlPoint2: CGPoint(x: 118.55, y: 51.99))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 38.78, y: 76.44),
                             controlPoint1: CGPoint(x: 63.45, y: 51.99),
                             controlPoint2: CGPoint(x: 45.06, y: 69.43))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 33.69, y: 71.35))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 45.49),
                             controlPoint1: CGPoint(x: 39.68, y: 64.86),
                             controlPoint2: CGPoint(x: 60.13, y: 45.49))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 148.31, y: 71.35),
                             controlPoint1: CGPoint(x: 121.87, y: 45.49),
                             controlPoint2: CGPoint(x: 142.32, y: 64.86))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 143.22, y: 76.44))
      notConnectedIconPath.closePath()
      notConnectedIconPath.moveToPoint(CGPoint(x: 181.46, y: 43.82))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 181.52, y: 43.79))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 0),
                             controlPoint1: CGPoint(x: 180.42, y: 42),
                             controlPoint2: CGPoint(x: 153.85, y: 0))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 0.48, y: 43.79),
                             controlPoint1: CGPoint(x: 28.15, y: 0),
                             controlPoint2: CGPoint(x: 1.58, y: 42))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 0.54, y: 43.82))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 0, y: 45.52),
                             controlPoint1: CGPoint(x: 0.23, y: 44.33),
                             controlPoint2: CGPoint(x: 0, y: 44.88))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 0.95, y: 47.81),
                             controlPoint1: CGPoint(x: 0, y: 46.41),
                             controlPoint2: CGPoint(x: 0.36, y: 47.23))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 10.7, y: 57.56))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 13, y: 58.51),
                             controlPoint1: CGPoint(x: 11.29, y: 58.15),
                             controlPoint2: CGPoint(x: 12.1, y: 58.51))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 15.67, y: 57.02),
                             controlPoint1: CGPoint(x: 14.14, y: 58.51),
                             controlPoint2: CGPoint(x: 15.09, y: 57.9))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 15.7, y: 57.04))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 19.5),
                             controlPoint1: CGPoint(x: 15.95, y: 56.67),
                             controlPoint2: CGPoint(x: 41.31, y: 19.5))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 166.3, y: 57.05),
                             controlPoint1: CGPoint(x: 140.55, y: 19.5),
                             controlPoint2: CGPoint(x: 166.05, y: 56.67))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 166.34, y: 57.02))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 169, y: 58.51),
                             controlPoint1: CGPoint(x: 166.92, y: 57.9),
                             controlPoint2: CGPoint(x: 167.87, y: 58.51))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 171.3, y: 57.56),
                             controlPoint1: CGPoint(x: 169.9, y: 58.51),
                             controlPoint2: CGPoint(x: 170.71, y: 58.15))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 181.05, y: 47.81))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 182, y: 45.52),
                             controlPoint1: CGPoint(x: 181.64, y: 47.23),
                             controlPoint2: CGPoint(x: 182, y: 46.41))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 181.46, y: 43.82),
                             controlPoint1: CGPoint(x: 182, y: 44.88),
                             controlPoint2: CGPoint(x: 181.77, y: 44.33))
      notConnectedIconPath.closePath()
      notConnectedIconPath.moveToPoint(CGPoint(x: 169.37, y: 50.3))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 13),
                             controlPoint1: CGPoint(x: 161.79, y: 40.74),
                             controlPoint2: CGPoint(x: 135.93, y: 13))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 12.63, y: 50.3),
                             controlPoint1: CGPoint(x: 46.07, y: 13),
                             controlPoint2: CGPoint(x: 20.21, y: 40.74))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 7.46, y: 45.13))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 26.15, y: 26.8),
                             controlPoint1: CGPoint(x: 10.04, y: 41.63),
                             controlPoint2: CGPoint(x: 16.15, y: 34.18))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 91, y: 6.5),
                             controlPoint1: CGPoint(x: 38.7, y: 17.54),
                             controlPoint2: CGPoint(x: 60.13, y: 6.5))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 155.85, y: 26.8),
                             controlPoint1: CGPoint(x: 121.87, y: 6.5),
                             controlPoint2: CGPoint(x: 143.3, y: 17.54))
      notConnectedIconPath.addCurveToPoint(CGPoint(x: 174.54, y: 45.13),
                             controlPoint1: CGPoint(x: 165.85, y: 34.18),
                             controlPoint2: CGPoint(x: 171.96, y: 41.63))
      notConnectedIconPath.addLineToPoint(CGPoint(x: 169.37, y: 50.3))
      notConnectedIconPath.closePath()
      iconColor.setFill()
      notConnectedIconPath.fill()
    }
  }

  public class func drawWifiStatus(#iconColor: UIColor, connected: Bool, containingFrame: CGRect) {
    //// General Declarations
    let context = UIGraphicsGetCurrentContext()


    //// Variable Declarations
    let squaredContainingFrameSize = CGSize(
      width: min(containingFrame.size.width, containingFrame.size.height),
      height: min(containingFrame.size.width, containingFrame.size.height))
    let squaredContainingFrame = CGRect(
      x: containingFrame.origin.x + (containingFrame.size.width - squaredContainingFrameSize.width) / 2.0,
      y: containingFrame.origin.y + (containingFrame.size.height - squaredContainingFrameSize.height) / 2.0,
      width: squaredContainingFrameSize.width,
      height: squaredContainingFrameSize.height)
    let wifiFrame = CGRect(
      x: squaredContainingFrame.origin.x,
      y: squaredContainingFrame.origin.y + (squaredContainingFrame.size.height - squaredContainingFrame.size.width * 4.25 / 5.69) / 2.0,
      width: squaredContainingFrame.size.width,
      height: squaredContainingFrame.size.width * 4.25 / 5.69)

    //// Frames
    let frame = CGRect(
      x: wifiFrame.origin.x,
      y: wifiFrame.origin.y,
      width: wifiFrame.size.width,
      height: wifiFrame.size.height)


    //// Symbol Drawing
    let symbolRect = CGRect(
      x: frame.minX + floor(frame.width * 0.0 + 0.5),
      y: frame.minY + floor(frame.height * 0.0 - 0.5) + 1,
      width: floor(frame.width * 1.0 + 0.5) - floor(frame.width * 0.0 + 0.5),
      height: floor(frame.height * 1.0 + 0.05) - floor(frame.height * 0.0 - 0.5) - 0.55)
    UIGraphicsPushContext(context)
    UIRectClip(symbolRect)
    CGContextTranslateCTM(context, symbolRect.origin.x, symbolRect.origin.y)
    CGContextScaleCTM(context, symbolRect.size.width / 182, symbolRect.size.height / 136)

    DrawingKit.drawWifiIcon(iconColor: iconColor, connected: connected)
    UIGraphicsPopContext()
  }

  public class func drawRoundishButtonWithText(#color: UIColor, buttonText: String, addGloss: Bool, textFrame: CGRect, radius: CGFloat) {
    //// General Declarations
    let context = UIGraphicsGetCurrentContext()

    //// Color Declarations
    let strokeColor = color.colorWithHighlight(0.4)

    //// Variable Declarations
    let widthBasedFontSize: CGFloat = textFrame.size.width / CGFloat(count(buttonText.utf16))
    let heightBasedFontSize: CGFloat = textFrame.size.height
    let appliedFontSize: CGFloat = min(widthBasedFontSize, heightBasedFontSize)

    //// Frames
    let frame = CGRect(
      x: textFrame.origin.x,
      y: textFrame.origin.y,
      width: textFrame.size.width,
      height: textFrame.size.height)

    //// Subframes
    let group: CGRect = CGRect(
      x: frame.minX + floor(frame.width * 0.0 + 0.5),
      y: frame.minY + floor(frame.height * 0.0 + 0.5),
      width: floor(frame.width * 1.0 + 0.5) - floor(frame.width * 0.0 + 0.5),
      height: floor(frame.height * 1.0 + 0.5) - floor(frame.height * 0.0 + 0.5))


    //// Group
    UIGraphicsPushContext(context)
    CGContextBeginTransparencyLayer(context, nil)


    //// roundishButton Drawing
    let roundishButtonRect = CGRect(
      x: group.minX + floor(group.width * 0.0 + 0.5),
      y: group.minY + floor(group.height * 0.0 + 0.5),
      width: floor(group.width * 1.0 + 0.5) - floor(group.width * 0.0 + 0.5),
      height: floor(group.height * 1.0 + 0.5) - floor(group.height * 0.0 + 0.5))
    UIBezierPath(roundedRect: roundishButtonRect, cornerRadius: radius).addClip()
    UIGraphicsPushContext(context)
    //    UIRectClip(roundishButtonRect)
    CGContextTranslateCTM(context, roundishButtonRect.origin.x, roundishButtonRect.origin.y)

    DrawingKit.drawRoundishButtonBase(frame: CGRect(
      x: 0,
      y: 0,
      width: roundishButtonRect.size.width,
      height: roundishButtonRect.size.height), color: color, radius: radius)
    UIGraphicsPopContext()


    //// Label Group
    UIGraphicsPushContext(context)
    CGContextSetBlendMode(context, kCGBlendModeDifference)
    CGContextBeginTransparencyLayer(context, nil)


    //// label Drawing
    let labelRect = CGRect(
      x: group.minX + floor(group.width * 0.0 + 0.5),
      y: group.minY + floor(group.height * 0.0 + 0.5),
      width: floor(group.width * 1.0 + 0.5) - floor(group.width * 0.0 + 0.5),
      height: floor(group.height * 1.0 + 0.5) - floor(group.height * 0.0 + 0.5))
    UIGraphicsPushContext(context)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.insettingShadow.shadowOffset,
      DrawingKit.insettingShadow.shadowBlurRadius,
      (DrawingKit.insettingShadow.shadowColor as! UIColor).CGColor
    )
    let labelStyle = NSParagraphStyle.defaultParagraphStyle().mutableCopy() as! NSMutableParagraphStyle
    labelStyle.alignment = NSTextAlignment.Center

    let labelFontAttributes = [NSFontAttributeName: UIFont(name: "HelveticaNeue-Bold", size: appliedFontSize)!,
                               NSForegroundColorAttributeName: strokeColor,
                               NSParagraphStyleAttributeName: labelStyle]

    let labelTextHeight: CGFloat = NSString(string: buttonText).boundingRectWithSize(
      CGSize( width: labelRect.width, height: CGFloat.infinity),
      options: NSStringDrawingOptions.UsesLineFragmentOrigin,
      attributes: labelFontAttributes,
      context: nil).size.height
    let labelTextRect: CGRect = CGRect(
      x: labelRect.minX,
      y: labelRect.minY + (labelRect.height - labelTextHeight) / 2,
      width: labelRect.width,
      height: labelTextHeight)
    UIGraphicsPushContext(context)
    CGContextClipToRect(context, labelRect);
    NSString(string: buttonText).drawInRect(labelTextRect, withAttributes: labelFontAttributes)
    UIGraphicsPopContext()

    ////// label Text Inner Shadow
    UIGraphicsPushContext(context)
    CGContextClipToRect(context, labelRect)
    CGContextSetShadow(context, CGSize(width: 0, height: 0), 0)
    CGContextSetAlpha(context, CGColorGetAlpha((DrawingKit.cutoutShadow.shadowColor as! UIColor).CGColor))
    CGContextBeginTransparencyLayer(context, nil)
    let labelOpaqueTextShadow = (DrawingKit.cutoutShadow.shadowColor as! UIColor).colorWithAlphaComponent(1)
    CGContextSetShadowWithColor(
      context,
      DrawingKit.cutoutShadow.shadowOffset,
      DrawingKit.cutoutShadow.shadowBlurRadius,
      labelOpaqueTextShadow.CGColor
    )
    CGContextSetBlendMode(context, kCGBlendModeSourceOut)
    CGContextBeginTransparencyLayer(context, nil)

    labelOpaqueTextShadow.setFill()

    let labelInnerShadowFontAttributes = [NSFontAttributeName: UIFont(name: "HelveticaNeue-Bold", size: appliedFontSize)!,
                                          NSForegroundColorAttributeName: (DrawingKit.cutoutShadow.shadowColor as! UIColor),
                                          NSParagraphStyleAttributeName: labelStyle]
    NSString(string: buttonText).drawInRect(labelTextRect, withAttributes: labelInnerShadowFontAttributes)

    CGContextEndTransparencyLayer(context)
    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()


    UIGraphicsPopContext()



    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()


    //// Gloss Group
    UIGraphicsPushContext(context)
    CGContextSetBlendMode(context, kCGBlendModeSoftLight)
    CGContextBeginTransparencyLayer(context, nil)


    if (addGloss) {
      //// glossOverlay Drawing
      let glossOverlayRect = CGRect(
        x: group.minX + floor(group.width * 0.0 + 0.5),
        y: group.minY + floor(group.height * 0.0 + 0.5),
        width: floor(group.width * 1.0 + 0.5) - floor(group.width * 0.0 + 0.5),
        height: floor(group.height * 1.0 + 0.5) - floor(group.height * 0.0 + 0.5))
      UIGraphicsPushContext(context)
      UIRectClip(glossOverlayRect)
      CGContextTranslateCTM(context, glossOverlayRect.origin.x, glossOverlayRect.origin.y)

      DrawingKit.drawGloss(frame: CGRect(x: 0, y: 0, width: glossOverlayRect.size.width, height: glossOverlayRect.size.height))
      UIGraphicsPopContext()
    }


    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()


    CGContextEndTransparencyLayer(context)
    UIGraphicsPopContext()
  }

}



extension UIColor {
  func colorWithHue(newHue: CGFloat) -> UIColor {
    var saturation: CGFloat = 1.0, brightness: CGFloat = 1.0, alpha: CGFloat = 1.0
    self.getHue(nil, saturation: &saturation, brightness: &brightness, alpha: &alpha)
    return UIColor(hue: newHue, saturation: saturation, brightness: brightness, alpha: alpha)
  }
  func colorWithSaturation(newSaturation: CGFloat) -> UIColor {
    var hue: CGFloat = 1.0, brightness: CGFloat = 1.0, alpha: CGFloat = 1.0
    self.getHue(&hue, saturation: nil, brightness: &brightness, alpha: &alpha)
    return UIColor(hue: hue, saturation: newSaturation, brightness: brightness, alpha: alpha)
  }
  func colorWithBrightness(newBrightness: CGFloat) -> UIColor {
    var hue: CGFloat = 1.0, saturation: CGFloat = 1.0, alpha: CGFloat = 1.0
    self.getHue(&hue, saturation: &saturation, brightness: nil, alpha: &alpha)
    return UIColor(hue: hue, saturation: saturation, brightness: newBrightness, alpha: alpha)
  }
  func colorWithAlpha(newAlpha: CGFloat) -> UIColor {
    var hue: CGFloat = 1.0, saturation: CGFloat = 1.0, brightness: CGFloat = 1.0
    self.getHue(&hue, saturation: &saturation, brightness: &brightness, alpha: nil)
    return UIColor(hue: hue, saturation: saturation, brightness: brightness, alpha: newAlpha)
  }
  func colorWithHighlight(highlight: CGFloat) -> UIColor {
    var red: CGFloat = 1.0, green: CGFloat = 1.0, blue: CGFloat = 1.0, alpha: CGFloat = 1.0
    self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
    return UIColor(red: red * (1-highlight) + highlight,
                   green: green * (1-highlight) + highlight,
                   blue: blue * (1-highlight) + highlight,
                   alpha: alpha * (1-highlight) + highlight)
  }
  func colorWithShadow(shadow: CGFloat) -> UIColor {
    var red: CGFloat = 1.0, green: CGFloat = 1.0, blue: CGFloat = 1.0, alpha: CGFloat = 1.0
    self.getRed(&red, green: &green, blue: &blue, alpha: &alpha)
    return UIColor(red: red * (1-shadow), green: green * (1-shadow), blue: blue * (1-shadow), alpha: alpha * (1-shadow) + shadow)
  }
  func blendedColorWithFraction(fraction: CGFloat, ofColor color: UIColor) -> UIColor {
    var r1: CGFloat = 1.0, g1: CGFloat = 1.0, b1: CGFloat = 1.0, a1: CGFloat = 1.0
    var r2: CGFloat = 1.0, g2: CGFloat = 1.0, b2: CGFloat = 1.0, a2: CGFloat = 1.0

    self.getRed(&r1, green: &g1, blue: &b1, alpha: &a1)
    color.getRed(&r2, green: &g2, blue: &b2, alpha: &a2)

    return UIColor(red: r1 * (1 - fraction) + r2 * fraction,
      green: g1 * (1 - fraction) + g2 * fraction,
      blue: b1 * (1 - fraction) + b2 * fraction,
      alpha: a1 * (1 - fraction) + a2 * fraction);
  }
}



extension NSShadow {
  convenience init(color: AnyObject!, offset: CGSize, blurRadius: CGFloat) {
    self.init()
    self.shadowColor = color
    self.shadowOffset = offset
    self.shadowBlurRadius = blurRadius
  }
}

@objc protocol StyleKitSettableImage {
  func setImage(image: UIImage!)
}

@objc protocol StyleKitSettableSelectedImage {
  func setSelectedImage(image: UIImage!)
}
